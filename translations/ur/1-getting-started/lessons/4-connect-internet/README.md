<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "71b5040e0b3472f1c0949c9b55f224c0",
  "translation_date": "2025-08-26T23:14:16+00:00",
  "source_file": "1-getting-started/lessons/4-connect-internet/README.md",
  "language_code": "ur"
}
-->
# اپنے ڈیوائس کو انٹرنیٹ سے کنیکٹ کریں

![اس سبق کا خاکہ](../../../../../translated_images/lesson-4.7344e074ea68fa545fd320b12dce36d72dd62d28c3b4596cb26cf315f434b98f.ur.jpg)

> خاکہ [نیتیا نرسمہن](https://github.com/nitya) کی طرف سے۔ تصویر پر کلک کریں تاکہ بڑا ورژن دیکھ سکیں۔

یہ سبق [ہیلو IoT سیریز](https://youtube.com/playlist?list=PLmsFUfdnGr3xRts0TIwyaHyQuHaNQcb6-) کے حصے کے طور پر [مائیکروسافٹ ری ایکٹر](https://developer.microsoft.com/reactor/?WT.mc_id=academic-17441-jabenn) میں پڑھایا گیا تھا۔ یہ سبق دو ویڈیوز میں پیش کیا گیا - ایک گھنٹے کا سبق اور ایک گھنٹے کا دفتر وقت جس میں سبق کے مختلف حصوں پر مزید گہرائی سے بات کی گئی اور سوالات کے جوابات دیے گئے۔

[![سبق 4: اپنے ڈیوائس کو انٹرنیٹ سے کنیکٹ کریں](https://img.youtube.com/vi/O4dd172mZhs/0.jpg)](https://youtu.be/O4dd172mZhs)

[![سبق 4: اپنے ڈیوائس کو انٹرنیٹ سے کنیکٹ کریں - دفتر وقت](https://img.youtube.com/vi/j-cVCzRDE2Q/0.jpg)](https://youtu.be/j-cVCzRDE2Q)

> 🎥 اوپر دی گئی تصاویر پر کلک کریں تاکہ ویڈیوز دیکھ سکیں

## سبق سے پہلے کا کوئز

[سبق سے پہلے کا کوئز](https://black-meadow-040d15503.1.azurestaticapps.net/quiz/7)

## تعارف

IoT میں **I** کا مطلب **انٹرنیٹ** ہے - وہ کلاؤڈ کنیکٹیویٹی اور سروسز جو IoT ڈیوائسز کی بہت سی خصوصیات کو ممکن بناتی ہیں، جیسے سینسرز سے ڈیٹا اکٹھا کرنا اور ایکچیویٹرز کو کنٹرول کرنے کے لیے پیغامات بھیجنا۔ IoT ڈیوائسز عام طور پر ایک کلاؤڈ IoT سروس سے ایک معیاری کمیونیکیشن پروٹوکول کے ذریعے جڑتی ہیں، اور وہ سروس آپ کی IoT ایپلیکیشن کے باقی حصے سے جڑی ہوتی ہے، جیسے AI سروسز جو آپ کے ڈیٹا پر سمارٹ فیصلے کرتی ہیں، یا ویب ایپس جو کنٹرول یا رپورٹنگ کے لیے استعمال ہوتی ہیں۔

> 🎓 سینسرز سے اکٹھا کیا گیا ڈیٹا جو کلاؤڈ کو بھیجا جاتا ہے اسے ٹیلیمیٹری کہا جاتا ہے۔

IoT ڈیوائسز کلاؤڈ سے پیغامات وصول کر سکتی ہیں۔ اکثر یہ پیغامات کمانڈز پر مشتمل ہوتے ہیں - یعنی وہ ہدایات جو کسی عمل کو انجام دینے کے لیے دی جاتی ہیں، چاہے وہ اندرونی ہو (جیسے ریبوٹ یا فرم ویئر اپڈیٹ)، یا ایکچیویٹر کے ذریعے (جیسے لائٹ آن کرنا)۔

یہ سبق ان کمیونیکیشن پروٹوکولز کا تعارف کراتا ہے جو IoT ڈیوائسز کلاؤڈ سے جڑنے کے لیے استعمال کر سکتی ہیں، اور وہ ڈیٹا کی اقسام جو وہ بھیج یا وصول کر سکتی ہیں۔ آپ ان دونوں کے ساتھ عملی تجربہ بھی حاصل کریں گے، اپنی نائٹ لائٹ میں انٹرنیٹ کنٹرول شامل کریں گے، اور LED کنٹرول لاجک کو 'سرور' کوڈ میں منتقل کریں گے جو مقامی طور پر چل رہا ہوگا۔

اس سبق میں ہم درج ذیل موضوعات کا احاطہ کریں گے:

* [کمیونیکیشن پروٹوکولز](../../../../../1-getting-started/lessons/4-connect-internet)
* [میسج کیوئنگ ٹیلیمیٹری ٹرانسپورٹ (MQTT)](../../../../../1-getting-started/lessons/4-connect-internet)
* [ٹیلیمیٹری](../../../../../1-getting-started/lessons/4-connect-internet)
* [کمانڈز](../../../../../1-getting-started/lessons/4-connect-internet)

## کمیونیکیشن پروٹوکولز

IoT ڈیوائسز کے انٹرنیٹ سے بات چیت کرنے کے لیے کئی مشہور کمیونیکیشن پروٹوکولز موجود ہیں۔ سب سے زیادہ مقبول پروٹوکولز پبلش/سبسکرائب میسجنگ پر مبنی ہیں جو کسی قسم کے بروکر کے ذریعے کام کرتے ہیں۔ IoT ڈیوائسز بروکر سے جڑتی ہیں، ٹیلیمیٹری پبلش کرتی ہیں اور کمانڈز کو سبسکرائب کرتی ہیں۔ کلاؤڈ سروسز بھی بروکر سے جڑتی ہیں، تمام ٹیلیمیٹری پیغامات کو سبسکرائب کرتی ہیں اور کمانڈز پبلش کرتی ہیں، چاہے وہ مخصوص ڈیوائسز کے لیے ہوں یا ڈیوائسز کے گروپس کے لیے۔

![IoT ڈیوائسز بروکر سے جڑتی ہیں، ٹیلیمیٹری پبلش کرتی ہیں اور کمانڈز کو سبسکرائب کرتی ہیں۔ کلاؤڈ سروسز بروکر سے جڑتی ہیں، تمام ٹیلیمیٹری کو سبسکرائب کرتی ہیں اور مخصوص ڈیوائسز کو کمانڈز بھیجتی ہیں۔](../../../../../translated_images/pub-sub.7c7ed43fe9fd15d4e1f81a3fd95440413c457acd9bcbe9a43341e30e88db5264.ur.png)

MQTT IoT ڈیوائسز کے لیے سب سے زیادہ مقبول کمیونیکیشن پروٹوکول ہے اور اس سبق میں اس کا احاطہ کیا گیا ہے۔ دیگر پروٹوکولز میں AMQP اور HTTP/HTTPS شامل ہیں۔

## میسج کیوئنگ ٹیلیمیٹری ٹرانسپورٹ (MQTT)

[MQTT](http://mqtt.org) ایک ہلکا پھلکا، اوپن اسٹینڈرڈ میسجنگ پروٹوکول ہے جو ڈیوائسز کے درمیان پیغامات بھیج سکتا ہے۔ اسے 1999 میں آئل پائپ لائنز کی نگرانی کے لیے ڈیزائن کیا گیا تھا، اور 15 سال بعد IBM نے اسے اوپن اسٹینڈرڈ کے طور پر جاری کیا۔

MQTT میں ایک بروکر اور متعدد کلائنٹس ہوتے ہیں۔ تمام کلائنٹس بروکر سے جڑتے ہیں، اور بروکر پیغامات کو متعلقہ کلائنٹس تک پہنچاتا ہے۔ پیغامات کو نامزد موضوعات کے ذریعے پہنچایا جاتا ہے، بجائے اس کے کہ انہیں براہ راست کسی کلائنٹ کو بھیجا جائے۔ ایک کلائنٹ کسی موضوع پر پبلش کر سکتا ہے، اور جو کلائنٹس اس موضوع کو سبسکرائب کرتے ہیں وہ پیغام وصول کریں گے۔

![IoT ڈیوائس /telemetry موضوع پر ٹیلیمیٹری پبلش کر رہا ہے، اور کلاؤڈ سروس اس موضوع کو سبسکرائب کر رہی ہے](../../../../../translated_images/mqtt.cbf7f21d9adc3e17548b359444cc11bb4bf2010543e32ece9a47becf54438c23.ur.png)

✅ تحقیق کریں۔ اگر آپ کے پاس بہت زیادہ IoT ڈیوائسز ہوں، تو آپ کیسے یقینی بنائیں گے کہ آپ کا MQTT بروکر تمام پیغامات کو سنبھال سکتا ہے؟

### اپنے IoT ڈیوائس کو MQTT سے کنیکٹ کریں

اپنی نائٹ لائٹ میں انٹرنیٹ کنٹرول شامل کرنے کا پہلا حصہ اسے MQTT بروکر سے کنیکٹ کرنا ہے۔

#### کام

اپنے ڈیوائس کو MQTT بروکر سے کنیکٹ کریں۔

اس سبق کے اس حصے میں، آپ اپنی IoT نائٹ لائٹ کو انٹرنیٹ سے کنیکٹ کریں گے تاکہ اسے دور سے کنٹرول کیا جا سکے۔ بعد میں اس سبق میں، آپ کا IoT ڈیوائس MQTT کے ذریعے روشنی کی سطح کے ساتھ ٹیلیمیٹری پیغام ایک عوامی MQTT بروکر کو بھیجے گا، جہاں یہ آپ کے لکھے ہوئے کچھ سرور کوڈ کے ذریعے اٹھایا جائے گا۔ یہ کوڈ روشنی کی سطح کو چیک کرے گا اور ڈیوائس کو LED آن یا آف کرنے کی ہدایت کے ساتھ کمانڈ پیغام واپس بھیجے گا۔

ایسی ترتیب کے لیے حقیقی دنیا کا استعمال یہ ہو سکتا ہے کہ متعدد روشنی سینسرز سے ڈیٹا اکٹھا کیا جائے اس سے پہلے کہ روشنیوں کو آن کرنے کا فیصلہ کیا جائے، کسی ایسے مقام پر جہاں بہت زیادہ روشنی ہو، جیسے اسٹیڈیم۔ یہ روشنیوں کو آن ہونے سے روک سکتا ہے اگر صرف ایک سینسر بادلوں یا پرندے سے ڈھکا ہوا ہو، لیکن دوسرے سینسرز کافی روشنی کا پتہ لگاتے ہوں۔

✅ کون سی دیگر صورتحالیں ہوں گی جہاں کمانڈز بھیجنے سے پہلے متعدد سینسرز سے ڈیٹا کا جائزہ لینا ضروری ہوگا؟

اس اسائنمنٹ کے حصے کے طور پر MQTT بروکر سیٹ اپ کرنے کی پیچیدگیوں سے نمٹنے کے بجائے، آپ ایک عوامی ٹیسٹ سرور استعمال کر سکتے ہیں جو [ایکلپس موسکیٹو](https://www.mosquitto.org) چلاتا ہے، جو ایک اوپن سورس MQTT بروکر ہے۔ یہ ٹیسٹ بروکر عوامی طور پر [test.mosquitto.org](https://test.mosquitto.org) پر دستیاب ہے، اور اکاؤنٹ سیٹ اپ کرنے کی ضرورت نہیں ہے، جو MQTT کلائنٹس اور سرورز کی جانچ کے لیے ایک بہترین ٹول بناتا ہے۔

> 💁 یہ ٹیسٹ بروکر عوامی اور غیر محفوظ ہے۔ جو کچھ آپ پبلش کرتے ہیں اسے کوئی بھی سن سکتا ہے، لہذا اسے کسی ایسے ڈیٹا کے ساتھ استعمال نہیں کیا جانا چاہیے جسے نجی رکھنا ضروری ہو۔

![اسائنمنٹ کا فلو چارٹ، روشنی کی سطح کو پڑھنے اور چیک کرنے، اور LED کو کنٹرول کرنے کو دکھا رہا ہے](../../../../../translated_images/assignment-1-internet-flow.3256feab5f052fd273bf4e331157c574c2c3fa42e479836fc9c3586f41db35a5.ur.png)

اپنے ڈیوائس کو MQTT بروکر سے کنیکٹ کرنے کے لیے نیچے دیے گئے متعلقہ مرحلے پر عمل کریں:

* [Arduino - Wio Terminal](wio-terminal-mqtt.md)
* [سنگل بورڈ کمپیوٹر - Raspberry Pi/ورچوئل IoT ڈیوائس](single-board-computer-mqtt.md)

### MQTT کے بارے میں مزید گہرائی سے معلومات

موضوعات میں ایک درجہ بندی ہو سکتی ہے، اور کلائنٹس وائلڈ کارڈز کا استعمال کرتے ہوئے درجہ بندی کے مختلف سطحوں کو سبسکرائب کر سکتے ہیں۔ مثال کے طور پر، آپ درجہ حرارت ٹیلیمیٹری پیغامات کو `/telemetry/temperature` موضوع پر بھیج سکتے ہیں اور نمی کے پیغامات کو `/telemetry/humidity` موضوع پر بھیج سکتے ہیں، پھر اپنی کلاؤڈ ایپ میں `/telemetry/*` موضوع کو سبسکرائب کر سکتے ہیں تاکہ درجہ حرارت اور نمی دونوں ٹیلیمیٹری پیغامات وصول کیے جا سکیں۔

پیغامات کو کوالٹی آف سروس (QoS) کے ساتھ بھیجا جا سکتا ہے، جو پیغام کے وصول ہونے کی ضمانت کا تعین کرتا ہے۔

* زیادہ سے زیادہ ایک بار - پیغام صرف ایک بار بھیجا جاتا ہے اور کلائنٹ اور بروکر اضافی اقدامات نہیں کرتے کہ ترسیل کی تصدیق کریں (فائر اینڈ فارگیٹ)۔
* کم از کم ایک بار - پیغام بھیجنے والے کے ذریعے متعدد بار دوبارہ کوشش کی جاتی ہے جب تک کہ تصدیق موصول نہ ہو (تصدیق شدہ ترسیل)۔
* بالکل ایک بار - بھیجنے والا اور وصول کرنے والا دو سطحی ہینڈ شیک میں مشغول ہوتے ہیں تاکہ یہ یقینی بنایا جا سکے کہ پیغام کی صرف ایک کاپی وصول کی گئی ہے (یقینی ترسیل)۔

✅ کون سی صورتحالیں ہوں گی جہاں یقینی ترسیل والے پیغام کی ضرورت ہوگی بجائے فائر اینڈ فارگیٹ پیغام کے؟

اگرچہ نام میسج کیوئنگ (MQTT میں ابتدائی حروف)، یہ دراصل میسج کیوئنگ کو سپورٹ نہیں کرتا۔ اس کا مطلب یہ ہے کہ اگر کوئی کلائنٹ منقطع ہو جائے، پھر دوبارہ جڑ جائے تو وہ منقطع ہونے کے دوران بھیجے گئے پیغامات وصول نہیں کرے گا، سوائے ان پیغامات کے جنہیں وہ پہلے ہی QoS عمل کے ذریعے پروسیس کرنا شروع کر چکا تھا۔ پیغامات پر ایک ریٹینڈ فلیگ سیٹ کیا جا سکتا ہے۔ اگر یہ سیٹ ہو، تو MQTT بروکر اس موضوع پر بھیجے گئے آخری پیغام کو اس فلیگ کے ساتھ اسٹور کرے گا، اور اس موضوع کو بعد میں سبسکرائب کرنے والے کسی بھی کلائنٹ کو یہ پیغام بھیجے گا۔ اس طرح، کلائنٹس ہمیشہ تازہ ترین پیغام حاصل کریں گے۔

MQTT ایک کیپ الائیو فنکشن کو بھی سپورٹ کرتا ہے جو پیغامات کے درمیان طویل وقفوں کے دوران کنکشن کے زندہ ہونے کی جانچ کرتا ہے۔

> 🦟 [ایکلپس فاؤنڈیشن سے موسکیٹو](https://mosquitto.org) ایک مفت MQTT بروکر ہے جسے آپ خود چلانے کے لیے استعمال کر سکتے ہیں تاکہ MQTT کے ساتھ تجربہ کریں، اور ایک عوامی MQTT بروکر جو آپ کے کوڈ کی جانچ کے لیے استعمال کیا جا سکتا ہے، [test.mosquitto.org](https://test.mosquitto.org) پر میزبانی کی گئی ہے۔

MQTT کنکشنز عوامی اور کھلے ہو سکتے ہیں، یا صارف نام اور پاس ورڈز، یا سرٹیفکیٹس کا استعمال کرتے ہوئے انکرپٹ اور محفوظ کیے جا سکتے ہیں۔

> 💁 MQTT TCP/IP پر بات چیت کرتا ہے، وہی بنیادی نیٹ ورک پروٹوکول جو HTTP کے طور پر استعمال ہوتا ہے، لیکن مختلف پورٹ پر۔ آپ MQTT کو ویب ساکٹس کے ذریعے بھی استعمال کر سکتے ہیں تاکہ ویب ایپس کے ساتھ بات چیت کریں جو براؤزر میں چل رہی ہوں، یا ایسی صورتحال میں جہاں فائر والز یا دیگر نیٹ ورکنگ قواعد معیاری MQTT کنکشنز کو بلاک کرتے ہوں۔

## ٹیلیمیٹری

لفظ ٹیلیمیٹری یونانی جڑوں سے ماخوذ ہے جس کا مطلب ہے دور سے پیمائش کرنا۔ ٹیلیمیٹری سینسرز سے ڈیٹا اکٹھا کرنے اور اسے کلاؤڈ کو بھیجنے کا عمل ہے۔

> 💁 ابتدائی ٹیلیمیٹری ڈیوائسز میں سے ایک 1874 میں فرانس میں ایجاد کی گئی تھی اور مونٹ بلانک سے پیرس تک حقیقی وقت میں موسم اور برف کی گہرائی بھیجتی تھی۔ یہ جسمانی تاروں کا استعمال کرتی تھی کیونکہ اس وقت وائرلیس ٹیکنالوجیز دستیاب نہیں تھیں۔

سبق 1 میں سمارٹ تھرموسٹیٹ کی مثال پر دوبارہ نظر ڈالیں۔

![ایک انٹرنیٹ سے جڑا تھرموسٹیٹ جو متعدد کمرے کے سینسرز استعمال کر رہا ہے](../../../../../translated_images/telemetry.21e5d8b97649d2ebeb0f68d4b9691ab2d1f7bd629338e131465aff8a614e4d4a.ur.png)

تھرموسٹیٹ کے پاس ٹیلیمیٹری اکٹھا کرنے کے لیے درجہ حرارت سینسرز ہیں۔ اس میں سب سے زیادہ امکان ہے کہ ایک درجہ حرارت سینسر بلٹ ان ہو، اور یہ ایک وائرلیس پروٹوکول جیسے [بلوٹوتھ لو انرجی](https://wikipedia.org/wiki/Bluetooth_Low_Energy) (BLE) کے ذریعے متعدد بیرونی درجہ حرارت سینسرز سے جڑ سکتا ہے۔

اس کے بھیجے گئے ٹیلیمیٹری ڈیٹا کی ایک مثال یہ ہو سکتی ہے:

| نام | قدر | وضاحت |
| ---- | ----- | ----------- |
| `thermostat_temperature` | 18°C | تھرموسٹیٹ کے بلٹ ان درجہ حرارت سینسر کے ذریعے ماپا گیا درجہ حرارت |
| `livingroom_temperature` | 19°C | ایک ریموٹ درجہ حرارت سینسر کے ذریعے ماپا گیا درجہ حرارت جسے `livingroom` نام دیا گیا ہے تاکہ اس کمرے کی شناخت کی جا سکے جس میں یہ ہے |
| `bedroom_temperature` | 21°C | ایک ریموٹ درجہ حرارت سینسر کے ذریعے ماپا گیا درجہ حرارت جسے `bedroom` نام دیا گیا ہے تاکہ اس کمرے کی شناخت کی جا سکے جس میں یہ ہے |

کلاؤڈ سروس پھر اس ٹیلیمیٹری ڈیٹا کا استعمال کر سکتی ہے تاکہ ہیٹنگ کو کنٹرول کرنے کے لیے کون سے کمانڈز بھیجنے ہیں اس کے بارے میں فیصلے کرے۔

### اپنے IoT ڈیوائس سے ٹیلیمیٹری بھیجیں

اپنی نائٹ لائٹ میں انٹرنیٹ کنٹرول شامل کرنے کا اگلا حصہ روشنی کی سطح کی ٹیلیمیٹری کو ٹیلیمیٹری موضوع پر MQTT بروکر کو بھیجنا ہے۔

#### کام - اپنے IoT ڈیوائس سے ٹیلیمیٹری بھیجیں

روشنی کی سطح کی ٹیلیمیٹری MQTT بروکر کو بھیجیں۔

ڈیٹا JSON کے طور پر انکوڈ کیا جاتا ہے - جاوا اسکرپٹ آبجیکٹ نوٹیشن کا مخفف، جو کلیدی/قدر کے جوڑوں کا استعمال کرتے ہوئے متن میں ڈیٹا انکوڈ کرنے کا ایک معیار ہے۔

✅ اگر آپ نے پہلے JSON کے بارے میں نہیں سنا، تو آپ [JSON.org دستاویزات](https://www.json.org/) پر اس کے بارے میں مزید جان سکتے ہیں۔

اپنے ڈیوائس سے MQTT بروکر کو ٹیلیمیٹری بھیجنے کے لیے نیچے دیے گئے متعلقہ مرحلے پر عمل کریں:

* [Arduino - Wio Terminal](wio-terminal-telemetry.md)
* [سنگل بورڈ کمپیوٹر - Raspberry Pi/ورچوئل IoT ڈیوائس](single-board-computer-telemetry.md)

### MQTT بروکر سے ٹیلیمیٹری وصول کریں

ٹیلیمیٹری بھیجنے کا کوئی فائدہ نہیں اگر دوسری طرف کوئی اسے سننے والا نہ ہو۔ روشنی کی سطح کی ٹیلیمیٹری کو اسے پروسیس کرنے کے لیے کچھ سننے کی ضرورت ہے۔ یہ 'سرور' کوڈ وہ قسم کا کوڈ ہے جسے آپ ایک بڑی IoT ایپلیکیشن کے حصے کے طور پر کلاؤڈ سروس پر تعینات کریں گے، لیکن یہاں آپ یہ کوڈ اپنے کمپیوٹر پر مقامی طور پر چلائیں گے (یا اپنے Pi پر اگر آپ براہ راست وہاں کوڈنگ کر رہے ہیں)۔ سرور کوڈ ایک Python ایپ پر مشتمل ہے جو روشنی کی سطح کے ساتھ MQTT کے ذریعے ٹیلیمیٹری پیغامات سنتی ہے۔ بعد میں اس سبق میں آپ اسے LED کو آن یا آف کرنے کی ہدایت کے ساتھ کمانڈ پیغام کے ساتھ جواب دینے کے لیے بنائیں گے۔

✅ تحقیق کریں: MQTT پیغامات کے ساتھ کیا ہوتا ہے اگر کوئی سننے والا نہ ہو؟

#### Python اور VS Code انسٹال کریں

اگر آپ کے پاس Python اور VS Code مقامی طور پر انسٹال نہیں ہیں، تو آپ کو سرور کوڈ لکھنے کے لیے دونوں کو انسٹال کرنا ہوگا۔ اگر آپ ورچوئل IoT ڈیوائس استعمال کر رہے ہیں، یا اپنے
💁 آپ ان اسباق کے لیے کسی بھی Python IDE یا ایڈیٹر استعمال کرنے کے لیے آزاد ہیں اگر آپ کے پاس کوئی پسندیدہ ٹول ہے، لیکن اسباق میں ہدایات VS Code کے استعمال پر مبنی ہوں گی۔
1. VS Code میں Pylance ایکسٹینشن انسٹال کریں۔ یہ ایکسٹینشن Python زبان کی سپورٹ فراہم کرتی ہے۔ اس ایکسٹینشن کو VS Code میں انسٹال کرنے کے لیے [Pylance extension documentation](https://marketplace.visualstudio.com/items?WT.mc_id=academic-17441-jabenn&itemName=ms-python.vscode-pylance) کا حوالہ لیں۔

#### Python ورچوئل ماحول کو ترتیب دیں

Python کی ایک طاقتور خصوصیت [pip پیکجز](https://pypi.org) انسٹال کرنے کی صلاحیت ہے - یہ انٹرنیٹ پر شائع کردہ دوسرے لوگوں کے لکھے ہوئے کوڈ کے پیکجز ہیں۔ آپ ایک کمانڈ کے ذریعے اپنے کمپیوٹر پر pip پیکج انسٹال کر سکتے ہیں اور پھر اپنے کوڈ میں اس پیکج کا استعمال کر سکتے ہیں۔ آپ MQTT پر کمیونیکیٹ کرنے کے لیے ایک پیکج انسٹال کرنے کے لیے pip استعمال کریں گے۔

جب آپ ڈیفالٹ طور پر کوئی پیکج انسٹال کرتے ہیں تو وہ آپ کے کمپیوٹر پر ہر جگہ دستیاب ہوتا ہے، اور یہ پیکج ورژنز کے مسائل پیدا کر سکتا ہے - جیسے کہ ایک ایپلیکیشن کسی پیکج کے ایک ورژن پر انحصار کرتی ہے جو کسی دوسرے ایپلیکیشن کے لیے نیا ورژن انسٹال کرنے پر خراب ہو جاتا ہے۔ اس مسئلے سے بچنے کے لیے، آپ [Python ورچوئل ماحول](https://docs.python.org/3/library/venv.html) استعمال کر سکتے ہیں، جو کہ Python کی ایک کاپی ایک مخصوص فولڈر میں رکھتا ہے، اور جب آپ pip پیکجز انسٹال کرتے ہیں تو وہ صرف اسی فولڈر میں انسٹال ہوتے ہیں۔

##### کام - Python ورچوئل ماحول کو ترتیب دیں

Python ورچوئل ماحول کو ترتیب دیں اور MQTT pip پیکجز انسٹال کریں۔

1. اپنے ٹرمینل یا کمانڈ لائن سے، اپنی پسند کے کسی مقام پر درج ذیل کمانڈز چلائیں تاکہ ایک نیا ڈائریکٹری بنائیں اور اس میں جائیں:

    ```sh
    mkdir nightlight-server
    cd nightlight-server
    ```

1. اب `.venv` فولڈر میں ایک ورچوئل ماحول بنانے کے لیے درج ذیل کمانڈ چلائیں:

    ```sh
    python3 -m venv .venv
    ```

    > 💁 آپ کو ورچوئل ماحول بنانے کے لیے `python3` کو واضح طور پر کال کرنا ہوگا، خاص طور پر اگر آپ کے پاس Python 2 بھی انسٹال ہو۔ اگر Python 2 انسٹال ہے تو `python` کال کرنے سے Python 2 استعمال ہوگا بجائے Python 3 کے۔

1. ورچوئل ماحول کو ایکٹیویٹ کریں:

    * ونڈوز پر:
        * اگر آپ کمانڈ پرامپٹ یا ونڈوز ٹرمینل کے ذریعے کمانڈ پرامپٹ استعمال کر رہے ہیں، تو درج ذیل چلائیں:

            ```cmd
            .venv\Scripts\activate.bat
            ```

        * اگر آپ پاور شیل استعمال کر رہے ہیں، تو درج ذیل چلائیں:

            ```powershell
            .\.venv\Scripts\Activate.ps1
            ```

    * macOS یا Linux پر، درج ذیل چلائیں:

        ```cmd
        source ./.venv/bin/activate
        ```

    > 💁 یہ کمانڈز اسی مقام سے چلائی جانی چاہئیں جہاں آپ نے ورچوئل ماحول بنانے کی کمانڈ چلائی تھی۔ آپ کو کبھی بھی `.venv` فولڈر میں نیویگیٹ کرنے کی ضرورت نہیں ہوگی، آپ کو ہمیشہ ایکٹیویٹ کمانڈ اور پیکجز انسٹال کرنے یا کوڈ چلانے کے لیے وہی فولڈر استعمال کرنا ہوگا جہاں آپ نے ورچوئل ماحول بنایا تھا۔

1. ایک بار ورچوئل ماحول ایکٹیویٹ ہو جائے تو ڈیفالٹ `python` کمانڈ وہ Python ورژن چلائے گی جو ورچوئل ماحول بنانے کے لیے استعمال ہوا تھا۔ درج ذیل کمانڈ چلائیں تاکہ ورژن معلوم ہو:

    ```sh
    python --version
    ```

    آؤٹ پٹ کچھ اس طرح ہوگا:

    ```output
    (.venv) ➜  nightlight-server python --version
    Python 3.9.1
    ```

    > 💁 آپ کا Python ورژن مختلف ہو سکتا ہے - جب تک یہ ورژن 3.6 یا اس سے زیادہ ہے، آپ ٹھیک ہیں۔ اگر نہیں، تو اس فولڈر کو ڈیلیٹ کریں، Python کا نیا ورژن انسٹال کریں اور دوبارہ کوشش کریں۔

1. درج ذیل کمانڈز چلائیں تاکہ [Paho-MQTT](https://pypi.org/project/paho-mqtt/) pip پیکج انسٹال کریں، جو کہ ایک مشہور MQTT لائبریری ہے:

    ```sh
    pip install paho-mqtt
    ```

    یہ pip پیکج صرف ورچوئل ماحول میں انسٹال ہوگا اور اس کے باہر دستیاب نہیں ہوگا۔

#### سرور کوڈ لکھیں

اب سرور کوڈ Python میں لکھا جا سکتا ہے۔

##### کام - سرور کوڈ لکھیں

سرور کوڈ لکھیں۔

1. اپنے ٹرمینل یا کمانڈ لائن سے، ورچوئل ماحول کے اندر درج ذیل کمانڈ چلائیں تاکہ `app.py` نامی Python فائل بنائیں:

    * ونڈوز پر چلائیں:

        ```cmd
        type nul > app.py
        ```

    * macOS یا Linux پر چلائیں:

        ```cmd
        touch app.py
        ```

1. موجودہ فولڈر کو VS Code میں کھولیں:

    ```sh
    code .
    ```

1. جب VS Code لانچ ہوگا، تو یہ Python ورچوئل ماحول کو ایکٹیویٹ کرے گا۔ یہ نیچے اسٹیٹس بار میں رپورٹ ہوگا:

    ![VS Code میں منتخب ورچوئل ماحول دکھایا جا رہا ہے](../../../../../translated_images/vscode-virtual-env.8ba42e04c3d533cf677e16cbe5ed9a3b80f62c6964472dc84b6f940800f0909f.ur.png)

1. اگر VS Code ٹرمینل پہلے سے چل رہا ہو جب VS Code شروع ہو، تو اس میں ورچوئل ماحول ایکٹیویٹ نہیں ہوگا۔ سب سے آسان کام یہ ہے کہ **Kill the active terminal instance** بٹن استعمال کریں:

    ![VS Code میں Kill the active terminal instance بٹن](../../../../../translated_images/vscode-kill-terminal.1cc4de7c6f25ee08f423f0ead714e61d069fac1eb2089e97b8a7bbcb3d45fe5e.ur.png)

1. ایک نیا VS Code ٹرمینل لانچ کریں *Terminal -> New Terminal* منتخب کر کے، یا `` CTRL+` `` دبائیں۔ نیا ٹرمینل ورچوئل ماحول لوڈ کرے گا، اور ایکٹیویٹ کمانڈ ٹرمینل میں ظاہر ہوگی۔ ورچوئل ماحول کا نام (`.venv`) پرامپٹ میں بھی ہوگا:

    ```output
    ➜  nightlight-server source .venv/bin/activate
    (.venv) ➜  nightlight 
    ```

1. VS Code ایکسپلورر سے `app.py` فائل کھولیں اور درج ذیل کوڈ شامل کریں:

    ```python
    import json
    import time
    
    import paho.mqtt.client as mqtt
    
    id = '<ID>'
    
    client_telemetry_topic = id + '/telemetry'
    client_name = id + 'nightlight_server'
    
    mqtt_client = mqtt.Client(client_name)
    mqtt_client.connect('test.mosquitto.org')
    
    mqtt_client.loop_start()
    
    def handle_telemetry(client, userdata, message):
        payload = json.loads(message.payload.decode())
        print("Message received:", payload)
    
    mqtt_client.subscribe(client_telemetry_topic)
    mqtt_client.on_message = handle_telemetry
    
    while True:
        time.sleep(2)
    ```

    لائن 6 پر `<ID>` کو اس منفرد ID سے تبدیل کریں جو آپ نے اپنے ڈیوائس کوڈ بناتے وقت استعمال کی تھی۔

    ⚠️ یہ **ضروری** ہے کہ یہ وہی ID ہو جو آپ نے اپنے ڈیوائس پر استعمال کی تھی، ورنہ سرور کوڈ صحیح ٹاپک پر سبسکرائب یا پبلش نہیں کرے گا۔

    یہ کوڈ ایک MQTT کلائنٹ منفرد نام کے ساتھ بناتا ہے اور *test.mosquitto.org* بروکر سے جڑتا ہے۔ پھر یہ ایک پروسیسنگ لوپ شروع کرتا ہے جو بیک گراؤنڈ تھریڈ پر چلتا ہے اور سبسکرائب شدہ ٹاپکس پر پیغامات سننے کے لیے تیار رہتا ہے۔

    کلائنٹ ٹیلیمیٹری ٹاپک پر پیغامات سبسکرائب کرتا ہے اور ایک فنکشن ڈیفائن کرتا ہے جو پیغام موصول ہونے پر کال ہوتا ہے۔ جب ٹیلیمیٹری پیغام موصول ہوتا ہے، تو `handle_telemetry` فنکشن کال ہوتا ہے اور موصول شدہ پیغام کو کنسول پر پرنٹ کرتا ہے۔

    آخر میں، ایک لامتناہی لوپ ایپلیکیشن کو چلتا رکھتا ہے۔ MQTT کلائنٹ بیک گراؤنڈ تھریڈ پر پیغامات سن رہا ہوتا ہے اور جب تک مین ایپلیکیشن چل رہی ہو، یہ بھی چلتا رہتا ہے۔

1. VS Code ٹرمینل سے درج ذیل کمانڈ چلائیں تاکہ اپنی Python ایپ چلائیں:

    ```sh
    python app.py
    ```

    ایپ IoT ڈیوائس سے پیغامات سننا شروع کر دے گی۔

1. یقینی بنائیں کہ آپ کا ڈیوائس چل رہا ہے اور ٹیلیمیٹری پیغامات بھیج رہا ہے۔ اپنے فزیکل یا ورچوئل ڈیوائس کے ذریعے روشنی کی سطح کو ایڈجسٹ کریں۔ موصول ہونے والے پیغامات ٹرمینل میں پرنٹ ہوں گے۔

    ```output
    (.venv) ➜  nightlight-server python app.py
    Message received: {'light': 0}
    Message received: {'light': 400}
    ```

    nightlight ورچوئل ماحول میں `app.py` فائل کو چلانا ضروری ہے تاکہ nightlight-server ورچوئل ماحول میں `app.py` فائل بھیجے گئے پیغامات وصول کر سکے۔

> 💁 آپ اس کوڈ کو [code-server/server](../../../../../1-getting-started/lessons/4-connect-internet/code-server/server) فولڈر میں تلاش کر سکتے ہیں۔

### ٹیلیمیٹری کتنی بار بھیجی جانی چاہیے؟

ٹیلیمیٹری کے ساتھ ایک اہم غور یہ ہے کہ ڈیٹا کو کتنی بار ماپنا اور بھیجنا چاہیے؟ جواب یہ ہے - یہ منحصر ہے۔ اگر آپ اکثر ماپتے ہیں تو آپ تبدیلیوں پر تیزی سے ردعمل دے سکتے ہیں، لیکن آپ زیادہ پاور، زیادہ بینڈوڈتھ استعمال کرتے ہیں، زیادہ ڈیٹا پیدا کرتے ہیں اور کلاؤڈ وسائل کو پروسیس کرنے کے لیے زیادہ ضرورت ہوتی ہے۔ آپ کو اتنی بار ماپنا چاہیے جتنی ضرورت ہو، لیکن بہت زیادہ نہیں۔

ایک تھرموسٹیٹ کے لیے، ہر چند منٹ میں ماپنا شاید کافی ہے کیونکہ درجہ حرارت اتنی جلدی تبدیل نہیں ہوتا۔ اگر آپ دن میں صرف ایک بار ماپتے ہیں تو آپ دن کے وسط میں رات کے درجہ حرارت کے لیے اپنے گھر کو گرم کر سکتے ہیں، جبکہ اگر آپ ہر سیکنڈ ماپتے ہیں تو آپ ہزاروں غیر ضروری طور پر دہرائے گئے درجہ حرارت کی پیمائشیں حاصل کریں گے جو صارفین کے انٹرنیٹ کی رفتار اور بینڈوڈتھ کو ختم کر دیں گی (جو محدود بینڈوڈتھ پلان رکھنے والے لوگوں کے لیے مسئلہ ہو سکتا ہے)، زیادہ پاور استعمال کریں گے جو بیٹری سے چلنے والے ڈیوائسز جیسے ریموٹ سینسرز کے لیے مسئلہ ہو سکتا ہے، اور کلاؤڈ کمپیوٹنگ وسائل کے اخراجات بڑھا دیں گے۔

اگر آپ کسی فیکٹری میں کسی مشینری کے ارد گرد ڈیٹا کی نگرانی کر رہے ہیں جو اگر ناکام ہو جائے تو تباہ کن نقصان اور لاکھوں ڈالر کے نقصان کا سبب بن سکتی ہے، تو ہر سیکنڈ میں کئی بار ماپنا ضروری ہو سکتا ہے۔ بینڈوڈتھ ضائع کرنا بہتر ہے بجائے اس کے کہ ٹیلیمیٹری کو کھو دیا جائے جو یہ ظاہر کرتی ہے کہ مشین کو توڑنے سے پہلے روکنے اور ٹھیک کرنے کی ضرورت ہے۔

> 💁 اس صورتحال میں، آپ انٹرنیٹ پر انحصار کم کرنے کے لیے ٹیلیمیٹری کو پہلے پروسیس کرنے کے لیے ایک ایج ڈیوائس رکھنے پر غور کر سکتے ہیں۔

### کنیکٹیویٹی کا نقصان

انٹرنیٹ کنیکشن ناقابل اعتماد ہو سکتے ہیں، اور آؤٹجز عام ہیں۔ ایسے حالات میں IoT ڈیوائس کو کیا کرنا چاہیے - کیا اسے ڈیٹا کھونا چاہیے، یا اسے اس وقت تک محفوظ رکھنا چاہیے جب تک کنیکٹیویٹی بحال نہ ہو؟ پھر سے، جواب یہ ہے کہ یہ منحصر ہے۔

ایک تھرموسٹیٹ کے لیے، ڈیٹا کو کھونا شاید ٹھیک ہے جیسے ہی ایک نیا درجہ حرارت ماپا گیا ہو۔ ہیٹنگ سسٹم کو اس بات کی پرواہ نہیں ہے کہ 20 منٹ پہلے درجہ حرارت 20.5°C تھا اگر اب درجہ حرارت 19°C ہے، یہ موجودہ درجہ حرارت ہے جو فیصلہ کرتا ہے کہ ہیٹنگ آن ہونی چاہیے یا نہیں۔

مشینری کے لیے آپ ڈیٹا کو محفوظ رکھنا چاہیں گے، خاص طور پر اگر یہ رجحانات دیکھنے کے لیے استعمال ہوتا ہو۔ کچھ مشین لرننگ ماڈلز ہیں جو ڈیٹا کے سلسلوں میں انوملیز کا پتہ لگانے کے لیے ایک مخصوص وقت کی مدت (جیسے پچھلے گھنٹے) کے ڈیٹا کو دیکھ کر انوملی ڈیٹا کی نشاندہی کرتے ہیں۔ یہ اکثر پیش گوئی کی مرمت کے لیے استعمال ہوتا ہے، یہ دیکھنے کے لیے کہ کچھ جلدی ٹوٹ سکتا ہے تاکہ آپ اسے ٹوٹنے سے پہلے ٹھیک یا تبدیل کر سکیں۔ آپ مشین کے لیے ہر ٹیلیمیٹری کا ڈیٹا بھیجنا چاہیں گے تاکہ انوملی ڈیٹیکشن کے لیے پروسیس کیا جا سکے، لہذا جیسے ہی IoT ڈیوائس دوبارہ کنیکٹ ہو، یہ انٹرنیٹ آؤٹج کے دوران پیدا ہونے والی تمام ٹیلیمیٹری بھیجے۔

IoT ڈیوائس ڈیزائنرز کو یہ بھی غور کرنا چاہیے کہ آیا IoT ڈیوائس انٹرنیٹ آؤٹج یا مقام کی وجہ سے سگنل کے نقصان کے دوران استعمال کیا جا سکتا ہے۔ ایک سمارٹ تھرموسٹیٹ کو کچھ محدود فیصلے کرنے کے قابل ہونا چاہیے تاکہ اگر یہ کلاؤڈ کو ٹیلیمیٹری بھیجنے کے قابل نہ ہو تو ہیٹنگ کو کنٹرول کر سکے۔

[![یہ فراری خراب ہو گئی کیونکہ کسی نے اسے زیر زمین اپ گریڈ کرنے کی کوشش کی جہاں کوئی سیل ریسیپشن نہیں تھا](../../../../../translated_images/bricked-car.dc38f8efadc6c59d76211f981a521efb300939283dee468f79503aae3ec67615.ur.png)](https://twitter.com/internetofshit/status/1315736960082808832)

MQTT کے لیے کنیکٹیویٹی کے نقصان کو ہینڈل کرنے کے لیے، ڈیوائس اور سرور کوڈ کو یہ یقینی بنانے کے لیے ذمہ دار ہونا پڑے گا کہ اگر پیغام کی ترسیل ضروری ہو تو وہ یقینی بنائی جائے، مثال کے طور پر تمام بھیجے گئے پیغامات کے لیے جواب میں اضافی پیغامات کی ضرورت ہو تاکہ اگر جواب نہ ملے تو وہ دستی طور پر قطار میں رکھے جائیں اور بعد میں دوبارہ بھیجے جائیں۔

## کمانڈز

کمانڈز وہ پیغامات ہیں جو کلاؤڈ سے ڈیوائس کو بھیجے جاتے ہیں تاکہ اسے کچھ کرنے کی ہدایت دی جا سکے۔ زیادہ تر وقت یہ کسی ایکچوئیٹر کے ذریعے کچھ آؤٹپٹ دینے سے متعلق ہوتا ہے، لیکن یہ خود ڈیوائس کے لیے بھی ہدایت ہو سکتی ہے، جیسے کہ ریبوٹ کرنا، یا اضافی ٹیلیمیٹری اکٹھا کرنا اور اسے کمانڈ کے جواب کے طور پر واپس بھیجنا۔

![ایک انٹرنیٹ سے جڑا ہوا تھرموسٹیٹ جو ہیٹنگ آن کرنے کے لیے کمانڈ وصول کر رہا ہے](../../../../../translated_images/commands.d6c06bbbb3a02cce95f2831a1c331daf6dedd4e470c4aa2b0ae54f332016e504.ur.png)

ایک تھرموسٹیٹ کلاؤڈ سے کمانڈ وصول کر سکتا ہے تاکہ ہیٹنگ کو آن کرے۔ تمام سینسرز سے ٹیلیمیٹری ڈیٹا کی بنیاد پر، اگر کلاؤڈ سروس نے فیصلہ کیا ہے کہ ہیٹنگ آن ہونی چاہیے، تو یہ متعلقہ کمانڈ بھیجتا ہے۔

### MQTT بروکر کو کمانڈز بھیجیں

ہمارے انٹرنیٹ کنٹرولڈ نائٹ لائٹ کے لیے اگلا قدم یہ ہے کہ سرور کوڈ IoT ڈیوائس کو روشنی کی سطح کے مطابق کنٹرول کرنے کے لیے کمانڈ بھیجے۔

1. VS Code میں سرور کوڈ کھولیں

1. `client_telemetry_topic` کے اعلان کے بعد درج ذیل لائن شامل کریں تاکہ کمانڈز بھیجنے کے لیے ٹاپک کو ڈیفائن کریں:

    ```python
    server_command_topic = id + '/commands'
    ```

1. `handle_telemetry` فنکشن کے آخر میں درج ذیل کوڈ شامل کریں:

    ```python
    command = { 'led_on' : payload['light'] < 300 }
    print("Sending message:", command)
    
    client.publish(server_command_topic, json.dumps(command))
    ```

    یہ کمانڈ ٹاپک پر ایک JSON پیغام بھیجتا ہے جس میں `led_on` کی ویلیو true یا false ہوتی ہے، اس بات پر منحصر ہے کہ روشنی 300 سے کم ہے یا نہیں۔ اگر روشنی 300 سے کم ہو، تو true بھیجا جاتا ہے تاکہ ڈیوائس کو LED آن کرنے کی ہدایت دی جا سکے۔

1. پہلے کی طرح کوڈ چلائیں

1. اپنے فزیکل یا ورچوئل ڈیوائس کے ذریعے روشنی کی سطح کو ایڈجسٹ کریں۔ موصول ہونے والے پیغامات اور بھیجے گئے کمانڈز ٹرمینل میں لکھے جائیں گے:

    ```output
    (.venv) ➜  nightlight-server python app.py
    Message received: {'light': 0}
    Sending message: {'led_on': True}
    Message received: {'light': 400}
    Sending message: {'led_on': False}
    ```

> 💁 ٹیلیمیٹری اور کمانڈز ایک ہی ٹاپک پر بھیجے جا رہے ہیں۔ اس کا مطلب ہے کہ متعدد ڈیوائسز سے ٹیلیمیٹری ایک ہی ٹیلیمیٹری ٹاپک پر ظاہر ہوگی، اور متعدد ڈیوائسز کے کمانڈز ایک ہی کمانڈز ٹاپک پر ظاہر ہوں گے۔ اگر آپ کسی مخصوص ڈیوائس کو کمانڈ بھیجنا چاہتے ہیں، تو آپ متعدد ٹاپکس استعمال کر سکتے ہیں، جو منفرد ڈیوائس ID کے ساتھ نامزد ہوں، جیسے `/commands/device1`, `/commands/device2`۔ اس طرح ایک ڈیوائس صرف اس کے لیے مخصوص پیغامات سن سکتا ہے۔

> 💁 آپ اس کوڈ کو [code-commands/server](../../../../../1-getting-started/lessons/4-connect-internet/code-commands/server) فولڈر میں تلاش کر سکتے ہیں۔

### IoT ڈیوائس پر کمانڈز کو ہینڈل کریں

اب جب کہ سرور سے کمانڈز بھیجی جا رہی ہیں، آپ اب IoT ڈیوائس پر کوڈ شامل کر سکتے ہیں تاکہ انہیں ہینڈل کریں اور LED کو کنٹرول کریں۔

MQTT بروکر سے کمانڈز سننے کے لیے درج ذیل متعلقہ مرحلہ پر عمل کریں:

* [Arduino - Wio Terminal](wio-terminal-commands.md)
* [Single-board computer - Raspberry Pi/Virtual IoT device](single-board-computer-commands.md)

ایک بار یہ کوڈ لکھا اور چل رہا ہو، روشنی کی سطح کو تبدیل کرنے کے ساتھ تجربہ کریں۔ سرور اور ڈیوائس کے آؤٹپٹ کو دیکھیں، اور روشنی کی سطح کو تبدیل کرتے وقت LED کو دیکھیں۔

### کنیکٹیویٹی کا نقصان

اگر کلاؤڈ سروس کو کسی آف لائن IoT ڈیوائس کو کمانڈ بھیجنے کی ضرورت ہو تو کیا کرنا چاہیے؟ پھر سے، جواب یہ ہے کہ یہ منحصر ہے۔

اگر تازہ ترین کمانڈ پہلے والی کو اوور رائیڈ کرتی ہے تو پرانی کمانڈز کو شاید نظر انداز کیا جا سکتا ہے۔ اگر کلاؤڈ سروس ہیٹنگ کو آن کرنے کے لیے کمانڈ بھیجتی ہے، پھر اسے بند کرنے کے لیے کمانڈ بھیجتی ہے، تو آن کمانڈ کو نظر
ان آلات کے بارے میں سوچیں، وہ کون سے پیغامات بھیج یا وصول کر سکتے ہیں؟ وہ کون سی ٹیلیمیٹری بھیجتے ہیں؟ وہ کون سے پیغامات یا کمانڈز وصول کر سکتے ہیں؟ کیا آپ کو لگتا ہے کہ وہ محفوظ ہیں؟

## لیکچر کے بعد کا کوئز

[لیکچر کے بعد کا کوئز](https://black-meadow-040d15503.1.azurestaticapps.net/quiz/8)

## جائزہ اور خود مطالعہ

MQTT کے بارے میں مزید پڑھیں [MQTT ویکیپیڈیا صفحہ](https://wikipedia.org/wiki/MQTT) پر۔

خود ایک MQTT بروکر چلانے کی کوشش کریں [Mosquitto](https://www.mosquitto.org) استعمال کرتے ہوئے اور اپنے IoT ڈیوائس اور سرور کوڈ سے اس سے جڑیں۔

> 💁 ٹپ - Mosquitto ڈیفالٹ طور پر گمنام کنکشنز (یعنی بغیر یوزر نیم اور پاسورڈ کے کنکشن) کی اجازت نہیں دیتا، اور اس کمپیوٹر کے باہر سے کنکشن کی اجازت نہیں دیتا جس پر یہ چل رہا ہو۔
> آپ اسے [`mosquitto.conf` کنفیگریشن فائل](https://www.mosquitto.org/man/mosquitto-conf-5.html) کے ذریعے ٹھیک کر سکتے ہیں جس میں درج ذیل ہو:
>
> ```sh
> listener 1883 0.0.0.0
> allow_anonymous true
> ```

## اسائنمنٹ

[MQTT کا دیگر کمیونیکیشن پروٹوکولز کے ساتھ موازنہ کریں](assignment.md)

---

**ڈسکلیمر**:  
یہ دستاویز AI ترجمہ سروس [Co-op Translator](https://github.com/Azure/co-op-translator) کا استعمال کرتے ہوئے ترجمہ کی گئی ہے۔ ہم درستگی کے لیے کوشش کرتے ہیں، لیکن براہ کرم آگاہ رہیں کہ خودکار ترجمے میں غلطیاں یا غیر درستیاں ہو سکتی ہیں۔ اصل دستاویز کو اس کی اصل زبان میں مستند ذریعہ سمجھا جانا چاہیے۔ اہم معلومات کے لیے، پیشہ ور انسانی ترجمہ کی سفارش کی جاتی ہے۔ ہم اس ترجمے کے استعمال سے پیدا ہونے والی کسی بھی غلط فہمی یا غلط تشریح کے ذمہ دار نہیں ہیں۔