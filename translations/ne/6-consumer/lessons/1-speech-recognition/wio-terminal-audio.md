<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "2f336726b9410e97c3aaed76cc89b0d8",
  "translation_date": "2025-08-27T14:13:40+00:00",
  "source_file": "6-consumer/lessons/1-speech-recognition/wio-terminal-audio.md",
  "language_code": "ne"
}
-->
# рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрдиреБрд╣реЛрд╕реН - Wio Terminal

рдпрд╕ рдкрд╛рдардХреЛ рдпрд╕ рднрд╛рдЧрдорд╛, рддрдкрд╛рдИрдВ рдЖрдлреНрдиреЛ Wio Terminal рдорд╛ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди рдХреЛрдб рд▓реЗрдЦреНрдиреБрд╣реБрдиреЗрдЫред рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ Wio Terminal рдХреЛ рдорд╛рдерд┐рд▓реНрд▓реЛ рднрд╛рдЧрдорд╛ рд░рд╣реЗрдХреЛ рдмрдЯрдирд╣рд░реВрдордзреНрдпреЗ рдПрдХрджреНрд╡рд╛рд░рд╛ рдирд┐рдпрдиреНрддреНрд░рдг рдЧрд░рд┐рдиреЗрдЫред

## рдЙрдкрдХрд░рдгрд▓рд╛рдИ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди рдкреНрд░реЛрдЧреНрд░рд╛рдо рдЧрд░реНрдиреБрд╣реЛрд╕реН

рддрдкрд╛рдИрдВ C++ рдХреЛрдб рдкреНрд░рдпреЛрдЧ рдЧрд░реЗрд░ рдорд╛рдЗрдХреНрд░реЛрдлреЛрдирдмрд╛рдЯ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди рд╕рдХреНрдиреБрд╣реБрдиреНрдЫред Wio Terminal рдорд╛ рдХреЗрд╡рд▓ 192KB RAM рдЫ, рдЬрд╕рд▓реЗ рдХреЗрд╣реА рд╕реЗрдХреЗрдиреНрдбрднрдиреНрджрд╛ рдмрдвреА рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди рдкрд░реНрдпрд╛рдкреНрдд рдЫреИрдиред рдпрд╕рдорд╛ 4MB рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА рдкрдирд┐ рдЫ, рдЬрд╕рд▓рд╛рдИ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░рд┐рдПрдХреЛ рдЕрдбрд┐рдпреЛрд▓рд╛рдИ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд╕реБрд░рдХреНрд╖рд┐рдд рдЧрд░реНрди рдкреНрд░рдпреЛрдЧ рдЧрд░реНрди рд╕рдХрд┐рдиреНрдЫред

рдмрд┐рд▓реНрдЯ-рдЗрди рдорд╛рдЗрдХреНрд░реЛрдлреЛрдирд▓реЗ рдПрдирд╛рд▓рдЧ рд╕рд┐рдЧреНрдирд▓ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрдЫ, рдЬреБрди рдбрд┐рдЬрд┐рдЯрд▓ рд╕рд┐рдЧреНрдирд▓рдорд╛ рд░реВрдкрд╛рдиреНрддрд░рдг рд╣реБрдиреНрдЫ, рдЬрд╕рд▓рд╛рдИ Wio Terminal рд▓реЗ рдкреНрд░рдпреЛрдЧ рдЧрд░реНрди рд╕рдХреНрдЫред рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрджрд╛, рдбреЗрдЯрд╛ рд╕рд╣реА рд╕рдордпрдорд╛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди рдЖрд╡рд╢реНрдпрдХ рдЫ - рдЙрджрд╛рд╣рд░рдгрдХрд╛ рд▓рд╛рдЧрд┐, 16KHz рдорд╛ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди, рдЕрдбрд┐рдпреЛрд▓рд╛рдИ рдкреНрд░рддрд┐ рд╕реЗрдХреЗрдиреНрдб рдареАрдХ 16,000 рдкрдЯрдХ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрдиреБрдкрд░реНрдЫ, рдкреНрд░рддреНрдпреЗрдХ рдирдореБрдирд╛рдмреАрдЪ рд╕рдорд╛рди рдЕрдиреНрддрд░рд╛рд▓рдорд╛ред рддрдкрд╛рдИрдВрдХреЛ рдХреЛрдбрд▓реЗ рдпреЛ рдЧрд░реНрдиреБрднрдиреНрджрд╛, рддрдкрд╛рдИрдВрд▓реЗ рдбрд╛рдЗрд░реЗрдХреНрдЯ рдореЗрдореЛрд░реА рдПрдХреНрд╕реЗрд╕ рдХрдиреНрдЯреНрд░реЛрд▓рд░ (DMAC) рдкреНрд░рдпреЛрдЧ рдЧрд░реНрди рд╕рдХреНрдиреБрд╣реБрдиреНрдЫред рдпреЛ рдпрд╕реНрддреЛ рд╕рд░реНрдХрд┐рдЯ рд╣реЛ рдЬрд╕рд▓реЗ рдХреБрдиреИ рд╕рд┐рдЧреНрдирд▓рд▓рд╛рдИ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реЗрд░ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦреНрди рд╕рдХреНрдЫ, рддрдкрд╛рдИрдВрдХреЛ рдкреНрд░реЛрд╕реЗрд╕рд░рдорд╛ рдЪрд▓рд┐рд░рд╣реЗрдХреЛ рдХреЛрдбрд▓рд╛рдИ рдЕрд╡рд░реЛрдз рдирдЧрд░реАред

тЬЕ DMAC рдХреЛ рдмрд╛рд░реЗрдорд╛ рдердк рдкрдвреНрдирдХреЛ рд▓рд╛рдЧрд┐ [рд╡рд┐рдХрд┐рдкреЗрдбрд┐рдпрд╛рдХреЛ рдбрд╛рдЗрд░реЗрдХреНрдЯ рдореЗрдореЛрд░реА рдПрдХреНрд╕реЗрд╕ рдкреГрд╖реНрда](https://wikipedia.org/wiki/Direct_memory_access) рд╣реЗрд░реНрдиреБрд╣реЛрд╕реНред

![рдорд╛рдЗрдХреНрд░реЛрдлреЛрдирдмрд╛рдЯ рдЕрдбрд┐рдпреЛ ADC рдорд╛ рдЬрд╛рдиреНрдЫ, рддреНрдпрд╕рдкрдЫрд┐ DMAC рдорд╛ред рдпрд╕рд▓реЗ рдПрдЙрдЯрд╛ рдмрдлрд░рдорд╛ рд▓реЗрдЦреНрдЫред рдЬрдм рдпреЛ рдмрдлрд░ рднрд░рд┐рдиреНрдЫ, рдпреЛ рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░рд┐рдиреНрдЫ рд░ DMAC рд▓реЗ рджреЛрд╕реНрд░реЛ рдмрдлрд░рдорд╛ рд▓реЗрдЦреНрдЫред](../../../../../translated_images/dmac-adc-buffers.4509aee49145c90bc2e1be472b8ed2ddfcb2b6a81ad3e559114aca55f5fff759.ne.png)

DMAC рд▓реЗ ADC рдмрд╛рдЯ рдирд┐рд╢реНрдЪрд┐рдд рдЕрдиреНрддрд░рд╛рд▓рдорд╛ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди рд╕рдХреНрдЫ, рдЬрд╕реНрддреИ 16KHz рдЕрдбрд┐рдпреЛрдХреЛ рд▓рд╛рдЧрд┐ рдкреНрд░рддрд┐ рд╕реЗрдХреЗрдиреНрдб 16,000 рдкрдЯрдХред рдпрд╕рд▓реЗ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░рд┐рдПрдХреЛ рдбреЗрдЯрд╛ рдкреВрд░реНрд╡-рдирд┐рд░реНрдзрд╛рд░рд┐рдд рдореЗрдореЛрд░реА рдмрдлрд░рдорд╛ рд▓реЗрдЦреНрди рд╕рдХреНрдЫ, рд░ рдЬрдм рдпреЛ рднрд░рд┐рдиреНрдЫ, рддрдкрд╛рдИрдВрдХреЛ рдХреЛрдбрд▓рд╛рдИ рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░реНрди рдЙрдкрд▓рдмреНрдз рдЧрд░рд╛рдЙрдБрдЫред рдпреЛ рдореЗрдореЛрд░реА рдкреНрд░рдпреЛрдЧ рдЧрд░реНрджрд╛ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░рдорд╛ рдврд┐рд▓рд╛рдЗ рд╣реБрди рд╕рдХреНрдЫ, рддрд░ рддрдкрд╛рдИрдВрд▓реЗ рдзреЗрд░реИ рдмрдлрд░рд╣рд░реВ рд╕реЗрдЯрдЕрдк рдЧрд░реНрди рд╕рдХреНрдиреБрд╣реБрдиреНрдЫред DMAC рд▓реЗ рдмрдлрд░ 1 рдорд╛ рд▓реЗрдЦреНрдЫ, рддреНрдпрд╕рдкрдЫрд┐ рдЬрдм рдпреЛ рднрд░рд┐рдиреНрдЫ, рддрдкрд╛рдИрдВрдХреЛ рдХреЛрдбрд▓рд╛рдИ рдмрдлрд░ 1 рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░реНрди рд╕реВрдЪрд┐рдд рдЧрд░реНрдЫ, рдЬрдмрдХрд┐ DMAC рд▓реЗ рдмрдлрд░ 2 рдорд╛ рд▓реЗрдЦреНрдЫред рдЬрдм рдмрдлрд░ 2 рднрд░рд┐рдиреНрдЫ, рдпреЛ рддрдкрд╛рдИрдВрдХреЛ рдХреЛрдбрд▓рд╛рдИ рд╕реВрдЪрд┐рдд рдЧрд░реНрдЫ, рд░ рдлреЗрд░рд┐ рдмрдлрд░ 1 рдорд╛ рд▓реЗрдЦреНрди рдЬрд╛рдиреНрдЫред рдпрд╕рд░реА, рдЬрдмрд╕рдореНрдо рддрдкрд╛рдИрдВ рдкреНрд░рддреНрдпреЗрдХ рдмрдлрд░рд▓рд╛рдИ рднрд░рд┐рди рд▓рд╛рдЧреНрдиреЗ рд╕рдордпрднрдиреНрджрд╛ рдХрдо рд╕рдордпрдорд╛ рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░реНрдиреБрд╣реБрдиреНрдЫ, рддрдкрд╛рдИрдВрд▓реЗ рдХреБрдиреИ рдбреЗрдЯрд╛ рдЧреБрдорд╛рдЙрдиреБрд╣реБрдиреЗрдЫреИрдиред

рдкреНрд░рддреНрдпреЗрдХ рдмрдлрд░ рдХреНрдпрд╛рдкреНрдЪрд░ рднрдПрдкрдЫрд┐, рдпрд╕рд▓рд╛рдИ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦреНрди рд╕рдХрд┐рдиреНрдЫред рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрд▓рд╛рдИ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдареЗрдЧрд╛рдирд╛рд╣рд░реВ рдкреНрд░рдпреЛрдЧ рдЧрд░реЗрд░ рд▓реЗрдЦреНрди рдЖрд╡рд╢реНрдпрдХ рдЫ, рдХрд╣рд╛рдБ рд▓реЗрдЦреНрдиреЗ рд░ рдХрддрд┐ рдареВрд▓реЛ рд▓реЗрдЦреНрдиреЗ рдирд┐рд░реНрджрд┐рд╖реНрдЯ рдЧрд░реНрджреИ, рдореЗрдореЛрд░реАрдХреЛ рдмрд╛рдЗрдЯрд╣рд░реВрдХреЛ рдПрд░реНрд░реЗ рдЕрдкрдбреЗрдЯ рдЧрд░реЗрдЬрд╕реНрддреИред рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рдЧреНрд░рд╛рдиреНрдпреБрд▓рд╛рд░рд┐рдЯреА рд╣реБрдиреНрдЫ, рдЬрд╕рдХреЛ рдЕрд░реНрде рдореЗрдЯрд╛рдЙрдиреЗ рд░ рд▓реЗрдЦреНрдиреЗ рдХрд╛рд░реНрдпрд╣рд░реВ рдирд┐рд╢реНрдЪрд┐рдд рдЖрдХрд╛рд░рдХреЛ рдорд╛рддреНрд░рд╛рдорд╛ рдирд┐рд░реНрднрд░ рд╣реБрдиреНрдЫрдиреН, рд░ рддреНрдпрд╕ рдЖрдХрд╛рд░рд╕рдБрдЧ рдорд┐рд▓реНрдиреБрдкрд░реНрдЫред рдЙрджрд╛рд╣рд░рдгрдХрд╛ рд▓рд╛рдЧрд┐, рдпрджрд┐ рдЧреНрд░рд╛рдиреНрдпреБрд▓рд╛рд░рд┐рдЯреА 4096 рдмрд╛рдЗрдЯ рдЫ рд░ рддрдкрд╛рдИрдВрд▓реЗ рдареЗрдЧрд╛рдирд╛ 4200 рдорд╛ рдореЗрдЯрд╛рдЙрди рдЕрдиреБрд░реЛрдз рдЧрд░реНрдиреБрднрдпреЛ рднрдиреЗ, рдпрд╕рд▓реЗ рдареЗрдЧрд╛рдирд╛ 4096 рджреЗрдЦрд┐ 8192 рд╕рдореНрдордХреЛ рд╕рдмреИ рдбреЗрдЯрд╛ рдореЗрдЯрд╛рдЙрди рд╕рдХреНрдЫред рдпрд╕рдХреЛ рдЕрд░реНрде, рдЬрдм рддрдкрд╛рдИрдВ рдЕрдбрд┐рдпреЛ рдбреЗрдЯрд╛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦреНрдиреБрд╣реБрдиреНрдЫ, рдпреЛ рд╕рд╣реА рдЖрдХрд╛рд░рдХреЛ рдЯреБрдХреНрд░рд╛рдорд╛ рд╣реБрдиреБрдкрд░реНрдЫред

### рдХрд╛рд░реНрдп - рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА рдХрдиреНрдлрд┐рдЧрд░ рдЧрд░реНрдиреБрд╣реЛрд╕реН

1. PlatformIO рдкреНрд░рдпреЛрдЧ рдЧрд░реЗрд░ рдирдпрд╛рдБ Wio Terminal рдкреНрд░реЛрдЬреЗрдХреНрдЯ рд╕рд┐рд░реНрдЬрдирд╛ рдЧрд░реНрдиреБрд╣реЛрд╕реНред рдпрд╕ рдкреНрд░реЛрдЬреЗрдХреНрдЯрд▓рд╛рдИ `smart-timer` рдирд╛рдо рджрд┐рдиреБрд╣реЛрд╕реНред `setup` рдлрдЩреНрд╕рдирдорд╛ рд╕рд┐рд░рд┐рдпрд▓ рдкреЛрд░реНрдЯ рдХрдиреНрдлрд┐рдЧрд░ рдЧрд░реНрди рдХреЛрдб рдердкреНрдиреБрд╣реЛрд╕реНред

1. рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рдкрд╣реБрдБрдЪ рдкреНрд░рджрд╛рди рдЧрд░реНрди `platformio.ini` рдлрд╛рдЗрд▓рдорд╛ рдирд┐рдореНрди рдкреБрд╕реНрддрдХрд╛рд▓рдп рдирд┐рд░реНрднрд░рддрд╛рд╣рд░реВ рдердкреНрдиреБрд╣реЛрд╕реН:

    ```ini
    lib_deps =
        seeed-studio/Seeed Arduino FS @ 2.1.1
        seeed-studio/Seeed Arduino SFUD @ 2.0.2
    ```

1. `main.cpp` рдлрд╛рдЗрд▓ рдЦреЛрд▓реНрдиреБрд╣реЛрд╕реН рд░ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА рдкреБрд╕реНрддрдХрд╛рд▓рдпрдХреЛ рд▓рд╛рдЧрд┐ рдирд┐рдореНрди рдЗрдирдХреНрд▓реБрдб рдирд┐рд░реНрджреЗрд╢рди рдлрд╛рдЗрд▓рдХреЛ рд╢реАрд░реНрд╖рдорд╛ рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    #include <sfud.h>
    #include <SPI.h>
    ```

    > ЁЯОУ SFUD рдХреЛ рдЕрд░реНрде Serial Flash Universal Driver рд╣реЛ, рд░ рдпреЛ рд╕рдмреИ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА рдЪрд┐рдкрд╣рд░реВрд╕рдБрдЧ рдХрд╛рдо рдЧрд░реНрди рдбрд┐рдЬрд╛рдЗрди рдЧрд░рд┐рдПрдХреЛ рдкреБрд╕реНрддрдХрд╛рд▓рдп рд╣реЛред

1. `setup` рдлрдЩреНрд╕рдирдорд╛, рдлреНрд▓реНрдпрд╛рд╕ рд╕реНрдЯреЛрд░реЗрдЬ рдкреБрд╕реНрддрдХрд╛рд▓рдп рд╕реЗрдЯрдЕрдк рдЧрд░реНрди рдирд┐рдореНрди рдХреЛрдб рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    while (!(sfud_init() == SFUD_SUCCESS))
        ;

    sfud_qspi_fast_read_enable(sfud_get_device(SFUD_W25Q32_DEVICE_INDEX), 2);
    ```

    рдпреЛ рд▓реВрдк рд╣реБрдиреНрдЫ рдЬрдмрд╕рдореНрдо SFUD рдкреБрд╕реНрддрдХрд╛рд▓рдп рдЖрд░рдореНрдн рд╣реБрдБрджреИрди, рддреНрдпрд╕рдкрдЫрд┐ рдлрд╛рд╕реНрдЯ рд░рд┐рдбреНрд╕ рдЕрди рдЧрд░реНрджрдЫред рдмрд┐рд▓реНрдЯ-рдЗрди рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрд▓рд╛рдИ Queued Serial Peripheral Interface (QSPI) рдкреНрд░рдпреЛрдЧ рдЧрд░реЗрд░ рдкрд╣реБрдБрдЪ рдЧрд░реНрди рд╕рдХрд┐рдиреНрдЫ, рдЬреБрди SPI рдХрдиреНрдЯреНрд░реЛрд▓рд░рдХреЛ рдкреНрд░рдХрд╛рд░ рд╣реЛ рдЬрд╕рд▓реЗ рдиреНрдпреВрдирддрдо рдкреНрд░реЛрд╕реЗрд╕рд░ рдкреНрд░рдпреЛрдЧ рдЧрд░реЗрд░ рдирд┐рд░рдиреНрддрд░ рдкрд╣реБрдБрдЪрдХреЛ рд▓рд╛рдЧрд┐ рдХреНрдпреВ рдкреНрд░рдпреЛрдЧ рдЧрд░реНрджрдЫред рдпрд╕рд▓реЗ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рдкрдвреНрди рд░ рд▓реЗрдЦреНрди рдЫрд┐рдЯреЛ рдмрдирд╛рдЙрдБрдЫред

1. `src` рдлреЛрд▓реНрдбрд░рдорд╛ `flash_writer.h` рдирд╛рдордХ рдирдпрд╛рдБ рдлрд╛рдЗрд▓ рд╕рд┐рд░реНрдЬрдирд╛ рдЧрд░реНрдиреБрд╣реЛрд╕реНред

1. рдпрд╕ рдлрд╛рдЗрд▓рдХреЛ рд╢реАрд░реНрд╖рдорд╛ рдирд┐рдореНрди рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    #pragma once

    #include <Arduino.h>
    #include <sfud.h>
    ```

    рдпрд╕рд▓реЗ рдЖрд╡рд╢реНрдпрдХ рд╣реЗрдбрд░ рдлрд╛рдЗрд▓рд╣рд░реВ рд╕рдорд╛рд╡реЗрд╢ рдЧрд░реНрджрдЫ, рдЬрд╕рдорд╛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрд╕рдБрдЧ рдЕрдиреНрддрд░рдХреНрд░рд┐рдпрд╛ рдЧрд░реНрди SFUD рдкреБрд╕реНрддрдХрд╛рд▓рдпрдХреЛ рд╣реЗрдбрд░ рдлрд╛рдЗрд▓ рдкрдирд┐ рд╕рдорд╛рд╡реЗрд╢ рдЫред

1. рдпрд╕ рдирдпрд╛рдБ рд╣реЗрдбрд░ рдлрд╛рдЗрд▓рдорд╛ `FlashWriter` рдирд╛рдордХ рдХрдХреНрд╖рд╛ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдЧрд░реНрдиреБрд╣реЛрд╕реН:

    ```cpp
    class FlashWriter
    {
    public:
    
    private:
    };
    ```

1. `private` рд╕реЗрдХреНрд╕рдирдорд╛ рдирд┐рдореНрди рдХреЛрдб рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    byte *_sfudBuffer;
    size_t _sfudBufferSize;
    size_t _sfudBufferPos;
    size_t _sfudBufferWritePos;

    const sfud_flash *_flash;
    ```

    рдпрд╕рд▓реЗ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦреНрди рдкреНрд░рдпреЛрдЧ рдЧрд░реНрди рдбреЗрдЯрд╛ рднрдгреНрдбрд╛рд░рдг рдЧрд░реНрди рдмрдлрд░рдХреЛ рд▓рд╛рдЧрд┐ рдХреЗрд╣реА рдлрд┐рд▓реНрдбрд╣рд░реВ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдЧрд░реНрджрдЫред `_sfudBuffer` рдирд╛рдордХ рдмрд╛рдЗрдЯ рдПрд░реНрд░реЗрдорд╛ рдбреЗрдЯрд╛ рд▓реЗрдЦрд┐рдиреНрдЫ, рд░ рдЬрдм рдпреЛ рднрд░рд┐рдиреНрдЫ, рдбреЗрдЯрд╛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦрд┐рдиреНрдЫред `_sfudBufferPos` рдлрд┐рд▓реНрдбрд▓реЗ рдпрд╕ рдмрдлрд░рдорд╛ рд▓реЗрдЦреНрдирдХреЛ рд▓рд╛рдЧрд┐ рд╣рд╛рд▓рдХреЛ рд╕реНрдерд╛рди рднрдгреНрдбрд╛рд░рдг рдЧрд░реНрджрдЫ, рд░ `_sfudBufferWritePos` рд▓реЗ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦреНрдирдХреЛ рд▓рд╛рдЧрд┐ рд╕реНрдерд╛рди рднрдгреНрдбрд╛рд░рдг рдЧрд░реНрджрдЫред `_flash` рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦреНрдирдХреЛ рд▓рд╛рдЧрд┐ рдкреЛрдЗрдиреНрдЯрд░ рд╣реЛ - рдХреЗрд╣реА рдорд╛рдЗрдХреНрд░реЛрдХрдиреНрдЯреНрд░реЛрд▓рд░рд╣рд░реВрдорд╛ рдзреЗрд░реИ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА рдЪрд┐рдкрд╣рд░реВ рд╣реБрдиреНрдЫрдиреНред

1. рдпреЛ рдХрдХреНрд╖рд╛рдХреЛ `public` рд╕реЗрдХреНрд╕рдирдорд╛ рдпреЛ рдХрдХреНрд╖рд╛ рдЖрд░рдореНрдн рдЧрд░реНрди рдирд┐рдореНрди рд╡рд┐рдзрд┐ рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    void init()
    {
        _flash = sfud_get_device_table() + 0;
        _sfudBufferSize = _flash->chip.erase_gran;
        _sfudBuffer = new byte[_sfudBufferSize];
        _sfudBufferPos = 0;
        _sfudBufferWritePos = 0;
    }
    ```

    рдпреЛ Wio Terminal рдорд╛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА рд▓реЗрдЦреНрди рдХрдиреНрдлрд┐рдЧрд░ рдЧрд░реНрджрдЫ, рд░ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдХреЛ рдЧреНрд░реЗрди рд╕рд╛рдЗрдЬрдХреЛ рдЖрдзрд╛рд░рдорд╛ рдмрдлрд░рд╣рд░реВ рд╕реЗрдЯрдЕрдк рдЧрд░реНрджрдЫред рдпреЛ `init` рд╡рд┐рдзрд┐рдорд╛ рдЫ, рдХрдиреНрд╕реНрдЯреНрд░рдХреНрдЯрд░рдорд╛ рд╣реЛрдЗрди, рдХрд┐рдирднрдиреЗ рдпреЛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА `setup` рдлрдЩреНрд╕рдирдорд╛ рд╕реЗрдЯрдЕрдк рднрдПрдкрдЫрд┐ рдорд╛рддреНрд░ рдмреЛрд▓рд╛рдЙрди рдЖрд╡рд╢реНрдпрдХ рдЫред

1. `public` рд╕реЗрдХреНрд╕рдирдорд╛ рдирд┐рдореНрди рдХреЛрдб рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    void writeSfudBuffer(byte b)
    {
        _sfudBuffer[_sfudBufferPos++] = b;
        if (_sfudBufferPos == _sfudBufferSize)
        {
            sfud_erase_write(_flash, _sfudBufferWritePos, _sfudBufferSize, _sfudBuffer);
            _sfudBufferWritePos += _sfudBufferSize;
            _sfudBufferPos = 0;
        }
    }

    void writeSfudBuffer(byte *b, size_t len)
    {
        for (size_t i = 0; i < len; ++i)
        {
            writeSfudBuffer(b[i]);
        }
    }

    void flushSfudBuffer()
    {
        if (_sfudBufferPos > 0)
        {
            sfud_erase_write(_flash, _sfudBufferWritePos, _sfudBufferSize, _sfudBuffer);
            _sfudBufferWritePos += _sfudBufferSize;
            _sfudBufferPos = 0;
        }
    }
    ```

    рдпреЛ рдХреЛрдбрд▓реЗ рдлреНрд▓реНрдпрд╛рд╕ рд╕реНрдЯреЛрд░реЗрдЬ рдкреНрд░рдгрд╛рд▓реАрдорд╛ рдмрд╛рдЗрдЯрд╣рд░реВ рд▓реЗрдЦреНрди рд╡рд┐рдзрд┐рд╣рд░реВ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдЧрд░реНрджрдЫред рдпреЛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдХреЛ рд╕рд╣реА рдЖрдХрд╛рд░рдХреЛ рдЗрди-рдореЗрдореЛрд░реА рдмрдлрд░рдорд╛ рд▓реЗрдЦреЗрд░ рдХрд╛рдо рдЧрд░реНрджрдЫ, рд░ рдЬрдм рдпреЛ рднрд░рд┐рдиреНрдЫ, рдпреЛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦрд┐рдиреНрдЫ, рддреНрдпрд╣рд╛рдБрдХреЛ рдХреБрдиреИ рдкрдирд┐ рдЕрд╡рд╕реНрдерд┐рдд рдбреЗрдЯрд╛ рдореЗрдЯрд╛рдЙрдБрджреИред `flushSfudBuffer` рдкрдирд┐ рдЫ, рдЬрд╕рд▓реЗ рдЕрдзреВрд░реЛ рдмрдлрд░ рд▓реЗрдЦреНрдЫ, рдХрд┐рдирднрдиреЗ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░рд┐рдПрдХреЛ рдбреЗрдЯрд╛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдХреЛ рдЧреНрд░реЗрди рд╕рд╛рдЗрдЬрдХреЛ рдареНрдпрд╛рдХреНрдХреИ рдЧреБрдгрдХ рд╣реБрдБрджреИрди, рддреНрдпрд╕реИрд▓реЗ рдбреЗрдЯрд╛ рдЕрдиреНрддреНрдпрдХреЛ рднрд╛рдЧ рд▓реЗрдЦреНрди рдЖрд╡рд╢реНрдпрдХ рдЫред

    > ЁЯТБ рдбреЗрдЯрд╛ рдЕрдиреНрддреНрдпрдХреЛ рднрд╛рдЧрд▓реЗ рдЕрддрд┐рд░рд┐рдХреНрдд рдЕрдирд╛рд╡рд╢реНрдпрдХ рдбреЗрдЯрд╛ рд▓реЗрдЦреНрди рд╕рдХреНрдЫ, рддрд░ рдпреЛ рдареАрдХ рдЫ рдХрд┐рдирднрдиреЗ рдХреЗрд╡рд▓ рдЖрд╡рд╢реНрдпрдХ рдбреЗрдЯрд╛ рдорд╛рддреНрд░ рдкрдврд┐рдиреЗрдЫред

### рдХрд╛рд░реНрдп - рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рд╕реЗрдЯрдЕрдк рдЧрд░реНрдиреБрд╣реЛрд╕реН

1. `src` рдлреЛрд▓реНрдбрд░рдорд╛ `config.h` рдирд╛рдордХ рдирдпрд╛рдБ рдлрд╛рдЗрд▓ рд╕рд┐рд░реНрдЬрдирд╛ рдЧрд░реНрдиреБрд╣реЛрд╕реНред

1. рдпрд╕ рдлрд╛рдЗрд▓рдХреЛ рд╢реАрд░реНрд╖рдорд╛ рдирд┐рдореНрди рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    #pragma once

    #define RATE 16000
    #define SAMPLE_LENGTH_SECONDS 4
    #define SAMPLES RATE * SAMPLE_LENGTH_SECONDS
    #define BUFFER_SIZE (SAMPLES * 2) + 44
    #define ADC_BUF_LEN 1600
    ```

    рдпреЛ рдХреЛрдбрд▓реЗ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░рдХрд╛ рд▓рд╛рдЧрд┐ рдХреЗрд╣реА рд╕реНрдерд┐рд░рд╛рдВрдХрд╣рд░реВ рд╕реЗрдЯрдЕрдк рдЧрд░реНрджрдЫред

    | рд╕реНрдерд┐рд░рд╛рдВрдХ              | рдорд╛рди  | рд╡рд┐рд╡рд░рдг |
    | --------------------- | -----: | - |
    | RATE                  | 16000  | рдЕрдбрд┐рдпреЛрдХреЛ рдирдореВрдирд╛ рджрд░ред 16,000 рднрдиреЗрдХреЛ 16KHz рд╣реЛ |
    | SAMPLE_LENGTH_SECONDS | 4      | рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди рдЕрдбрд┐рдпреЛрдХреЛ рд▓рдореНрдмрд╛рдЗред рдпреЛ 4 рд╕реЗрдХреЗрдиреНрдбрдорд╛ рд╕реЗрдЯ рдЧрд░рд┐рдПрдХреЛ рдЫред рд▓рд╛рдореЛ рдЕрдбрд┐рдпреЛ рд░реЗрдХрд░реНрдб рдЧрд░реНрди, рдпрд╕рд▓рд╛рдИ рдмрдврд╛рдЙрдиреБрд╣реЛрд╕реНред |
    | SAMPLES               | 64000  | рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░рд┐рдиреЗ рдЕрдбрд┐рдпреЛ рдирдореВрдирд╛рд╣рд░реВрдХреЛ рдХреБрд▓ рд╕рдВрдЦреНрдпрд╛ред рдирдореВрдирд╛ рджрд░ * рд╕реЗрдХреЗрдиреНрдбрдХреЛ рд╕рдВрдЦреНрдпрд╛ |
    | BUFFER_SIZE           | 128044 | рдЕрдбрд┐рдпреЛ рдмрдлрд░рдХреЛ рдЖрдХрд╛рд░ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрдиред рдЕрдбрд┐рдпреЛ WAV рдлрд╛рдЗрд▓рдХреЛ рд░реВрдкрдорд╛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░рд┐рдиреЗрдЫ, рдЬрд╕рдорд╛ 44 рдмрд╛рдЗрдЯрдХреЛ рд╣реЗрдбрд░, рддреНрдпрд╕рдкрдЫрд┐ 128,000 рдмрд╛рдЗрдЯрдХреЛ рдЕрдбрд┐рдпреЛ рдбреЗрдЯрд╛ (рдкреНрд░рддреНрдпреЗрдХ рдирдореВрдирд╛ 2 рдмрд╛рдЗрдЯ рд╣реЛ) |
    | ADC_BUF_LEN           | 1600   | DMAC рдмрд╛рдЯ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди рдкреНрд░рдпреЛрдЧ рдЧрд░рд┐рдиреЗ рдмрдлрд░рд╣рд░реВрдХреЛ рдЖрдХрд╛рд░ |

    > ЁЯТБ рдпрджрд┐ рддрдкрд╛рдИрдВрд▓рд╛рдИ 4 рд╕реЗрдХреЗрдиреНрдб рдЫреЛрдЯреЛ рд▓рд╛рдЧреНрдЫ рдЯрд╛рдЗрдорд░ рдЕрдиреБрд░реЛрдз рдЧрд░реНрди, рддрдкрд╛рдИрдВ `SAMPLE_LENGTH_SECONDS` рдорд╛рди рдмрдврд╛рдЙрди рд╕рдХреНрдиреБрд╣реБрдиреНрдЫ, рд░ рдЕрдиреНрдп рд╕рдмреИ рдорд╛рдирд╣рд░реВ рдкреБрди: рдЧрдгрдирд╛ рдЧрд░рд┐рдиреЗрдЫред

1. `src` рдлреЛрд▓реНрдбрд░рдорд╛ `mic.h` рдирд╛рдордХ рдирдпрд╛рдБ рдлрд╛рдЗрд▓ рд╕рд┐рд░реНрдЬрдирд╛ рдЧрд░реНрдиреБрд╣реЛрд╕реНред

1. рдпрд╕ рдлрд╛рдЗрд▓рдХреЛ рд╢реАрд░реНрд╖рдорд╛ рдирд┐рдореНрди рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    #pragma once

    #include <Arduino.h>

    #include "config.h"
    #include "flash_writer.h"
    ```

    рдпрд╕рд▓реЗ рдЖрд╡рд╢реНрдпрдХ рд╣реЗрдбрд░ рдлрд╛рдЗрд▓рд╣рд░реВ рд╕рдорд╛рд╡реЗрд╢ рдЧрд░реНрджрдЫ, рдЬрд╕рдорд╛ `config.h` рд░ `FlashWriter` рд╣реЗрдбрд░ рдлрд╛рдЗрд▓рд╣рд░реВ рд╕рдорд╛рд╡реЗрд╢ рдЫрдиреНред

1. рдорд╛рдЗрдХреНрд░реЛрдлреЛрдирдмрд╛рдЯ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди `Mic` рдХрдХреНрд╖рд╛ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдЧрд░реНрди рдирд┐рдореНрди рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    class Mic
    {
    public:
        Mic()
        {
            _isRecording = false;
            _isRecordingReady = false;
        }
    
        void startRecording()
        {
            _isRecording = true;
            _isRecordingReady = false;
        }
    
        bool isRecording()
        {
            return _isRecording;
        }
    
        bool isRecordingReady()
        {
            return _isRecordingReady;
        }
    
    private:
        volatile bool _isRecording;
        volatile bool _isRecordingReady;
        FlashWriter _writer;
    };
    
    Mic mic;
    ```

    рдпреЛ рдХрдХреНрд╖рд╛рдорд╛ рд╣рд╛рд▓рд▓рд╛рдИ рдХреЗрд╡рд▓ рдХреЗрд╣реА рдлрд┐рд▓реНрдбрд╣рд░реВ рдЫрдиреН, рдЬрд╕рд▓реЗ рд░реЗрдХрд░реНрдбрд┐рдЩ рд╕реБрд░реБ рднрдПрдХреЛ рдЫ рдХрд┐ рдЫреИрди рд░ рд░реЗрдХрд░реНрдбрд┐рдЩ рдкреНрд░рдпреЛрдЧ рдЧрд░реНрди рддрдпрд╛рд░ рдЫ рдХрд┐ рдЫреИрди рдЯреНрд░реНрдпрд╛рдХ рдЧрд░реНрджрдЫред DMAC рд╕реЗрдЯрдЕрдк рднрдПрдкрдЫрд┐, рдпреЛ рд▓рдЧрд╛рддрд╛рд░ рдореЗрдореЛрд░реА рдмрдлрд░рд╣рд░реВрдорд╛ рд▓реЗрдЦреНрдЫ, рддреНрдпрд╕реИрд▓реЗ `_isRecording` рдлреНрд▓реНрдпрд╛рдЧрд▓реЗ рдпреА рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░реНрди рд╡рд╛ рдмреЗрд╡рд╛рд╕реНрддрд╛ рдЧрд░реНрди рдирд┐рд░реНрдзрд╛рд░рдг рдЧрд░реНрджрдЫред `_isRecordingReady` рдлреНрд▓реНрдпрд╛рдЧ рдЖрд╡рд╢реНрдпрдХ 4 рд╕реЗрдХреЗрдиреНрдбрдХреЛ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рднрдПрдкрдЫрд┐ рд╕реЗрдЯ рдЧрд░рд┐рдиреЗрдЫред `_writer` рдлрд┐рд▓реНрдб рдЕрдбрд┐рдпреЛ рдбреЗрдЯрд╛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд╕реБрд░рдХреНрд╖рд┐рдд рдЧрд░реНрди рдкреНрд░рдпреЛрдЧ рдЧрд░рд┐рдиреНрдЫред

    рддреНрдпрд╕рдкрдЫрд┐ `Mic` рдХрдХреНрд╖рд╛рдХреЛ рдЙрджрд╛рд╣рд░рдгрдХреЛ рд▓рд╛рдЧрд┐ рдПрдХ рдЧреНрд▓реЛрдмрд▓ рднреЗрд░рд┐рдПрдмрд▓ рдШреЛрд╖рдгрд╛ рдЧрд░рд┐рдиреНрдЫред

1. `Mic` рдХрдХреНрд╖рд╛рдХреЛ `private` рд╕реЗрдХреНрд╕рдирдорд╛ рдирд┐рдореНрди рдХреЛрдб рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    typedef struct
    {
        uint16_t btctrl;
        uint16_t btcnt;
        uint32_t srcaddr;
        uint32_t dstaddr;
        uint32_t descaddr;
    } dmacdescriptor;

    // Globals - DMA and ADC
    volatile dmacdescriptor _wrb[DMAC_CH_NUM] __attribute__((aligned(16)));
    dmacdescriptor _descriptor_section[DMAC_CH_NUM] __attribute__((aligned(16)));
    dmacdescriptor _descriptor __attribute__((aligned(16)));

    void configureDmaAdc()
    {
        // Configure DMA to sample from ADC at a regular interval (triggered by timer/counter)
        DMAC->BASEADDR.reg = (uint32_t)_descriptor_section;                    // Specify the location of the descriptors
        DMAC->WRBADDR.reg = (uint32_t)_wrb;                                    // Specify the location of the write back descriptors
        DMAC->CTRL.reg = DMAC_CTRL_DMAENABLE | DMAC_CTRL_LVLEN(0xf);           // Enable the DMAC peripheral
        DMAC->Channel[1].CHCTRLA.reg = DMAC_CHCTRLA_TRIGSRC(TC5_DMAC_ID_OVF) | // Set DMAC to trigger on TC5 timer overflow
                                        DMAC_CHCTRLA_TRIGACT_BURST;             // DMAC burst transfer

        _descriptor.descaddr = (uint32_t)&_descriptor_section[1];                    // Set up a circular descriptor
        _descriptor.srcaddr = (uint32_t)&ADC1->RESULT.reg;                           // Take the result from the ADC0 RESULT register
        _descriptor.dstaddr = (uint32_t)_adc_buf_0 + sizeof(uint16_t) * ADC_BUF_LEN; // Place it in the adc_buf_0 array
        _descriptor.btcnt = ADC_BUF_LEN;                                             // Beat count
        _descriptor.btctrl = DMAC_BTCTRL_BEATSIZE_HWORD |                            // Beat size is HWORD (16-bits)
                                DMAC_BTCTRL_DSTINC |                                    // Increment the destination address
                                DMAC_BTCTRL_VALID |                                     // Descriptor is valid
                                DMAC_BTCTRL_BLOCKACT_SUSPEND;                           // Suspend DMAC channel 0 after block transfer
        memcpy(&_descriptor_section[0], &_descriptor, sizeof(_descriptor));          // Copy the descriptor to the descriptor section

        _descriptor.descaddr = (uint32_t)&_descriptor_section[0];                    // Set up a circular descriptor
        _descriptor.srcaddr = (uint32_t)&ADC1->RESULT.reg;                           // Take the result from the ADC0 RESULT register
        _descriptor.dstaddr = (uint32_t)_adc_buf_1 + sizeof(uint16_t) * ADC_BUF_LEN; // Place it in the adc_buf_1 array
        _descriptor.btcnt = ADC_BUF_LEN;                                             // Beat count
        _descriptor.btctrl = DMAC_BTCTRL_BEATSIZE_HWORD |                            // Beat size is HWORD (16-bits)
                                DMAC_BTCTRL_DSTINC |                                    // Increment the destination address
                                DMAC_BTCTRL_VALID |                                     // Descriptor is valid
                                DMAC_BTCTRL_BLOCKACT_SUSPEND;                           // Suspend DMAC channel 0 after block transfer
        memcpy(&_descriptor_section[1], &_descriptor, sizeof(_descriptor));          // Copy the descriptor to the descriptor section

        // Configure NVIC
        NVIC_SetPriority(DMAC_1_IRQn, 0); // Set the Nested Vector Interrupt Controller (NVIC) priority for DMAC1 to 0 (highest)
        NVIC_EnableIRQ(DMAC_1_IRQn);      // Connect DMAC1 to Nested Vector Interrupt Controller (NVIC)

        // Activate the suspend (SUSP) interrupt on DMAC channel 1
        DMAC->Channel[1].CHINTENSET.reg = DMAC_CHINTENSET_SUSP;

        // Configure ADC
        ADC1->INPUTCTRL.bit.MUXPOS = ADC_INPUTCTRL_MUXPOS_AIN12_Val; // Set the analog input to ADC0/AIN2 (PB08 - A4 on Metro M4)
        while (ADC1->SYNCBUSY.bit.INPUTCTRL)
            ;                              // Wait for synchronization
        ADC1->SAMPCTRL.bit.SAMPLEN = 0x00; // Set max Sampling Time Length to half divided ADC clock pulse (2.66us)
        while (ADC1->SYNCBUSY.bit.SAMPCTRL)
            ;                                         // Wait for synchronization
        ADC1->CTRLA.reg = ADC_CTRLA_PRESCALER_DIV128; // Divide Clock ADC GCLK by 128 (48MHz/128 = 375kHz)
        ADC1->CTRLB.reg = ADC_CTRLB_RESSEL_12BIT |    // Set ADC resolution to 12 bits
                            ADC_CTRLB_FREERUN;          // Set ADC to free run mode
        while (ADC1->SYNCBUSY.bit.CTRLB)
            ;                       // Wait for synchronization
        ADC1->CTRLA.bit.ENABLE = 1; // Enable the ADC
        while (ADC1->SYNCBUSY.bit.ENABLE)
            ;                       // Wait for synchronization
        ADC1->SWTRIG.bit.START = 1; // Initiate a software trigger to start an ADC conversion
        while (ADC1->SYNCBUSY.bit.SWTRIG)
            ; // Wait for synchronization

        // Enable DMA channel 1
        DMAC->Channel[1].CHCTRLA.bit.ENABLE = 1;

        // Configure Timer/Counter 5
        GCLK->PCHCTRL[TC5_GCLK_ID].reg = GCLK_PCHCTRL_CHEN |     // Enable peripheral channel for TC5
                                            GCLK_PCHCTRL_GEN_GCLK1; // Connect generic clock 0 at 48MHz

        TC5->COUNT16.WAVE.reg = TC_WAVE_WAVEGEN_MFRQ; // Set TC5 to Match Frequency (MFRQ) mode
        TC5->COUNT16.CC[0].reg = 3000 - 1;            // Set the trigger to 16 kHz: (4Mhz / 16000) - 1
        while (TC5->COUNT16.SYNCBUSY.bit.CC0)
            ; // Wait for synchronization

        // Start Timer/Counter 5
        TC5->COUNT16.CTRLA.bit.ENABLE = 1; // Enable the TC5 timer
        while (TC5->COUNT16.SYNCBUSY.bit.ENABLE)
            ; // Wait for synchronization
    }

    uint16_t _adc_buf_0[ADC_BUF_LEN];
    uint16_t _adc_buf_1[ADC_BUF_LEN];
    ```

    рдпреЛ рдХреЛрдбрд▓реЗ `configureDmaAdc` рд╡рд┐рдзрд┐ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдЧрд░реНрджрдЫ, рдЬрд╕рд▓реЗ DMAC рдХрдиреНрдлрд┐рдЧрд░ рдЧрд░реНрджрдЫ, рдпрд╕рд▓рд╛рдИ ADC рд╕рдБрдЧ рдЬрдбрд╛рди рдЧрд░реНрджрдЫ рд░ рджреБрдИ рдлрд░рдХ рд╡реИрдХрд▓реНрдкрд┐рдХ рдмрдлрд░рд╣рд░реВ `_adc_buf_0` рд░ `_adc_buf_1` рдорд╛ рдбреЗрдЯрд╛ рднрд░реНрдиреЗ рд╕реЗрдЯ рдЧрд░реНрджрдЫред

    > ЁЯТБ рдорд╛рдЗрдХреНрд░реЛрдХрдиреНрдЯреНрд░реЛрд▓рд░ рд╡рд┐рдХрд╛рд╕рдХреЛ рдПрдХ рдХрдордЬреЛрд░реА рднрдиреЗрдХреЛ рд╣рд╛рд░реНрдбрд╡реЗрдпрд░рд╕рдБрдЧ рдЕрдиреНрддрд░рдХреНрд░рд┐рдпрд╛ рдЧрд░реНрди рдЖрд╡рд╢реНрдпрдХ рдХреЛрдбрдХреЛ рдЬрдЯрд┐рд▓рддрд╛ рд╣реЛ, рдХрд┐рдирднрдиреЗ рддрдкрд╛рдИрдВрдХреЛ рдХреЛрдб рд╣рд╛рд░реНрдбрд╡реЗрдпрд░рд╕рдБрдЧ рд╕рд┐рдзреИ рдХрдо рд╕реНрддрд░рдорд╛ рдЪрд▓реНрдЫред рдпреЛ рдХреЛрдб рд╕рд┐рдВрдЧрд▓-рдмреЛрд░реНрдб рдХрдореНрдкреНрдпреБрдЯрд░ рд╡рд╛ рдбреЗрд╕реНрдХрдЯрдк рдХрдореНрдкреНрдпреБрдЯрд░рдХреЛ рд▓рд╛рдЧрд┐ рд▓реЗрдЦрд┐рдиреЗ рдХреЛрдбрднрдиреНрджрд╛ рдмрдвреА рдЬрдЯрд┐рд▓ рдЫ, рдХрд┐рдирднрдиреЗ рдпрд╣рд╛рдБ рдЕрдкрд░реЗрдЯрд┐рдЩ рд╕рд┐рд╕реНрдЯрдорд▓реЗ рд╕рд╣рдпреЛрдЧ рдЧрд░реНрджреИрдиред рдХреЗрд╣реА рдкреБрд╕реНрддрдХрд╛рд▓рдпрд╣рд░реВ рдЙрдкрд▓рдмреНрдз рдЫрдиреН рдЬрд╕рд▓реЗ рдпрд╕рд▓рд╛рдИ рд╕рд░рд▓ рдмрдирд╛рдЙрди рд╕рдХреНрдЫ, рддрд░ рдЕрдЭреИ рдзреЗрд░реИ рдЬрдЯрд┐рд▓рддрд╛ рд░рд╣рдиреНрдЫред

1. рдпрд╕рдХреЛ рддрд▓, рдирд┐рдореНрди рдХреЛрдб рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    // WAV files have a header. This struct defines that header
    struct wavFileHeader
    {
        char riff[4];         /* "RIFF"                                  */
        long flength;         /* file length in bytes                    */
        char wave[4];         /* "WAVE"                                  */
        char fmt[4];          /* "fmt "                                  */
        long chunk_size;      /* size of FMT chunk in bytes (usually 16) */
        short format_tag;     /* 1=PCM, 257=Mu-Law, 258=A-Law, 259=ADPCM */
        short num_chans;      /* 1=mono, 2=stereo                        */
        long srate;           /* Sampling rate in samples per second     */
        long bytes_per_sec;   /* bytes per second = srate*bytes_per_samp */
        short bytes_per_samp; /* 2=16-bit mono, 4=16-bit stereo          */
        short bits_per_samp;  /* Number of bits per sample               */
        char data[4];         /* "data"                                  */
        long dlength;         /* data length in bytes (filelength - 44)  */
    };

    void initBufferHeader()
    {
        wavFileHeader wavh;

        strncpy(wavh.riff, "RIFF", 4);
        strncpy(wavh.wave, "WAVE", 4);
        strncpy(wavh.fmt, "fmt ", 4);
        strncpy(wavh.data, "data", 4);

        wavh.chunk_size = 16;
        wavh.format_tag = 1; // PCM
        wavh.num_chans = 1;  // mono
        wavh.srate = RATE;
        wavh.bytes_per_sec = (RATE * 1 * 16 * 1) / 8;
        wavh.bytes_per_samp = 2;
        wavh.bits_per_samp = 16;
        wavh.dlength = RATE * 2 * 1 * 16 / 2;
        wavh.flength = wavh.dlength + 44;

        _writer.writeSfudBuffer((byte *)&wavh, 44);
    }
    ```

    рдпреЛ рдХреЛрдбрд▓реЗ WAV рд╣реЗрдбрд░рд▓рд╛рдИ 44 рдмрд╛рдЗрдЯрдХреЛ рдореЗрдореЛрд░реА рдУрдЧрдЯреНрдиреЗ рд╕реНрдЯреНрд░рдХреНрдЯрдХреЛ рд░реВрдкрдорд╛ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдЧрд░реНрджрдЫред рдпрд╕рд▓реЗ рдЕрдбрд┐рдпреЛ рдлрд╛рдЗрд▓ рджрд░, рдЖрдХрд╛рд░, рд░ рдЪреНрдпрд╛рдирд▓рд╣рд░реВрдХреЛ рд╕рдВрдЦреНрдпрд╛ рдмрд╛рд░реЗ рд╡рд┐рд╡рд░рдг рд▓реЗрдЦреНрдЫред рдпреЛ рд╣реЗрдбрд░ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦрд┐рдиреНрдЫред

1. рдпрд╕ рдХреЛрдбрдХреЛ рддрд▓, рдЕрдбрд┐рдпреЛ рдмрдлрд░рд╣рд░реВ рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░реНрди рддрдпрд╛рд░ рд╣реБрдБрджрд╛ рдмреЛрд▓рд╛рдЗрдиреЗ рд╡рд┐рдзрд┐ рдШреЛрд╖рдгрд╛ рдЧрд░реНрди рдирд┐рдореНрди рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    void audioCallback(uint16_t *buf, uint32_t buf_len)
    {
        static uint32_t idx = 44;

        if (_isRecording)
        {
            for (uint32_t i = 0; i < buf_len; i++)
            {
                int16_t audio_value = ((int16_t)buf[i] - 2048) * 16;

                _writer.writeSfudBuffer(audio_value & 0xFF);
                _writer.writeSfudBuffer((audio_value >> 8) & 0xFF);
            }

            idx += buf_len;
                
            if (idx >= BUFFER_SIZE)
            {
                _writer.flushSfudBuffer();
                idx = 44;
                _isRecording = false;
                _isRecordingReady = true;
            }
        }
    }
    ```

    рдЕрдбрд┐рдпреЛ рдмрдлрд░рд╣рд░реВ 16-рдмрд┐рдЯ рдкреВрд░реНрдгрд╛рдВрдХрд╣рд░реВрдХреЛ рдПрд░реНрд░реЗ рд╣реБрдиреН, рдЬрд╕рдорд╛ ADC рдмрд╛рдЯ рдЕрдбрд┐рдпреЛ рд╣реБрдиреНрдЫред ADC рд▓реЗ 12-рдмрд┐рдЯ рдЕрд╕рд╛рдЗрди рдЧрд░рд┐рдПрдХреЛ рдорд╛рдирд╣рд░реВ (0-1023) рдлрд┐рд░реНрддрд╛ рдЧрд░реНрдЫ, рддреНрдпрд╕реИрд▓реЗ рдпреАрд▓рд╛рдИ 16-рдмрд┐рдЯ рд╕рд╛рдЗрди рдЧрд░рд┐рдПрдХреЛ рдорд╛рдирд╣рд░реВрдорд╛ рд░реВрдкрд╛рдиреНрддрд░рдг рдЧрд░реНрди рдЖрд╡рд╢реНрдпрдХ рдЫ, рд░ рддреНрдпрд╕рдкрдЫрд┐ рдХрдЪреНрдЪрд╛ рдмрд╛рдЗрдирд░реА рдбреЗрдЯрд╛ рд░реВрдкрдорд╛ рднрдгреНрдбрд╛рд░рдг рдЧрд░реНрди 2 рдмрд╛рдЗрдЯрдорд╛ рд░реВрдкрд╛рдиреНрддрд░рдг рдЧрд░реНрди рдЖрд╡рд╢реНрдпрдХ рдЫред

    рдпреА рдмрд╛рдЗрдЯрд╣рд░реВ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА рдмрдлрд░рд╣рд░реВрдорд╛ рд▓реЗрдЦрд┐рдиреНрдЫрдиреНред рд▓реЗрдЦрд╛рдЗ 44 рдорд╛ рд╕реБрд░реБ рд╣реБрдиреНрдЫ - рдпреЛ WAV рдлрд╛рдЗрд▓ рд╣реЗрдбрд░рдХреЛ рд░реВрдкрдорд╛ рд▓реЗрдЦрд┐рдПрдХрд╛ 44 рдмрд╛рдЗрдЯрд╣рд░реВрдХреЛ рдЕрдлрд╕реЗрдЯ рд╣реЛред рдЖрд╡рд╢реНрдпрдХ рдЕрдбрд┐рдпреЛ рд▓рдореНрдмрд╛рдЗрдХреЛ рд▓рд╛рдЧрд┐ рдЖрд╡рд╢реНрдпрдХ рд╕рдмреИ рдмрд╛рдЗрдЯрд╣рд░реВ рдХреНрдпрд╛рдкреНрдЪрд░ рднрдПрдкрдЫрд┐, рдмрд╛рдБрдХреА рдбреЗрдЯрд╛ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реАрдорд╛ рд▓реЗрдЦрд┐рдиреНрдЫред

1. `Mic` рдХрдХреНрд╖рд╛рдХреЛ `public` рд╕реЗрдХреНрд╕рдирдорд╛ рдирд┐рдореНрди рдХреЛрдб рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    void dmaHandler()
    {
        static uint8_t count = 0;

        if (DMAC->Channel[1].CHINTFLAG.bit.SUSP)
        {
            DMAC->Channel[1].CHCTRLB.reg = DMAC_CHCTRLB_CMD_RESUME;
            DMAC->Channel[1].CHINTFLAG.bit.SUSP = 1;

            if (count)
            {
                audioCallback(_adc_buf_0, ADC_BUF_LEN);
            }
            else
            {
                audioCallback(_adc_buf_1, ADC_BUF_LEN);
            }

            count = (count + 1) % 2;
        }
    }
    ```

    рдпреЛ рдХреЛрдб DMAC рджреНрд╡рд╛рд░рд╛ рддрдкрд╛рдИрдВрдХреЛ рдХреЛрдбрд▓рд╛рдИ рдмрдлрд░рд╣рд░реВ рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░реНрди рднрдиреНрди рдмреЛрд▓рд╛рдЗрдиреЗрдЫред рдпрд╕рд▓реЗ рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░реНрди рдбреЗрдЯрд╛ рдЫ рдХрд┐ рдЫреИрди рдЬрд╛рдБрдЪреНрдЫ, рд░ рд╕рдореНрдмрдиреНрдзрд┐рдд рдмрдлрд░рдХреЛ рд╕рд╛рде `audioCallback` рд╡рд┐рдзрд┐ рдмреЛрд▓рд╛рдЙрдБрдЫред

1. рдХрдХреНрд╖рд╛рдХреЛ рдмрд╛рд╣рд┐рд░, `Mic mic;` рдШреЛрд╖рдгрд╛рдкрдЫрд┐, рдирд┐рдореНрди рдХреЛрдб рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    void DMAC_1_Handler()
    {
        mic.dmaHandler();
    }
    ```

    `DMAC_1_Handler` DMAC рджреНрд╡рд╛рд░рд╛ рдмреЛрд▓рд╛рдЗрдиреЗрдЫ рдЬрдм рдмрдлрд░рд╣рд░реВ рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░реНрди рддрдпрд╛рд░ рд╣реБрдиреНрдЫрдиреНред рдпреЛ рдлрдЩреНрд╕рди рдирд╛рдорджреНрд╡рд╛рд░рд╛ рдлреЗрд▓рд╛ рдкрд╛рд░рд┐рдиреНрдЫ, рддреНрдпрд╕реИрд▓реЗ рдХреЗрд╡рд▓ рдЕрд╕реНрддрд┐рддреНрд╡рдорд╛ рд╣реБрди рдЖрд╡рд╢реНрдпрдХ рдЫред

1. `Mic` рдХрдХреНрд╖рд╛рдХреЛ `public` рд╕реЗрдХреНрд╕рдирдорд╛ рдирд┐рдореНрди рджреБрдИ рд╡рд┐рдзрд┐рд╣рд░реВ рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    void init()
    {
        analogReference(AR_INTERNAL2V23);

        _writer.init();

        initBufferHeader();
        configureDmaAdc();
    }

    void reset()
    {
        _isRecordingReady = false;
        _isRecording = false;

        _writer.reset();

        initBufferHeader();
    }
    ```

    `init` рд╡рд┐рдзрд┐рдорд╛ `Mic` рдХрдХреНрд╖рд╛ рдЖрд░рдореНрдн рдЧрд░реНрди рдХреЛрдб рд╕рдорд╛рд╡реЗрд╢ рдЫред рдпреЛ рд╡рд┐рдзрд┐рд▓реЗ Mic рдкрд┐рдирдХреЛ рд▓рд╛рдЧрд┐ рд╕рд╣реА рднреЛрд▓реНрдЯреЗрдЬ рд╕реЗрдЯ рдЧрд░реНрджрдЫ, рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА рд▓реЗрдЦрдХ рд╕реЗрдЯрдЕрдк рдЧрд░реНрджрдЫ, WAV рдлрд╛рдЗрд▓ рд╣реЗрдбрд░ рд▓реЗрдЦреНрдЫ, рд░ DMAC рдХрдиреНрдлрд┐рдЧрд░ рдЧрд░реНрджрдЫред `reset` рд╡рд┐рдзрд┐рд▓реЗ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рд░ рдкреНрд░рдпреЛрдЧ рднрдПрдкрдЫрд┐ рдлреНрд▓реНрдпрд╛рд╕ рдореЗрдореЛрд░реА рд░рд┐рд╕реЗрдЯ рдЧрд░реНрджрдЫ рд░ рд╣реЗрдбрд░ рдкреБрди: рд▓реЗрдЦреНрдЫред

### рдХрд╛рд░реНрдп - рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрдиреБрд╣реЛрд╕реН

1. `main.cpp` рдлрд╛рдЗрд▓рдорд╛, `mic.h` рд╣реЗрдбрд░ рдлрд╛рдЗрд▓рдХреЛ рд▓рд╛рдЧрд┐ рдЗрдирдХреНрд▓реБрдб рдирд┐рд░реНрджреЗрд╢рди рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    #include "mic.h"
    ```

1. `setup` рдлрдЩреНрд╕рдирдорд╛, C рдмрдЯрдирд▓рд╛рдИ рдЖрд░рдореНрдн рдЧрд░реНрдиреБрд╣реЛрд╕реНред рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдпреЛ рдмрдЯрди рдерд┐рдЪреНрджрд╛ рд╕реБрд░реБ рд╣реБрдиреЗрдЫ, рд░ 4 рд╕реЗрдХреЗрдиреНрдбрд╕рдореНрдо рдЬрд╛рд░реА рд░рд╣рдиреЗрдЫ:

    ```cpp
    pinMode(WIO_KEY_C, INPUT_PULLUP);
    ```

1. рдпрд╕рдХреЛ рддрд▓, рдорд╛рдЗрдХреНрд░реЛрдлреЛрди рдЖрд░рдореНрдн рдЧрд░реНрдиреБрд╣реЛрд╕реН, рддреНрдпрд╕рдкрдЫрд┐ рдХрдиреНрд╕реЛрд▓рдорд╛ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░реНрди рддрдпрд╛рд░ рдЫ рднрдиреЗрд░ рдкреНрд░рд┐рдиреНрдЯ рдЧрд░реНрдиреБрд╣реЛрд╕реН:

    ```cpp
    mic.init();

    Serial.println("Ready.");
    ```

1. `loop` рдлрдЩреНрд╕рдирднрдиреНрджрд╛ рдорд╛рдерд┐, рдХреНрдпрд╛рдкреНрдЪрд░ рдЧрд░рд┐рдПрдХреЛ рдЕрдбрд┐рдпреЛ рдкреНрд░реЛрд╕реЗрд╕ рдЧрд░реНрди рдлрдЩреНрд╕рди рдкрд░рд┐рднрд╛рд╖рд┐рдд рдЧрд░реНрдиреБрд╣реЛрд╕реНред рдЕрд╣рд┐рд▓реЗрдХрд╛ рд▓рд╛рдЧрд┐ рдпрд╕рд▓реЗ рдХреЗрд╣реА рдЧрд░реНрджреИрди, рддрд░ рдпрд╕ рдкрд╛рдардХреЛ рдкрдЫрд┐ рдпреЛ рднрд╛рд╖рдгрд▓рд╛рдИ рдкрд╛рдардорд╛ рд░реВрдкрд╛рдиреНрддрд░рдг рдЧрд░реНрди рдкрдард╛рдЙрдиреЗрдЫ:

    ```cpp
    void processAudio()
    {
    
    }
    ```

1. `loop` рдлрдЩреНрд╕рдирдорд╛ рдирд┐рдореНрди рдердкреНрдиреБрд╣реЛрд╕реН:

    ```cpp
    void loop()
    {
        if (digitalRead(WIO_KEY_C) == LOW && !mic.isRecording())
        {
            Serial.println("Starting recording...");
            mic.startRecording();
        }
    
        if (!mic.isRecording() && mic.isRecordingReady())
        {
            Serial.println("Finished recording");
    
            processAudio();
    
            mic.reset();
        }
    }
    ```

    рдпреЛ рдХреЛрдбрд▓реЗ C рдмрдЯрди рдЬрд╛рдБрдЪреНрдЫ, рд░ рдпрджрд┐ рдпреЛ рдерд┐рдЪрд┐рдПрдХреЛ рдЫ рд░ рд░реЗрдХрд░реНрдбрд┐рдЩ рд╕реБрд░реБ рднрдПрдХреЛ рдЫреИрди рднрдиреЗ, `Mic` рдХрдХреНрд╖рд╛рдХреЛ `_isRecording` рдлрд┐рд▓реНрдбрд▓рд╛рдИ `true` рдорд╛ рд╕реЗрдЯ рдЧрд░реНрджрдЫред рдпрд╕рд▓реЗ `Mic` рдХрдХреНрд╖рд╛рдХреЛ `audioCallback` рд╡рд┐рдзрд┐рд▓рд╛рдИ 4 рд╕реЗрдХреЗрдиреНрдбрд╕рдореНрдо рдЕрдбрд┐рдпреЛ рднрдгреНрдбрд╛рд░рдг рдЧрд░реНрди рдХрд╛рд░рдг рдмрдирд╛рдЙрдБрдЫред рдПрдХрдкрдЯрдХ 4 рд╕реЗрдХреЗрдиреНрдбрдХреЛ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рднрдПрдкрдЫрд┐, `_isRecording` рдлрд┐рд▓реНрдбрд▓рд╛рдИ `false` рдорд╛ рд╕реЗрдЯ рдЧрд░рд┐рдиреНрдЫ, рд░ `_isRecordingReady` рдлрд┐рд▓реНрдбрд▓рд╛рдИ `true` рдорд╛ рд╕реЗрдЯ рдЧрд░рд┐рдиреНрдЫред рдпреЛ `loop` рдлрдЩреНрд╕рдирдорд╛ рдЬрд╛рдБрдЪрд┐рдиреНрдЫ, рд░ рдЬрдм `true` рд╣реБрдиреНрдЫ, `processAudio` рдлрдЩреНрд╕рди рдмреЛрд▓рд╛рдЗрдиреНрдЫ, рддреНрдпрд╕рдкрдЫрд┐ `Mic` рдХрдХреНрд╖рд╛ рд░рд┐рд╕реЗрдЯ рдЧрд░рд┐рдиреНрдЫред

1. рдпреЛ рдХреЛрдб рдмрдирд╛рдЙрдиреБрд╣реЛрд╕реН, рдпрд╕рд▓рд╛рдИ рдЖрдлреНрдиреЛ Wio Terminal рдорд╛ рдЕрдкрд▓реЛрдб рдЧрд░реНрдиреБрд╣реЛрд╕реН рд░ рд╕рд┐рд░рд┐рдпрд▓ рдореЛрдирд┐рдЯрд░ рдорд╛рд░реНрдлрдд рдкрд░реАрдХреНрд╖рдг рдЧрд░реНрдиреБрд╣реЛрд╕реНред C рдмрдЯрди рдерд┐рдЪреНрдиреБрд╣реЛрд╕реН (рдкрд╛рд╡рд░ рд╕реНрд╡рд┐рдЪрдХреЛ рдирдЬрд┐рдХрдХреЛ рдмрд╛рдпрд╛рдБрдкрдЯреНрдЯрд┐ рд░рд╣реЗрдХреЛ рдмрдЯрди), рд░ рдмреЛрд▓реНрдиреБрд╣реЛрд╕реНред 4 рд╕реЗрдХреЗрдиреНрдбрдХреЛ рдЕрдбрд┐рдпреЛ рдХреНрдпрд╛рдкреНрдЪрд░ рд╣реБрдиреЗрдЫред

    ```output
    --- Available filters and text transformations: colorize, debug, default, direct, hexlify, log2file, nocontrol, printable, send_on_enter, time
    --- More details at http://bit.ly/pio-monitor-filters
    --- Miniterm on /dev/cu.usbmodem1101  9600,8,N,1 ---
    --- Quit: Ctrl+C | Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
    Ready.
    Starting recording...
    Finished recording
    ```
> ЁЯТБ рддрдкрд╛рдИрдВрд▓реЗ рдпреЛ рдХреЛрдб [code-record/wio-terminal](../../../../../6-consumer/lessons/1-speech-recognition/code-record/wio-terminal) рдлреЛрд▓реНрдбрд░рдорд╛ рдлреЗрд▓рд╛ рдкрд╛рд░реНрди рд╕рдХреНрдиреБрд╣реБрдиреНрдЫред
ЁЯША рддрдкрд╛рдИрдВрдХреЛ рдЕрдбрд┐рдпреЛ рд░реЗрдХрд░реНрдбрд┐рдЩ рдХрд╛рд░реНрдпрдХреНрд░рдо рд╕рдлрд▓ рднрдпреЛ!

---

**рдЕрд╕реНрд╡реАрдХрд░рдг**:  
рдпреЛ рджрд╕реНрддрд╛рд╡реЗрдЬрд╝ AI рдЕрдиреБрд╡рд╛рдж рд╕реЗрд╡рд╛ [Co-op Translator](https://github.com/Azure/co-op-translator) рдкреНрд░рдпреЛрдЧ рдЧрд░реА рдЕрдиреБрд╡рд╛рдж рдЧрд░рд┐рдПрдХреЛ рд╣реЛред рд╣рд╛рдореА рдпрдерд╛рд╕рдореНрднрд╡ рд╢реБрджреНрдзрддрд╛рдХреЛ рдкреНрд░рдпрд╛рд╕ рдЧрд░реНрдЫреМрдВ, рддрд░ рдХреГрдкрдпрд╛ рдзреНрдпрд╛рди рджрд┐рдиреБрд╣реЛрд╕реН рдХрд┐ рд╕реНрд╡рдЪрд╛рд▓рд┐рдд рдЕрдиреБрд╡рд╛рджрд╣рд░реВрдорд╛ рддреНрд░реБрдЯрд┐ рд╡рд╛ рдЕрд╢реБрджреНрдзрд┐ рд╣реБрди рд╕рдХреНрдЫред рдпрд╕рдХреЛ рдореВрд▓ рднрд╛рд╖рд╛рдорд╛ рд░рд╣реЗрдХреЛ рдореВрд▓ рджрд╕реНрддрд╛рд╡реЗрдЬрд╝рд▓рд╛рдИ рдЖрдзрд┐рдХрд╛рд░рд┐рдХ рд╕реНрд░реЛрдд рдорд╛рдирд┐рдиреБрдкрд░реНрдЫред рдорд╣рддреНрддреНрд╡рдкреВрд░реНрдг рдЬрд╛рдирдХрд╛рд░реАрдХрд╛ рд▓рд╛рдЧрд┐, рд╡реНрдпрд╛рд╡рд╕рд╛рдпрд┐рдХ рдорд╛рдирд╡ рдЕрдиреБрд╡рд╛рдж рд╕рд┐рдлрд╛рд░рд┐рд╕ рдЧрд░рд┐рдиреНрдЫред рдпрд╕ рдЕрдиреБрд╡рд╛рджрдХреЛ рдкреНрд░рдпреЛрдЧрдмрд╛рдЯ рдЙрддреНрдкрдиреНрди рд╣реБрдиреЗ рдХреБрдиреИ рдкрдирд┐ рдЧрд▓рддрдлрд╣рдореА рд╡рд╛ рдЧрд▓рдд рд╡реНрдпрд╛рдЦреНрдпрд╛рдХрд╛ рд▓рд╛рдЧрд┐ рд╣рд╛рдореА рдЬрд┐рдореНрдореЗрд╡рд╛рд░ рд╣реБрдиреЗ рдЫреИрдиреМрдВред