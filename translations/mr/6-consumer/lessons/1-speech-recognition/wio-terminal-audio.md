<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "2f336726b9410e97c3aaed76cc89b0d8",
  "translation_date": "2025-08-27T14:12:21+00:00",
  "source_file": "6-consumer/lessons/1-speech-recognition/wio-terminal-audio.md",
  "language_code": "mr"
}
-->
# рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рд╛ - Wio Terminal

рдпрд╛ рдзрдбреНрдпрд╛рдЪреНрдпрд╛ рднрд╛рдЧрд╛рдд, рддреБрдореНрд╣реА Wio Terminal рд╡рд░ рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдХреЛрдб рд▓рд┐рд╣рд╛рд▓. рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ Wio Terminal рдЪреНрдпрд╛ рд╡рд░рдЪреНрдпрд╛ рдмрд╛рдЬреВрд▓рд╛ рдЕрд╕рд▓реЗрд▓реНрдпрд╛ рдмрдЯрдгрд╛рдВрдкреИрдХреА рдПрдХрд╛ рдмрдЯрдгрд╛рджреНрд╡рд╛рд░реЗ рдирд┐рдпрдВрддреНрд░рд┐рдд рдХреЗрд▓реЗ рдЬрд╛рдИрд▓.

## рдбрд┐рд╡реНрд╣рд╛рдЗрд╕ рдкреНрд░реЛрдЧреНрд░рд╛рдо рдХрд░рд╛ рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА

рддреБрдореНрд╣реА рдорд╛рдпрдХреНрд░реЛрдлреЛрдирдордзреВрди C++ рдХреЛрдб рд╡рд╛рдкрд░реВрди рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░реВ рд╢рдХрддрд╛. Wio Terminal рдордзреНрдпреЗ рдлрдХреНрдд 192KB RAM рдЖрд╣реЗ, рдЬреЗ рдХрд╛рд╣реА рд╕реЗрдХрдВрджрд╛рдВрдкреЗрдХреНрд╖рд╛ рдЬрд╛рд╕реНрдд рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдкреБрд░реЗрд╕реЗ рдирд╛рд╣реА. рдпрд╛рдордзреНрдпреЗ 4MB рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рджреЗрдЦреАрд▓ рдЖрд╣реЗ, рдЬреА рддреНрдпрд╛рдРрд╡рдЬреА рд╡рд╛рдкрд░рд▓реА рдЬрд╛рдК рд╢рдХрддреЗ, рдХреЕрдкреНрдЪрд░ рдХреЗрд▓реЗрд▓рд╛ рдСрдбрд┐рдУ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рд╕реЗрд╡реНрд╣ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА.

рдЕрдВрдЧрднреВрдд рдорд╛рдпрдХреНрд░реЛрдлреЛрди рдЕреЕрдирд╛рд▓реЙрдЧ рд╕рд┐рдЧреНрдирд▓ рдХреЕрдкреНрдЪрд░ рдХрд░рддреЛ, рдЬреЛ рдбрд┐рдЬрд┐рдЯрд▓ рд╕рд┐рдЧреНрдирд▓рдордзреНрдпреЗ рд░реВрдкрд╛рдВрддрд░рд┐рдд рд╣реЛрддреЛ рдЬреНрдпрд╛рдЪрд╛ Wio Terminal рд╡рд╛рдкрд░ рдХрд░реВ рд╢рдХрддреЛ. рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рддрд╛рдирд╛, рдбреЗрдЯрд╛ рдпреЛрдЧреНрдп рд╡реЗрд│реА рдХреЕрдкреНрдЪрд░ рдХрд░рдгреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрд╣реЗ - рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде, 16KHz рд╡рд░ рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА, рдСрдбрд┐рдУ рдЕрдЪреВрдХрдкрдгреЗ рдкреНрд░рддрд┐ рд╕реЗрдХрдВрдж 16,000 рд╡реЗрд│рд╛ рдХреЕрдкреНрдЪрд░ рдХрд░рдгреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрд╣реЗ, рдкреНрд░рддреНрдпреЗрдХ рдирдореБрдиреНрдпрд╛рджрд░рдореНрдпрд╛рди рд╕рдорд╛рди рдЕрдВрддрд░рд╛рд╕рд╣. рддреБрдордЪрд╛ рдХреЛрдб рд╡рд╛рдкрд░рдгреНрдпрд╛рдРрд╡рдЬреА, рддреБрдореНрд╣реА рдбрд╛рдпрд░реЗрдХреНрдЯ рдореЗрдорд░реА рдНрдХреНрд╕реЗрд╕ рдХрдВрдЯреНрд░реЛрд▓рд░ (DMAC) рд╡рд╛рдкрд░реВ рд╢рдХрддрд╛. рд╣реЗ рд╕рд░реНрдХрд┐рдЯрд░реА рдЖрд╣реЗ рдЬреЗ рдХреБрдареВрди рддрд░реА рд╕рд┐рдЧреНрдирд▓ рдХреЕрдкреНрдЪрд░ рдХрд░реВ рд╢рдХрддреЗ рдЖрдгрд┐ рдореЗрдорд░реАрдордзреНрдпреЗ рд▓рд┐рд╣реВ рд╢рдХрддреЗ, рддреБрдордЪрд╛ рдХреЛрдб рдкреНрд░реЛрд╕реЗрд╕рд░рд╡рд░ рдЪрд╛рд▓рдд рдЕрд╕рддрд╛рдирд╛ рд╡реНрдпрддреНрдпрдп рди рдЖрдгрддрд╛.

тЬЕ DMA рдмрджреНрджрд▓ рдЕрдзрд┐рдХ рд╡рд╛рдЪрд╛ [Wikipedia рд╡рд░реАрд▓ рдбрд╛рдпрд░реЗрдХреНрдЯ рдореЗрдорд░реА рдНрдХреНрд╕реЗрд╕ рдкреГрд╖реНрдард╛рд╡рд░](https://wikipedia.org/wiki/Direct_memory_access).

![рдорд╛рдпрдХреНрд░реЛрдлреЛрдирдордзреВрди рдСрдбрд┐рдУ ADC рдХрдбреЗ рдЬрд╛рддреЛ рдЖрдгрд┐ рдирдВрддрд░ DMAC рдХрдбреЗ. рд╣реЗ рдПрдХрд╛ рдмрдлрд░рдордзреНрдпреЗ рд▓рд┐рд╣рд┐рддреЗ. рдЬреЗрд╡реНрд╣рд╛ рд╣рд╛ рдмрдлрд░ рдкреВрд░реНрдг рд╣реЛрддреЛ, рддреЗрд╡реНрд╣рд╛ рддреЛ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХреЗрд▓реА рдЬрд╛рддреЗ рдЖрдгрд┐ DMAC рджреБрд╕рд▒реНрдпрд╛ рдмрдлрд░рдордзреНрдпреЗ рд▓рд┐рд╣рд┐рддреЗ](../../../../../translated_images/dmac-adc-buffers.4509aee49145c90bc2e1be472b8ed2ddfcb2b6a81ad3e559114aca55f5fff759.mr.png)

DMAC ADC рдордзреВрди рдСрдбрд┐рдУ рдирд┐рд╢реНрдЪрд┐рдд рдЕрдВрддрд░рд╛рд╡рд░ рдХреЕрдкреНрдЪрд░ рдХрд░реВ рд╢рдХрддреЛ, рдЬрд╕реЗ рдХреА 16KHz рдСрдбрд┐рдУрд╕рд╛рдареА рдкреНрд░рддрд┐ рд╕реЗрдХрдВрдж 16,000 рд╡реЗрд│рд╛. рд╣реЗ рдХреЕрдкреНрдЪрд░ рдХреЗрд▓реЗрд▓рд╛ рдбреЗрдЯрд╛ рдкреВрд░реНрд╡-рдирд┐рд░реНрдзрд╛рд░рд┐рдд рдореЗрдорд░реА рдмрдлрд░рдордзреНрдпреЗ рд▓рд┐рд╣реВ рд╢рдХрддреЗ рдЖрдгрд┐ рдЬреЗрд╡реНрд╣рд╛ рд╣рд╛ рдкреВрд░реНрдг рд╣реЛрддреЛ, рддреЗрд╡реНрд╣рд╛ рддреБрдордЪреНрдпрд╛ рдХреЛрдбрд▓рд╛ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдЙрдкрд▓рдмреНрдз рдХрд░реВрди рджреЗрддреЗ. рд╣реА рдореЗрдорд░реА рд╡рд╛рдкрд░рдгреЗ рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рдгреНрдпрд╛рд╕ рд╡рд┐рд▓рдВрдм рдХрд░реВ рд╢рдХрддреЗ, рдкрд░рдВрддреБ рддреБрдореНрд╣реА рдПрдХрд╛рдзрд┐рдХ рдмрдлрд░ рд╕реЗрдЯ рдХрд░реВ рд╢рдХрддрд╛. DMAC рдмрдлрд░ 1 рдордзреНрдпреЗ рд▓рд┐рд╣рд┐рддреЗ, рдирдВрддрд░ рдЬреЗрд╡реНрд╣рд╛ рддреЗ рдкреВрд░реНрдг рд╣реЛрддреЗ, рддреБрдордЪреНрдпрд╛ рдХреЛрдбрд▓рд╛ рдмрдлрд░ 1 рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рд╕реВрдЪрд┐рдд рдХрд░рддреЗ, рддрд░ DMAC рдмрдлрд░ 2 рдордзреНрдпреЗ рд▓рд┐рд╣рд┐рддреЗ. рдЬреЗрд╡реНрд╣рд╛ рдмрдлрд░ 2 рдкреВрд░реНрдг рд╣реЛрддреЗ, рддреЗрд╡реНрд╣рд╛ рддреБрдордЪреНрдпрд╛ рдХреЛрдбрд▓рд╛ рд╕реВрдЪрд┐рдд рдХрд░рддреЗ рдЖрдгрд┐ рдкреБрдиреНрд╣рд╛ рдмрдлрд░ 1 рдордзреНрдпреЗ рд▓рд┐рд╣рд┐рдгреНрдпрд╛рд╕ рдЬрд╛рддреЗ. рдЕрд╢рд╛ рдкреНрд░рдХрд╛рд░реЗ, рдЬреЛрдкрд░реНрдпрдВрдд рддреБрдореНрд╣реА рдкреНрд░рддреНрдпреЗрдХ рдмрдлрд░ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рд▓рд╛рдЧрдгрд╛рд▒реНрдпрд╛ рд╡реЗрд│реЗрдкреЗрдХреНрд╖рд╛ рдХрдореА рд╡реЗрд│реЗрдд рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рддрд╛, рддреЛрдкрд░реНрдпрдВрдд рддреБрдореНрд╣реА рдХреЛрдгрддрд╛рд╣реА рдбреЗрдЯрд╛ рдЧрдорд╛рд╡рдгрд╛рд░ рдирд╛рд╣реА.

рдкреНрд░рддреНрдпреЗрдХ рдмрдлрд░ рдХреЕрдкреНрдЪрд░ рдЭрд╛рд▓реНрдпрд╛рдирдВрддрд░, рддреЗ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рд▓рд┐рд╣рд┐рд▓реЗ рдЬрд╛рдК рд╢рдХрддреЗ. рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрд▓рд╛ рдкрд░рд┐рднрд╛рд╖рд┐рдд рдкрддреНрддреЗ рд╡рд╛рдкрд░реВрди рд▓рд┐рд╣рд┐рд▓реЗ рдЬрд╛рдгреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрд╣реЗ, рдХреБрдареЗ рд▓рд┐рд╣рд╛рдпрдЪреЗ рдЖрдгрд┐ рдХрд┐рддреА рдореЛрдареЗ рд▓рд┐рд╣рд╛рдпрдЪреЗ рд╣реЗ рдирд┐рд░реНрджрд┐рд╖реНрдЯ рдХрд░рдгреЗ, рдореЗрдорд░реАрдордзреАрд▓ рдмрд╛рдЗрдЯреНрд╕рдЪреНрдпрд╛ рдНрд░реЗрд▓рд╛ рдЕрдкрдбреЗрдЯ рдХрд░рдгреНрдпрд╛рд╕рд╛рд░рдЦреЗ. рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рдЧреНрд░реЕрдиреНрдпреБрд▓реЕрд░рд┐рдЯреА рдЕрд╕рддреЗ, рдореНрд╣рдгрдЬреЗрдЪ рдорд┐рдЯрд╡рдгреЗ рдЖрдгрд┐ рд▓рд┐рд╣рд┐рдгреНрдпрд╛рдЪреНрдпрд╛ рдСрдкрд░реЗрд╢рдиреНрд╕ рдлрдХреНрдд рдирд┐рд╢реНрдЪрд┐рдд рдЖрдХрд╛рд░рд╛рдЪреЗ рдЕрд╕рдгреНрдпрд╛рд╡рд░рдЪ рдЕрд╡рд▓рдВрдмреВрди рдирд╕реВрди рддреНрдпрд╛ рдЖрдХрд╛рд░рд╛рд╢реА рд╕рдВрд░реЗрдЦрд┐рдд рдЕрд╕рдгреНрдпрд╛рд╡рд░рд╣реА рдЕрд╡рд▓рдВрдмреВрди рдЕрд╕рддреЗ. рдЙрджрд╛рд╣рд░рдгрд╛рд░реНрде, рдЬрд░ рдЧреНрд░реЕрдиреНрдпреБрд▓реЕрд░рд┐рдЯреА 4096 рдмрд╛рдЗрдЯреНрд╕ рдЕрд╕реЗрд▓ рдЖрдгрд┐ рддреБрдореНрд╣реА рдкрддреНрддрд╛ 4200 рд╡рд░ рдорд┐рдЯрд╡рдгреНрдпрд╛рдЪреА рд╡рд┐рдирдВрддреА рдХреЗрд▓реА, рддрд░ рддреЗ рдкрддреНрддрд╛ 4096 рддреЗ 8192 рдкрд░реНрдпрдВрддрдЪрд╛ рд╕рд░реНрд╡ рдбреЗрдЯрд╛ рдорд┐рдЯрд╡реВ рд╢рдХрддреЗ. рдпрд╛рдЪрд╛ рдЕрд░реНрде рдЕрд╕рд╛ рдХреА рдЬреЗрд╡реНрд╣рд╛ рддреБрдореНрд╣реА рдСрдбрд┐рдУ рдбреЗрдЯрд╛ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рд▓рд┐рд╣рд┐рддрд╛, рддреЗрд╡реНрд╣рд╛ рддреЗ рдпреЛрдЧреНрдп рдЖрдХрд╛рд░рд╛рдЪреНрдпрд╛ рддреБрдХрдбреНрдпрд╛рдВрдордзреНрдпреЗ рдЕрд╕рд▓реЗ рдкрд╛рд╣рд┐рдЬреЗ.

### рдХрд╛рд░реНрдп - рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рдХреЙрдиреНрдлрд┐рдЧрд░ рдХрд░рд╛

1. PlatformIO рд╡рд╛рдкрд░реВрди рдПрдХ рдирд╡реАрди Wio Terminal рдкреНрд░реЛрдЬреЗрдХреНрдЯ рддрдпрд╛рд░ рдХрд░рд╛. рдпрд╛ рдкреНрд░реЛрдЬреЗрдХреНрдЯрд▓рд╛ `smart-timer` рдЕрд╕реЗ рдирд╛рд╡ рджреНрдпрд╛. `setup` рдлрдВрдХреНрд╢рдирдордзреНрдпреЗ рд╕реАрд░рд┐рдпрд▓ рдкреЛрд░реНрдЯ рдХреЙрдиреНрдлрд┐рдЧрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдХреЛрдб рдЬреЛрдбрд╛.

1. рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рдкреНрд░рд╡реЗрд╢ рдкреНрд░рджрд╛рди рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА `platformio.ini` рдлрд╛рдЗрд▓рдордзреНрдпреЗ рдЦрд╛рд▓реАрд▓ рд▓рд╛рдпрдмреНрд░рд░реА рдбрд┐рдкреЗрдВрдбрдиреНрд╕реА рдЬреЛрдбрд╛:

    ```ini
    lib_deps =
        seeed-studio/Seeed Arduino FS @ 2.1.1
        seeed-studio/Seeed Arduino SFUD @ 2.0.2
    ```

1. `main.cpp` рдлрд╛рдЗрд▓ рдЙрдШрдбрд╛ рдЖрдгрд┐ рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рд▓рд╛рдпрдмреНрд░рд░реАрд╕рд╛рдареА рдЦрд╛рд▓реАрд▓ `include` рдирд┐рд░реНрджреЗрд╢ рдлрд╛рдЗрд▓рдЪреНрдпрд╛ рд╢реАрд░реНрд╖рд╕реНрдерд╛рдиреА рдЬреЛрдбрд╛:

    ```cpp
    #include <sfud.h>
    #include <SPI.h>
    ```

    > ЁЯОУ SFUD рдореНрд╣рдгрдЬреЗ Serial Flash Universal Driver, рдЖрдгрд┐ рд╣реА рд▓рд╛рдпрдмреНрд░рд░реА рд╕рд░реНрд╡ рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рдЪрд┐рдкреНрд╕рд╕рд╛рдареА рдХрд╛рдо рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдбрд┐рдЭрд╛рдЗрди рдХреЗрд▓реА рдЖрд╣реЗ.

1. `setup` рдлрдВрдХреНрд╢рдирдордзреНрдпреЗ, рдлреНрд▓реЕрд╢ рд╕реНрдЯреЛрд░реЗрдЬ рд▓рд╛рдпрдмреНрд░рд░реА рд╕реЗрдЯ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдЦрд╛рд▓реАрд▓ рдХреЛрдб рдЬреЛрдбрд╛:

    ```cpp
    while (!(sfud_init() == SFUD_SUCCESS))
        ;

    sfud_qspi_fast_read_enable(sfud_get_device(SFUD_W25Q32_DEVICE_INDEX), 2);
    ```

    рд╣реЗ SFUD рд▓рд╛рдпрдмреНрд░рд░реА рдЗрдирд┐рд╢рд┐рдпрд▓рд╛рдЗрдЭ рд╣реЛрдИрдкрд░реНрдпрдВрдд рд▓реВрдк рдХрд░рддреЗ, рдирдВрддрд░ рдлрд╛рд╕реНрдЯ рд░реАрдбреНрд╕ рдЪрд╛рд▓реВ рдХрд░рддреЗ. рдЕрдВрдЧрднреВрдд рдлреНрд▓реЕрд╢ рдореЗрдорд░реА Queued Serial Peripheral Interface (QSPI) рд╡рд╛рдкрд░реВрди рдНрдХреНрд╕реЗрд╕ рдХреЗрд▓реА рдЬрд╛рдК рд╢рдХрддреЗ, SPI рдХрдВрдЯреНрд░реЛрд▓рд░рдЪрд╛ рдПрдХ рдкреНрд░рдХрд╛рд░ рдЬреЛ рдорд┐рдирд┐рдорд▓ рдкреНрд░реЛрд╕реЗрд╕рд░ рд╡рд╛рдкрд░рд╛рд╕рд╣ рд╕рддрдд рдНрдХреНрд╕реЗрд╕ рдХрд░рдгреНрдпрд╛рд╕ рдЕрдиреБрдорддреА рджреЗрддреЛ. рдпрд╛рдореБрд│реЗ рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рд╡рд╛рдЪрдгреЗ рдЖрдгрд┐ рд▓рд┐рд╣рд┐рдгреЗ рд╡реЗрдЧрд╡рд╛рди рд╣реЛрддреЗ.

1. `src` рдлреЛрд▓реНрдбрд░рдордзреНрдпреЗ `flash_writer.h` рдирд╛рд╡рд╛рдЪреА рдирд╡реАрди рдлрд╛рдЗрд▓ рддрдпрд╛рд░ рдХрд░рд╛.

1. рдпрд╛ рдлрд╛рдЗрд▓рдЪреНрдпрд╛ рд╢реАрд░реНрд╖рд╕реНрдерд╛рдиреА рдЦрд╛рд▓реАрд▓ рдЬреЛрдбрд╛:

    ```cpp
    #pragma once

    #include <Arduino.h>
    #include <sfud.h>
    ```

    рд╣реЗ рдХрд╛рд╣реА рдЖрд╡рд╢реНрдпрдХ рд╣реЗрдбрд░ рдлрд╛рдЗрд▓реНрд╕ рд╕рдорд╛рд╡рд┐рд╖реНрдЯ рдХрд░рддреЗ, рдЬреНрдпрд╛рдордзреНрдпреЗ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрд╢реА рд╕рдВрд╡рд╛рдж рд╕рд╛рдзрдгреНрдпрд╛рд╕рд╛рдареА SFUD рд▓рд╛рдпрдмреНрд░рд░реАрд╕рд╛рдареА рд╣реЗрдбрд░ рдлрд╛рдЗрд▓ рд╕рдорд╛рд╡рд┐рд╖реНрдЯ рдЖрд╣реЗ.

1. рдпрд╛ рдирд╡реАрди рд╣реЗрдбрд░ рдлрд╛рдЗрд▓рдордзреНрдпреЗ `FlashWriter` рдирд╛рд╡рд╛рдЪрд╛ рдХреНрд▓рд╛рд╕ рдбрд┐рдлрд╛рдЗрди рдХрд░рд╛:

    ```cpp
    class FlashWriter
    {
    public:
    
    private:
    };
    ```

1. `private` рд╕реЗрдХреНрд╢рдирдордзреНрдпреЗ рдЦрд╛рд▓реАрд▓ рдХреЛрдб рдЬреЛрдбрд╛:

    ```cpp
    byte *_sfudBuffer;
    size_t _sfudBufferSize;
    size_t _sfudBufferPos;
    size_t _sfudBufferWritePos;

    const sfud_flash *_flash;
    ```

    рд╣реЗ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рдбреЗрдЯрд╛ рд▓рд┐рд╣рд┐рдгреНрдпрд╛рдкреВрд░реНрд╡реА рд╡рд╛рдкрд░рдгреНрдпрд╛рд╕рд╛рдареА рдмрдлрд░рд╕рд╛рдареА рдХрд╛рд╣реА рдлреАрд▓реНрдбреНрд╕ рдбрд┐рдлрд╛рдЗрди рдХрд░рддреЗ. `_sfudBuffer` рдирд╛рд╡рд╛рдЪрд╛ рдмрд╛рдЗрдЯ рдНрд░реЗ рдЖрд╣реЗ, рдЬреНрдпрд╛рдордзреНрдпреЗ рдбреЗрдЯрд╛ рд▓рд┐рд╣рд┐рд▓рд╛ рдЬрд╛рддреЛ, рдЖрдгрд┐ рдЬреЗрд╡реНрд╣рд╛ рд╣рд╛ рдкреВрд░реНрдг рд╣реЛрддреЛ, рддреЗрд╡реНрд╣рд╛ рдбреЗрдЯрд╛ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рд▓рд┐рд╣рд┐рд▓рд╛ рдЬрд╛рддреЛ. `_sfudBufferPos` рдлреАрд▓реНрдб рдмрдлрд░рдордзреНрдпреЗ рд▓рд┐рд╣рд┐рдгреНрдпрд╛рд╕рд╛рдареА рд╡рд░реНрддрдорд╛рди рд╕реНрдерд╛рди рд╕рд╛рдард╡рддреЗ, рдЖрдгрд┐ `_sfudBufferWritePos` рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рд▓рд┐рд╣рд┐рдгреНрдпрд╛рд╕рд╛рдареА рд╕реНрдерд╛рди рд╕рд╛рдард╡рддреЗ. `_flash` рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рд▓рд┐рд╣рд┐рдгреНрдпрд╛рд╕рд╛рдареА рдкреЙрдЗрдВрдЯрд░ рдЖрд╣реЗ - рдХрд╛рд╣реА рдорд╛рдпрдХреНрд░реЛрдХрдВрдЯреНрд░реЛрд▓рд░реНрд╕рдордзреНрдпреЗ рдПрдХрд╛рдзрд┐рдХ рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рдЪрд┐рдкреНрд╕ рдЕрд╕рддрд╛рдд.

1. рдпрд╛ рдХреНрд▓рд╛рд╕рдЪреНрдпрд╛ `public` рд╕реЗрдХреНрд╢рдирдордзреНрдпреЗ рдЦрд╛рд▓реАрд▓ рдореЗрдердб рдЬреЛрдбрд╛:

    ```cpp
    void init()
    {
        _flash = sfud_get_device_table() + 0;
        _sfudBufferSize = _flash->chip.erase_gran;
        _sfudBuffer = new byte[_sfudBufferSize];
        _sfudBufferPos = 0;
        _sfudBufferWritePos = 0;
    }
    ```

    рд╣реЗ Wio Terminal рд╡рд░ рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рд▓рд┐рд╣рд┐рдгреНрдпрд╛рд╕рд╛рдареА рдХреЙрдиреНрдлрд┐рдЧрд░ рдХрд░рддреЗ рдЖрдгрд┐ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдЪреНрдпрд╛ рдЧреНрд░реЗрди рд╕рд╛рдЗрдЬрд╡рд░ рдЖрдзрд╛рд░рд┐рдд рдмрдлрд░ рд╕реЗрдЯ рдХрд░рддреЗ. рд╣реЗ `init` рдореЗрдердбрдордзреНрдпреЗ рдЖрд╣реЗ, рдХрдиреНрд╕реНрдЯреНрд░рдХреНрдЯрд░рдРрд╡рдЬреА рдХрд╛рд░рдг рд╣реЗ `setup` рдлрдВрдХреНрд╢рдирдордзреНрдпреЗ рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рд╕реЗрдЯ рдХреЗрд▓реНрдпрд╛рдирдВрддрд░ рдХреЙрд▓ рдХреЗрд▓реЗ рдЬрд╛рдгреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрд╣реЗ.

1. `public` рд╕реЗрдХреНрд╢рдирдордзреНрдпреЗ рдЦрд╛рд▓реАрд▓ рдХреЛрдб рдЬреЛрдбрд╛:

    ```cpp
    void writeSfudBuffer(byte b)
    {
        _sfudBuffer[_sfudBufferPos++] = b;
        if (_sfudBufferPos == _sfudBufferSize)
        {
            sfud_erase_write(_flash, _sfudBufferWritePos, _sfudBufferSize, _sfudBuffer);
            _sfudBufferWritePos += _sfudBufferSize;
            _sfudBufferPos = 0;
        }
    }

    void writeSfudBuffer(byte *b, size_t len)
    {
        for (size_t i = 0; i < len; ++i)
        {
            writeSfudBuffer(b[i]);
        }
    }

    void flushSfudBuffer()
    {
        if (_sfudBufferPos > 0)
        {
            sfud_erase_write(_flash, _sfudBufferWritePos, _sfudBufferSize, _sfudBuffer);
            _sfudBufferWritePos += _sfudBufferSize;
            _sfudBufferPos = 0;
        }
    }
    ```

    рд╣реЗ рдлреНрд▓реЕрд╢ рд╕реНрдЯреЛрд░реЗрдЬ рд╕рд┐рд╕реНрдЯрдордордзреНрдпреЗ рдмрд╛рдЗрдЯреНрд╕ рд▓рд┐рд╣рд┐рдгреНрдпрд╛рд╕рд╛рдареА рдореЗрдердбреНрд╕ рдбрд┐рдлрд╛рдЗрди рдХрд░рддреЗ. рд╣реЗ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрд╕рд╛рдареА рдпреЛрдЧреНрдп рдЖрдХрд╛рд░рд╛рдЪреНрдпрд╛ рдЗрди-рдореЗрдорд░реА рдмрдлрд░рдордзреНрдпреЗ рд▓рд┐рд╣рд┐рдгреНрдпрд╛рдЪреЗ рдХрд╛рдо рдХрд░рддреЗ, рдЖрдгрд┐ рдЬреЗрд╡реНрд╣рд╛ рд╣рд╛ рдкреВрд░реНрдг рд╣реЛрддреЛ, рддреЗрд╡реНрд╣рд╛ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рд▓рд┐рд╣рд┐рд▓реЗ рдЬрд╛рддреЗ, рддреНрдпрд╛ рдард┐рдХрд╛рдгреА рдЕрд╕рд▓реЗрд▓рд╛ рдХреЛрдгрддрд╛рд╣реА рд╡рд┐рджреНрдпрдорд╛рди рдбреЗрдЯрд╛ рдорд┐рдЯрд╡реВрди. `flushSfudBuffer` рджреЗрдЦреАрд▓ рдЖрд╣реЗ, рдЬреЛ рдЕрдкреВрд░реНрдг рдмрдлрд░ рд▓рд┐рд╣рд┐рддреЛ, рдХрд╛рд░рдг рдХреЕрдкреНрдЪрд░ рдХреЗрд▓реЗрд▓рд╛ рдбреЗрдЯрд╛ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдЪреНрдпрд╛ рдЧреНрд░реЗрди рд╕рд╛рдЗрдЬрдЪреНрдпрд╛ рдЕрдЪреВрдХ рдЧреБрдгрд╛рдХрд╛рд░рд╛рдВрдордзреНрдпреЗ рдирд╕реЗрд▓, рддреНрдпрд╛рдореБрд│реЗ рдбреЗрдЯрд╛рдЪрд╛ рд╢реЗрд╡рдЯрдЪрд╛ рднрд╛рдЧ рд▓рд┐рд╣рд┐рд▓рд╛ рдЬрд╛рдгреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрд╣реЗ.

    > ЁЯТБ рдбреЗрдЯрд╛рдЪрд╛ рд╢реЗрд╡рдЯрдЪрд╛ рднрд╛рдЧ рдЕрддрд┐рд░рд┐рдХреНрдд рдЕрд╡рд╛рдВрдЫрд┐рдд рдбреЗрдЯрд╛ рд▓рд┐рд╣реАрд▓, рдкрд░рдВрддреБ рд╣реЗ рдареАрдХ рдЖрд╣реЗ рдХрд╛рд░рдг рдлрдХреНрдд рдЖрд╡рд╢реНрдпрдХ рдбреЗрдЯрд╛ рд╡рд╛рдЪрд▓рд╛ рдЬрд╛рдИрд▓.

### рдХрд╛рд░реНрдп - рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рд╕реЗрдЯ рдХрд░рд╛

1. `src` рдлреЛрд▓реНрдбрд░рдордзреНрдпреЗ `config.h` рдирд╛рд╡рд╛рдЪреА рдирд╡реАрди рдлрд╛рдЗрд▓ рддрдпрд╛рд░ рдХрд░рд╛.

1. рдпрд╛ рдлрд╛рдЗрд▓рдЪреНрдпрд╛ рд╢реАрд░реНрд╖рд╕реНрдерд╛рдиреА рдЦрд╛рд▓реАрд▓ рдЬреЛрдбрд╛:

    ```cpp
    #pragma once

    #define RATE 16000
    #define SAMPLE_LENGTH_SECONDS 4
    #define SAMPLES RATE * SAMPLE_LENGTH_SECONDS
    #define BUFFER_SIZE (SAMPLES * 2) + 44
    #define ADC_BUF_LEN 1600
    ```

    рд╣реЗ рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░рд╕рд╛рдареА рдХрд╛рд╣реА рд╕реНрдерд┐рд░рд╛рдВрдХ рд╕реЗрдЯ рдХрд░рддреЗ.

    | рд╕реНрдерд┐рд░рд╛рдВрдХ              | рдореВрд▓реНрдп  | рд╡рд░реНрдгрди |
    | --------------------- | -----: | - |
    | RATE                  | 16000  | рдСрдбрд┐рдУрд╕рд╛рдареА рд╕реЕрдореНрдкрд▓ рд░реЗрдЯ. 16,000 рдореНрд╣рдгрдЬреЗ 16KHz |
    | SAMPLE_LENGTH_SECONDS | 4      | рдХреЕрдкреНрдЪрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдСрдбрд┐рдУрдЪреА рд▓рд╛рдВрдмреА. рд╣реЗ 4 рд╕реЗрдХрдВрджрд╛рдВрд╡рд░ рд╕реЗрдЯ рдХреЗрд▓реЗ рдЖрд╣реЗ. рдЬрд╛рд╕реНрдд рдСрдбрд┐рдУ рд░реЗрдХреЙрд░реНрдб рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА, рд╣реЗ рд╡рд╛рдврд╡рд╛. |
    | SAMPLES               | 64000  | рдХреЕрдкреНрдЪрд░ рдХреЗрд▓реЗрд▓реНрдпрд╛ рдСрдбрд┐рдУ рд╕реЕрдореНрдкрд▓реНрд╕рдЪреА рдПрдХреВрдг рд╕рдВрдЦреНрдпрд╛. рд╕реЕрдореНрдкрд▓ рд░реЗрдЯ * рд╕реЗрдХрдВрджрд╛рдВрдЪреА рд╕рдВрдЦреНрдпрд╛ |
    | BUFFER_SIZE           | 128044 | рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдмрдлрд░рдЪрд╛ рдЖрдХрд╛рд░. рдСрдбрд┐рдУ WAV рдлрд╛рдЗрд▓ рдореНрд╣рдгреВрди рдХреЕрдкреНрдЪрд░ рдХреЗрд▓рд╛ рдЬрд╛рдИрд▓, рдЬреНрдпрд╛рдордзреНрдпреЗ 44 рдмрд╛рдЗрдЯреНрд╕ рд╣реЗрдбрд░, рдирдВрддрд░ 128,000 рдмрд╛рдЗрдЯреНрд╕ рдСрдбрд┐рдУ рдбреЗрдЯрд╛ (рдкреНрд░рддреНрдпреЗрдХ рд╕реЕрдореНрдкрд▓ 2 рдмрд╛рдЗрдЯреНрд╕ рдЖрд╣реЗ) |
    | ADC_BUF_LEN           | 1600   | DMAC рдордзреВрди рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рд╡рд╛рдкрд░рдгреНрдпрд╛рд╕рд╛рдареА рдмрдлрд░рдЪрд╛ рдЖрдХрд╛рд░ |

    > ЁЯТБ рдЬрд░ рддреБрдореНрд╣рд╛рд▓рд╛ 4 рд╕реЗрдХрдВрдж рдЦреВрдк рдХрдореА рд╡рд╛рдЯрдд рдЕрд╕рддреАрд▓, рддрд░ `SAMPLE_LENGTH_SECONDS` рдореВрд▓реНрдп рд╡рд╛рдврд╡рд╛, рдЖрдгрд┐ рдЗрддрд░ рд╕рд░реНрд╡ рдореВрд▓реНрдпреЗ рдкреБрдиреНрд╣рд╛ рдЧрдгрдирд╛ рд╣реЛрддреАрд▓.

1. `src` рдлреЛрд▓реНрдбрд░рдордзреНрдпреЗ `mic.h` рдирд╛рд╡рд╛рдЪреА рдирд╡реАрди рдлрд╛рдЗрд▓ рддрдпрд╛рд░ рдХрд░рд╛.

1. рдпрд╛ рдлрд╛рдЗрд▓рдЪреНрдпрд╛ рд╢реАрд░реНрд╖рд╕реНрдерд╛рдиреА рдЦрд╛рд▓реАрд▓ рдЬреЛрдбрд╛:

    ```cpp
    #pragma once

    #include <Arduino.h>

    #include "config.h"
    #include "flash_writer.h"
    ```

    рд╣реЗ рдХрд╛рд╣реА рдЖрд╡рд╢реНрдпрдХ рд╣реЗрдбрд░ рдлрд╛рдЗрд▓реНрд╕ рд╕рдорд╛рд╡рд┐рд╖реНрдЯ рдХрд░рддреЗ, рдЬреНрдпрд╛рдордзреНрдпреЗ `config.h` рдЖрдгрд┐ `FlashWriter` рд╣реЗрдбрд░ рдлрд╛рдЗрд▓реНрд╕ рд╕рдорд╛рд╡рд┐рд╖реНрдЯ рдЖрд╣реЗрдд.

1. рдорд╛рдпрдХреНрд░реЛрдлреЛрдирдордзреВрди рдХреЕрдкреНрдЪрд░ рдХрд░реВ рд╢рдХрдгрд╛рд░рд╛ `Mic` рдХреНрд▓рд╛рд╕ рдбрд┐рдлрд╛рдЗрди рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдЦрд╛рд▓реАрд▓ рдЬреЛрдбрд╛:

    ```cpp
    class Mic
    {
    public:
        Mic()
        {
            _isRecording = false;
            _isRecordingReady = false;
        }
    
        void startRecording()
        {
            _isRecording = true;
            _isRecordingReady = false;
        }
    
        bool isRecording()
        {
            return _isRecording;
        }
    
        bool isRecordingReady()
        {
            return _isRecordingReady;
        }
    
    private:
        volatile bool _isRecording;
        volatile bool _isRecordingReady;
        FlashWriter _writer;
    };
    
    Mic mic;
    ```

    рд╕рдзреНрдпрд╛ рдпрд╛ рдХреНрд▓рд╛рд╕рдордзреНрдпреЗ рд░реЗрдХреЙрд░реНрдбрд┐рдВрдЧ рд╕реБрд░реВ рдЭрд╛рд▓реЗ рдЖрд╣реЗ рдХрд╛ рдЖрдгрд┐ рд░реЗрдХреЙрд░реНрдбрд┐рдВрдЧ рд╡рд╛рдкрд░рдгреНрдпрд╛рд╕рд╛рдареА рддрдпрд╛рд░ рдЖрд╣реЗ рдХрд╛ рд╣реЗ рдЯреНрд░реЕрдХ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдХрд╛рд╣реА рдлреАрд▓реНрдбреНрд╕ рдЖрд╣реЗрдд. DMAC рд╕реЗрдЯ рдХреЗрд▓реНрдпрд╛рд╡рд░, рддреЛ рд╕рддрдд рдореЗрдорд░реА рдмрдлрд░рдордзреНрдпреЗ рд▓рд┐рд╣рд┐рдд рд░рд╛рд╣рддреЛ, рддреНрдпрд╛рдореБрд│реЗ `_isRecording` рдлреНрд▓реЕрдЧ рдард░рд╡рддреЛ рдХреА рд╣реЗ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рд╛рдпрдЪреЗ рдХреА рджреБрд░реНрд▓рдХреНрд╖ рдХрд░рд╛рдпрдЪреЗ. `_isRecordingReady` рдлреНрд▓реЕрдЧ рдЖрд╡рд╢реНрдпрдХ 4 рд╕реЗрдХрдВрджрд╛рдВрдЪрд╛ рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдЭрд╛рд▓реНрдпрд╛рд╡рд░ рд╕реЗрдЯ рдХреЗрд▓рд╛ рдЬрд╛рдИрд▓. `_writer` рдлреАрд▓реНрдб рдСрдбрд┐рдУ рдбреЗрдЯрд╛ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рд╕реЗрд╡реНрд╣ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рд╡рд╛рдкрд░рд▓рд╛ рдЬрд╛рддреЛ.

    рдирдВрддрд░ `Mic` рдХреНрд▓рд╛рд╕рдЪреНрдпрд╛ рдЙрджрд╛рд╣рд░рдгрд╛рд╕рд╛рдареА рдПрдХ рдЧреНрд▓реЛрдмрд▓ рд╡реНрд╣реЗрд░рд┐рдПрдмрд▓ рдШреЛрд╖рд┐рдд рдХреЗрд▓реА рдЬрд╛рддреЗ.

1. `Mic` рдХреНрд▓рд╛рд╕рдЪреНрдпрд╛ `private` рд╕реЗрдХреНрд╢рдирдордзреНрдпреЗ рдЦрд╛рд▓реАрд▓ рдХреЛрдб рдЬреЛрдбрд╛:

    ```cpp
    typedef struct
    {
        uint16_t btctrl;
        uint16_t btcnt;
        uint32_t srcaddr;
        uint32_t dstaddr;
        uint32_t descaddr;
    } dmacdescriptor;

    // Globals - DMA and ADC
    volatile dmacdescriptor _wrb[DMAC_CH_NUM] __attribute__((aligned(16)));
    dmacdescriptor _descriptor_section[DMAC_CH_NUM] __attribute__((aligned(16)));
    dmacdescriptor _descriptor __attribute__((aligned(16)));

    void configureDmaAdc()
    {
        // Configure DMA to sample from ADC at a regular interval (triggered by timer/counter)
        DMAC->BASEADDR.reg = (uint32_t)_descriptor_section;                    // Specify the location of the descriptors
        DMAC->WRBADDR.reg = (uint32_t)_wrb;                                    // Specify the location of the write back descriptors
        DMAC->CTRL.reg = DMAC_CTRL_DMAENABLE | DMAC_CTRL_LVLEN(0xf);           // Enable the DMAC peripheral
        DMAC->Channel[1].CHCTRLA.reg = DMAC_CHCTRLA_TRIGSRC(TC5_DMAC_ID_OVF) | // Set DMAC to trigger on TC5 timer overflow
                                        DMAC_CHCTRLA_TRIGACT_BURST;             // DMAC burst transfer

        _descriptor.descaddr = (uint32_t)&_descriptor_section[1];                    // Set up a circular descriptor
        _descriptor.srcaddr = (uint32_t)&ADC1->RESULT.reg;                           // Take the result from the ADC0 RESULT register
        _descriptor.dstaddr = (uint32_t)_adc_buf_0 + sizeof(uint16_t) * ADC_BUF_LEN; // Place it in the adc_buf_0 array
        _descriptor.btcnt = ADC_BUF_LEN;                                             // Beat count
        _descriptor.btctrl = DMAC_BTCTRL_BEATSIZE_HWORD |                            // Beat size is HWORD (16-bits)
                                DMAC_BTCTRL_DSTINC |                                    // Increment the destination address
                                DMAC_BTCTRL_VALID |                                     // Descriptor is valid
                                DMAC_BTCTRL_BLOCKACT_SUSPEND;                           // Suspend DMAC channel 0 after block transfer
        memcpy(&_descriptor_section[0], &_descriptor, sizeof(_descriptor));          // Copy the descriptor to the descriptor section

        _descriptor.descaddr = (uint32_t)&_descriptor_section[0];                    // Set up a circular descriptor
        _descriptor.srcaddr = (uint32_t)&ADC1->RESULT.reg;                           // Take the result from the ADC0 RESULT register
        _descriptor.dstaddr = (uint32_t)_adc_buf_1 + sizeof(uint16_t) * ADC_BUF_LEN; // Place it in the adc_buf_1 array
        _descriptor.btcnt = ADC_BUF_LEN;                                             // Beat count
        _descriptor.btctrl = DMAC_BTCTRL_BEATSIZE_HWORD |                            // Beat size is HWORD (16-bits)
                                DMAC_BTCTRL_DSTINC |                                    // Increment the destination address
                                DMAC_BTCTRL_VALID |                                     // Descriptor is valid
                                DMAC_BTCTRL_BLOCKACT_SUSPEND;                           // Suspend DMAC channel 0 after block transfer
        memcpy(&_descriptor_section[1], &_descriptor, sizeof(_descriptor));          // Copy the descriptor to the descriptor section

        // Configure NVIC
        NVIC_SetPriority(DMAC_1_IRQn, 0); // Set the Nested Vector Interrupt Controller (NVIC) priority for DMAC1 to 0 (highest)
        NVIC_EnableIRQ(DMAC_1_IRQn);      // Connect DMAC1 to Nested Vector Interrupt Controller (NVIC)

        // Activate the suspend (SUSP) interrupt on DMAC channel 1
        DMAC->Channel[1].CHINTENSET.reg = DMAC_CHINTENSET_SUSP;

        // Configure ADC
        ADC1->INPUTCTRL.bit.MUXPOS = ADC_INPUTCTRL_MUXPOS_AIN12_Val; // Set the analog input to ADC0/AIN2 (PB08 - A4 on Metro M4)
        while (ADC1->SYNCBUSY.bit.INPUTCTRL)
            ;                              // Wait for synchronization
        ADC1->SAMPCTRL.bit.SAMPLEN = 0x00; // Set max Sampling Time Length to half divided ADC clock pulse (2.66us)
        while (ADC1->SYNCBUSY.bit.SAMPCTRL)
            ;                                         // Wait for synchronization
        ADC1->CTRLA.reg = ADC_CTRLA_PRESCALER_DIV128; // Divide Clock ADC GCLK by 128 (48MHz/128 = 375kHz)
        ADC1->CTRLB.reg = ADC_CTRLB_RESSEL_12BIT |    // Set ADC resolution to 12 bits
                            ADC_CTRLB_FREERUN;          // Set ADC to free run mode
        while (ADC1->SYNCBUSY.bit.CTRLB)
            ;                       // Wait for synchronization
        ADC1->CTRLA.bit.ENABLE = 1; // Enable the ADC
        while (ADC1->SYNCBUSY.bit.ENABLE)
            ;                       // Wait for synchronization
        ADC1->SWTRIG.bit.START = 1; // Initiate a software trigger to start an ADC conversion
        while (ADC1->SYNCBUSY.bit.SWTRIG)
            ; // Wait for synchronization

        // Enable DMA channel 1
        DMAC->Channel[1].CHCTRLA.bit.ENABLE = 1;

        // Configure Timer/Counter 5
        GCLK->PCHCTRL[TC5_GCLK_ID].reg = GCLK_PCHCTRL_CHEN |     // Enable peripheral channel for TC5
                                            GCLK_PCHCTRL_GEN_GCLK1; // Connect generic clock 0 at 48MHz

        TC5->COUNT16.WAVE.reg = TC_WAVE_WAVEGEN_MFRQ; // Set TC5 to Match Frequency (MFRQ) mode
        TC5->COUNT16.CC[0].reg = 3000 - 1;            // Set the trigger to 16 kHz: (4Mhz / 16000) - 1
        while (TC5->COUNT16.SYNCBUSY.bit.CC0)
            ; // Wait for synchronization

        // Start Timer/Counter 5
        TC5->COUNT16.CTRLA.bit.ENABLE = 1; // Enable the TC5 timer
        while (TC5->COUNT16.SYNCBUSY.bit.ENABLE)
            ; // Wait for synchronization
    }

    uint16_t _adc_buf_0[ADC_BUF_LEN];
    uint16_t _adc_buf_1[ADC_BUF_LEN];
    ```

    рд╣реЗ `configureDmaAdc` рдореЗрдердб рдбрд┐рдлрд╛рдЗрди рдХрд░рддреЗ рдЬреЗ DMAC рдХреЙрдиреНрдлрд┐рдЧрд░ рдХрд░рддреЗ, ADC рд╢реА рдХрдиреЗрдХреНрдЯ рдХрд░рддреЗ рдЖрдгрд┐ рджреЛрди рд╡реЗрдЧрд│реНрдпрд╛ рдкрд░реНрдпрд╛рдпреА рдмрдлрд░ `_adc_buf_0` рдЖрдгрд┐ `_adc_buf_1` рд╕реЗрдЯ рдХрд░рддреЗ.

    > ЁЯТБ рдорд╛рдпрдХреНрд░реЛрдХрдВрдЯреНрд░реЛрд▓рд░ рдбреЗрд╡реНрд╣рд▓рдкрдореЗрдВрдЯрдЪрд╛ рдПрдХ рддреЛрдЯрд╛ рдореНрд╣рдгрдЬреЗ рд╣рд╛рд░реНрдбрд╡реЗрдЕрд░рд╢реА рд╕рдВрд╡рд╛рдж рд╕рд╛рдзрдгреНрдпрд╛рд╕рд╛рдареА рдЖрд╡рд╢реНрдпрдХ рдЕрд╕рд▓реЗрд▓реНрдпрд╛ рдХреЛрдбрдЪреА рдЧреБрдВрддрд╛рдЧреБрдВрдд, рдХрд╛рд░рдг рддреБрдордЪрд╛ рдХреЛрдб рд╣рд╛рд░реНрдбрд╡реЗрдЕрд░рд╢реА рдереЗрдЯ рд╕рдВрд╡рд╛рдж рд╕рд╛рдзрдд рдЦреВрдк рдХрдореА рд╕реНрддрд░рд╛рд╡рд░ рдЪрд╛рд▓рддреЛ. рд╣реЗ рдХреЛрдб рд╕рд┐рдВрдЧрд▓-рдмреЛрд░реНрдб рдХрдВрдкреНрдпреВрдЯрд░ рдХрд┐рдВрд╡рд╛ рдбреЗрд╕реНрдХрдЯреЙрдк рдХрдВрдкреНрдпреВрдЯрд░рд╕рд╛рдареА рд▓рд┐рд╣рд┐рд▓реЗрд▓реНрдпрд╛ рдХреЛрдбрдкреЗрдХреНрд╖рд╛ рдЕрдзрд┐рдХ рдЬрдЯрд┐рд▓ рдЖрд╣реЗ рдХрд╛рд░рдг рдСрдкрд░реЗрдЯрд┐рдВрдЧ рд╕рд┐рд╕реНрдЯрдо рдорджрдд рдХрд░рдд рдирд╛рд╣реА. рдХрд╛рд╣реА рд▓рд╛рдпрдмреНрд░рд░реА рдЙрдкрд▓рдмреНрдз рдЖрд╣реЗрдд рдЬреНрдпрд╛ рд╣реЗ рд╕реЛрдкреЗ рдХрд░реВ рд╢рдХрддрд╛рдд, рдкрд░рдВрддреБ рддрд░реАрд╣реА рдмрд░реАрдЪ рдЧреБрдВрддрд╛рдЧреБрдВрдд рдЖрд╣реЗ.

1. рдЦрд╛рд▓реАрд▓ рдХреЛрдб рдЬреЛрдбрд╛:

    ```cpp
    // WAV files have a header. This struct defines that header
    struct wavFileHeader
    {
        char riff[4];         /* "RIFF"                                  */
        long flength;         /* file length in bytes                    */
        char wave[4];         /* "WAVE"                                  */
        char fmt[4];          /* "fmt "                                  */
        long chunk_size;      /* size of FMT chunk in bytes (usually 16) */
        short format_tag;     /* 1=PCM, 257=Mu-Law, 258=A-Law, 259=ADPCM */
        short num_chans;      /* 1=mono, 2=stereo                        */
        long srate;           /* Sampling rate in samples per second     */
        long bytes_per_sec;   /* bytes per second = srate*bytes_per_samp */
        short bytes_per_samp; /* 2=16-bit mono, 4=16-bit stereo          */
        short bits_per_samp;  /* Number of bits per sample               */
        char data[4];         /* "data"                                  */
        long dlength;         /* data length in bytes (filelength - 44)  */
    };

    void initBufferHeader()
    {
        wavFileHeader wavh;

        strncpy(wavh.riff, "RIFF", 4);
        strncpy(wavh.wave, "WAVE", 4);
        strncpy(wavh.fmt, "fmt ", 4);
        strncpy(wavh.data, "data", 4);

        wavh.chunk_size = 16;
        wavh.format_tag = 1; // PCM
        wavh.num_chans = 1;  // mono
        wavh.srate = RATE;
        wavh.bytes_per_sec = (RATE * 1 * 16 * 1) / 8;
        wavh.bytes_per_samp = 2;
        wavh.bits_per_samp = 16;
        wavh.dlength = RATE * 2 * 1 * 16 / 2;
        wavh.flength = wavh.dlength + 44;

        _writer.writeSfudBuffer((byte *)&wavh, 44);
    }
    ```

    рд╣реЗ WAV рд╣реЗрдбрд░ 44 рдмрд╛рдЗрдЯреНрд╕ рдореЗрдорд░реА рдШреЗрдгрд╛рд▒реНрдпрд╛ рд╕реНрдЯреНрд░рдХреНрдЪрд░ рдореНрд╣рдгреВрди рдбрд┐рдлрд╛рдЗрди рдХрд░рддреЗ. рдСрдбрд┐рдУ рдлрд╛рдЗрд▓ рд░реЗрдЯ, рдЖрдХрд╛рд░ рдЖрдгрд┐ рдЪреЕрдиреЗрд▓реНрд╕рдмрджреНрджрд▓ рддрдкрд╢реАрд▓ рд▓рд┐рд╣рд┐рддреЗ. рдирдВрддрд░ рд╣рд╛ рд╣реЗрдбрд░ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рд▓рд┐рд╣рд┐рд▓рд╛ рдЬрд╛рддреЛ.

1. рдЦрд╛рд▓реАрд▓ рдХреЛрдб рдЬреЛрдбрд╛, рдЬреЗрд╡реНрд╣рд╛ рдСрдбрд┐рдУ рдмрдлрд░ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рддрдпрд╛рд░ рдЕрд╕рддреАрд▓ рддреЗрд╡реНрд╣рд╛ рдХреЙрд▓ рдХреЗрд▓реЗ рдЬрд╛рдгрд╛рд░реЗ рдореЗрдердб рдШреЛрд╖рд┐рдд рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА:

    ```cpp
    void audioCallback(uint16_t *buf, uint32_t buf_len)
    {
        static uint32_t idx = 44;

        if (_isRecording)
        {
            for (uint32_t i = 0; i < buf_len; i++)
            {
                int16_t audio_value = ((int16_t)buf[i] - 2048) * 16;

                _writer.writeSfudBuffer(audio_value & 0xFF);
                _writer.writeSfudBuffer((audio_value >> 8) & 0xFF);
            }

            idx += buf_len;
                
            if (idx >= BUFFER_SIZE)
            {
                _writer.flushSfudBuffer();
                idx = 44;
                _isRecording = false;
                _isRecordingReady = true;
            }
        }
    }
    ```

    рдСрдбрд┐рдУ рдмрдлрд░ ADC рдордзреВрди рдСрдбрд┐рдУ рдЕрд╕рд▓реЗрд▓реНрдпрд╛ 16-рдмрд┐рдЯ рдкреВрд░реНрдгрд╛рдВрдХрд╛рдВрдЪреНрдпрд╛ рдНрд░реЗ рдЖрд╣реЗрдд. ADC 12-рдмрд┐рдЯ рдЕрдирд╕рд╛рдЗрди рд╡реНрд╣реЕрд▓реНрдпреВ (0-1023) рдкрд░рдд рдХрд░рддреЗ, рддреНрдпрд╛рдореБрд│реЗ рддреНрдпрд╛рдВрдирд╛ 16-рдмрд┐рдЯ рд╕рд╛рдЗрди рд╡реНрд╣реЕрд▓реНрдпреВрдордзреНрдпреЗ рд░реВрдкрд╛рдВрддрд░рд┐рдд рдХрд░рдгреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрд╣реЗ, рдЖрдгрд┐ рдирдВрддрд░ рдХрдЪреНрдЪреНрдпрд╛ рдмрд╛рдпрдирд░реА рдбреЗрдЯрд╛рдордзреНрдпреЗ рд╕реНрдЯреЛрдЕрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА 2 рдмрд╛рдЗрдЯреНрд╕рдордзреНрдпреЗ рд░реВрдкрд╛рдВрддрд░рд┐рдд рдХрд░рдгреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрд╣реЗ.

    рд╣реЗ рдмрд╛рдЗрдЯреНрд╕ рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рдмрдлрд░рдордзреНрдпреЗ рд▓рд┐рд╣рд┐рд▓реЗ рдЬрд╛рддрд╛рдд. рд▓реЗрдЦрди 44 рд╡рд░ рд╕реБрд░реВ рд╣реЛрддреЗ - рд╣реЗ WAV рдлрд╛рдЗрд▓ рд╣реЗрдбрд░ рдореНрд╣рдгреВрди рд▓рд┐рд╣рд┐рд▓реЗрд▓реНрдпрд╛ 44 рдмрд╛рдЗрдЯреНрд╕рдЪреНрдпрд╛ рдСрдлрд╕реЗрдЯ рдЖрд╣реЗ. рдЖрд╡рд╢реНрдпрдХ рдСрдбрд┐рдУ рд▓рд╛рдВрдмреАрд╕рд╛рдареА рдЖрд╡рд╢реНрдпрдХ рдЕрд╕рд▓реЗрд▓реЗ рд╕рд░реНрд╡ рдмрд╛рдЗрдЯреНрд╕ рдХреЕрдкреНрдЪрд░ рдЭрд╛рд▓реНрдпрд╛рдирдВрддрд░, рдЙрд░реНрд╡рд░рд┐рдд рдбреЗрдЯрд╛ рдлреНрд▓реЕрд╢ рдореЗрдорд░реАрдордзреНрдпреЗ рд▓рд┐рд╣рд┐рд▓рд╛ рдЬрд╛рддреЛ.

1. `Mic` рдХреНрд▓рд╛рд╕рдЪреНрдпрд╛ `public` рд╕реЗрдХреНрд╢рдирдордзреНрдпреЗ рдЦрд╛рд▓реАрд▓ рдХреЛрдб рдЬреЛрдбрд╛:

    ```cpp
    void dmaHandler()
    {
        static uint8_t count = 0;

        if (DMAC->Channel[1].CHINTFLAG.bit.SUSP)
        {
            DMAC->Channel[1].CHCTRLB.reg = DMAC_CHCTRLB_CMD_RESUME;
            DMAC->Channel[1].CHINTFLAG.bit.SUSP = 1;

            if (count)
            {
                audioCallback(_adc_buf_0, ADC_BUF_LEN);
            }
            else
            {
                audioCallback(_adc_buf_1, ADC_BUF_LEN);
            }

            count = (count + 1) % 2;
        }
    }
    ```

    DMAC рддреБрдордЪреНрдпрд╛ рдХреЛрдбрд▓рд╛ рдмрдлрд░ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рдгреНрдпрд╛рд╕ рд╕рд╛рдВрдЧрдгреНрдпрд╛рд╕рд╛рдареА рдХреЙрд▓ рдХрд░реЗрд▓. рд╣реЗ рддрдкрд╛рд╕рддреЗ рдХреА рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдбреЗрдЯрд╛ рдЖрд╣реЗ рдХрд╛, рдЖрдгрд┐ рд╕рдВрдмрдВрдзрд┐рдд рдмрдлрд░рд╕рд╣ `audioCallback` рдореЗрдердб рдХреЙрд▓ рдХрд░рддреЗ.

1. рдХреНрд▓рд╛рд╕рдЪреНрдпрд╛ рдмрд╛рд╣реЗрд░, `Mic mic;` рдШреЛрд╖рдгреЗрдирдВрддрд░ рдЦрд╛рд▓реАрд▓ рдХреЛрдб рдЬреЛрдбрд╛:

    ```cpp
    void DMAC_1_Handler()
    {
        mic.dmaHandler();
    }
    ```

    `DMAC_1_Handler` DMAC рджреНрд╡рд╛рд░реЗ рдХреЙрд▓ рдХреЗрд▓рд╛ рдЬрд╛рдИрд▓ рдЬреЗрд╡реНрд╣рд╛ рдмрдлрд░ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рддрдпрд╛рд░ рдЕрд╕рддреАрд▓. рд╣реА рдлрдВрдХреНрд╢рди рдирд╛рд╡рд╛рдиреЗ рд╕рд╛рдкрдбрддреЗ, рддреНрдпрд╛рдореБрд│реЗ рдлрдХреНрдд рдЕрд╕реНрддрд┐рддреНрд╡рд╛рдд рдЕрд╕рдгреЗ рдЖрд╡рд╢реНрдпрдХ рдЖрд╣реЗ.

1. `Mic` рдХреНрд▓рд╛рд╕рдЪреНрдпрд╛ `public` рд╕реЗрдХреНрд╢рдирдордзреНрдпреЗ рдЦрд╛рд▓реАрд▓ рджреЛрди рдореЗрдердбреНрд╕ рдЬреЛрдбрд╛:

    ```cpp
    void init()
    {
        analogReference(AR_INTERNAL2V23);

        _writer.init();

        initBufferHeader();
        configureDmaAdc();
    }

    void reset()
    {
        _isRecordingReady = false;
        _isRecording = false;

        _writer.reset();

        initBufferHeader();
    }
    ```

    `init` рдореЗрдердб `Mic` рдХреНрд▓рд╛рд╕ рдЗрдирд┐рд╢рд┐рдпрд▓рд╛рдЗрдЭ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдХреЛрдб рд╕рдорд╛рд╡рд┐рд╖реНрдЯ рдХрд░рддреЗ. рд╣реЗ Mic рдкрд┐рдирд╕рд╛рдареА рдпреЛрдЧреНрдп рд╡реНрд╣реЛрд▓реНрдЯреЗрдЬ рд╕реЗрдЯ рдХрд░рддреЗ, рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рд░рд╛рдпрдЯрд░ рд╕реЗрдЯ рдХрд░рддреЗ, WAV рдлрд╛рдЗрд▓ рд╣реЗрдбрд░ рд▓рд┐рд╣рд┐рддреЗ рдЖрдгрд┐ DMAC рдХреЙрдиреНрдлрд┐рдЧрд░ рдХрд░рддреЗ. `reset` рдореЗрдердб рдлреНрд▓реЕрд╢ рдореЗрдорд░реА рд░реАрд╕реЗрдЯ рдХрд░рддреЗ рдЖрдгрд┐ рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдЖрдгрд┐ рд╡рд╛рдкрд░рд▓рд╛ рдЧреЗрд▓реНрдпрд╛рдирдВрддрд░ рд╣реЗрдбрд░ рдкреБрдиреНрд╣рд╛ рд▓рд┐рд╣рд┐рддреЗ.

### рдХрд╛рд░реНрдп - рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рд╛

1. `main.cpp` рдлрд╛рдЗрд▓рдордзреНрдпреЗ `mic.h` рд╣реЗрдбрд░ рдлрд╛рдЗрд▓рд╕рд╛рдареА `include` рдирд┐рд░реНрджреЗрд╢ рдЬреЛрдбрд╛:

    ```cpp
    #include "mic.h"
    ```

1. `setup` рдлрдВрдХреНрд╢рдирдордзреНрдпреЗ, C рдмрдЯрдг рдЗрдирд┐рд╢рд┐рдпрд▓рд╛рдЗрдЭ рдХрд░рд╛. рд╣реЗ рдмрдЯрдг рджрд╛рдмрд▓реНрдпрд╛рд╡рд░ рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рд╕реБрд░реВ рд╣реЛрдИрд▓ рдЖрдгрд┐ 4 рд╕реЗрдХрдВрдж рдЪрд╛рд▓реВ рд░рд╛рд╣реАрд▓:

    ```cpp
    pinMode(WIO_KEY_C, INPUT_PULLUP);
    ```

1. рдпрд╛рдЦрд╛рд▓реА рдорд╛рдпрдХреНрд░реЛрдлреЛрди рдЗрдирд┐рд╢рд┐рдпрд▓рд╛рдЗрдЭ рдХрд░рд╛, рдирдВрддрд░ рдХрдиреНрд╕реЛрд▓рд╡рд░ рдкреНрд░рд┐рдВрдЯ рдХрд░рд╛ рдХреА рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рддрдпрд╛рд░ рдЖрд╣реЗ:

    ```cpp
    mic.init();

    Serial.println("Ready.");
    ```

1. `loop` рдлрдВрдХреНрд╢рдирдЪреНрдпрд╛ рд╡рд░, рдХреЕрдкреНрдЪрд░ рдХреЗрд▓реЗрд▓рд╛ рдСрдбрд┐рдУ рдкреНрд░рдХреНрд░рд┐рдпрд╛ рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдПрдХ рдлрдВрдХреНрд╢рди рдбрд┐рдлрд╛рдЗрди рдХрд░рд╛. рд╕рдзреНрдпрд╛ рд╣реЗ рдХрд╛рд╣реАрд╣реА рдХрд░рдд рдирд╛рд╣реА, рдкрд░рдВрддреБ рдирдВрддрд░рдЪреНрдпрд╛ рдзрдбреНрдпрд╛рдд рд╣реЗ рднрд╛рд╖рдг рдордЬрдХреВрд░рд╛рдд рд░реВрдкрд╛рдВрддрд░рд┐рдд рдХрд░рдгреНрдпрд╛рд╕рд╛рдареА рдкрд╛рдард╡реЗрд▓:

    ```cpp
    void processAudio()
    {
    
    }
    ```

1. `loop` рдлрдВрдХреНрд╢рдирдордзреНрдпреЗ рдЦрд╛рд▓реАрд▓ рдЬреЛрдбрд╛:

    ```cpp
    void loop()
    {
        if (digitalRead(WIO_KEY_C) == LOW && !mic.isRecording())
        {
            Serial.println("Starting recording...");
            mic.startRecording();
        }
    
        if (!mic.isRecording() && mic.isRecordingReady())
        {
            Serial.println("Finished recording");
    
            processAudio();
    
            mic.reset();
        }
    }
    ```

    рд╣рд╛ рдХреЛрдб C рдмрдЯрдг рддрдкрд╛рд╕рддреЛ, рдЖрдгрд┐ рдЬрд░ рд╣реЗ рджрд╛рдмрд▓реЗ рдЧреЗрд▓реЗ рдЕрд╕реЗрд▓ рдЖрдгрд┐ рд░реЗрдХреЙрд░реНрдбрд┐рдВрдЧ рд╕реБрд░реВ рдЭрд╛рд▓реЗ рдирд╕реЗрд▓, рддрд░ `Mic` рдХреНрд▓рд╛рд╕рдЪрд╛ `_isRecording` рдлреАрд▓реНрдб `true` рд╕реЗрдЯ рдХреЗрд▓рд╛ рдЬрд╛рддреЛ. рдпрд╛рдореБрд│реЗ `Mic` рдХреНрд▓рд╛рд╕рдЪрд╛ `audioCallback` рдореЗрдердб 4 рд╕реЗрдХрдВрджрд╛рдВрдЪрд╛ рдСрдбрд┐рдУ рд╕реНрдЯреЛрдЕрд░ рдХрд░реЗрд▓. рдПрдХрджрд╛ 4 рд╕реЗрдХрдВрджрд╛рдВрдЪрд╛ рдСрдбрд┐рдУ рдХреЕрдкреНрдЪрд░ рдЭрд╛рд▓реНрдпрд╛рд╡рд░, `_isRecording` рдлреАрд▓реНрдб `false` рд╕реЗрдЯ рдХреЗрд▓рд╛ рдЬрд╛рддреЛ, рдЖрдгрд┐ `_isRecordingReady` рдлреАрд▓реНрдб `true` рд╕реЗрдЯ рдХреЗрд▓рд╛ рдЬрд╛рддреЛ. рдирдВрддрд░ `loop` рдлрдВрдХреНрд╢рдирдордзреНрдпреЗ рд╣реЗ рддрдкрд╛рд╕рд▓реЗ рдЬрд╛рддреЗ, рдЖрдгрд┐ рдЬреЗрд╡реНрд╣рд╛ `true` рдЕрд╕реЗрд▓ рддреЗрд╡реНрд╣рд╛ `processAudio` рдлрдВрдХреНрд╢рди рдХреЙрд▓ рдХреЗрд▓рд╛ рдЬрд╛рддреЛ, рдирдВрддрд░ `mic` рдХреНрд▓рд╛рд╕ рд░реАрд╕реЗрдЯ рдХреЗрд▓рд╛ рдЬрд╛рддреЛ.

1. рд╣рд╛ рдХреЛрдб рддрдпрд╛рд░ рдХрд░рд╛, Wio Terminal рд╡рд░ рдЕрдкрд▓реЛрдб рдХрд░рд╛ рдЖрдгрд┐ рд╕реАрд░рд┐рдпрд▓ рдореЙрдирд┐рдЯрд░рджреНрд╡рд╛рд░реЗ рддрдкрд╛рд╕рд╛. C
ЁЯТБ рддреБрдореНрд╣реА рд╣рд╛ рдХреЛрдб [code-record/wio-terminal](../../../../../6-consumer/lessons/1-speech-recognition/code-record/wio-terminal) рдлреЛрд▓реНрдбрд░рдордзреНрдпреЗ рд╢реЛрдзреВ рд╢рдХрддрд╛.
ЁЯША рддреБрдордЪрд╛ рдСрдбрд┐рдУ рд░реЗрдХреЙрд░реНрдбрд┐рдВрдЧ рдкреНрд░реЛрдЧреНрд░рд╛рдо рдпрд╢рд╕реНрд╡реА рдЭрд╛рд▓рд╛!

---

**рдЕрд╕реНрд╡реАрдХрд░рдг**:  
рд╣рд╛ рджрд╕реНрддрдРрд╡рдЬ AI рднрд╛рд╖рд╛рдВрддрд░ рд╕реЗрд╡рд╛ [Co-op Translator](https://github.com/Azure/co-op-translator) рдЪрд╛ рд╡рд╛рдкрд░ рдХрд░реВрди рднрд╛рд╖рд╛рдВрддрд░рд┐рдд рдХрд░рдгреНрдпрд╛рдд рдЖрд▓рд╛ рдЖрд╣реЗ. рдЖрдореНрд╣реА рдЕрдЪреВрдХрддреЗрд╕рд╛рдареА рдкреНрд░рдпрддреНрдирд╢реАрд▓ рдЕрд╕рд▓реЛ рддрд░реА рдХреГрдкрдпрд╛ рд▓рдХреНрд╖рд╛рдд рдареЗрд╡рд╛ рдХреА рд╕реНрд╡рдпрдВрдЪрд▓рд┐рдд рднрд╛рд╖рд╛рдВрддрд░реЗ рддреНрд░реБрдЯреА рдХрд┐рдВрд╡рд╛ рдЕрдЪреВрдХрддреЗрдЪреНрдпрд╛ рдЕрднрд╛рд╡рд╛рдиреЗ рдпреБрдХреНрдд рдЕрд╕реВ рд╢рдХрддрд╛рдд. рдореВрд│ рднрд╛рд╖реЗрддреАрд▓ рджрд╕реНрддрдРрд╡рдЬ рд╣рд╛ рдЕрдзрд┐рдХреГрдд рд╕реНрд░реЛрдд рдорд╛рдирд▓рд╛ рдЬрд╛рд╡рд╛. рдорд╣рддреНрддреНрд╡рд╛рдЪреНрдпрд╛ рдорд╛рд╣рд┐рддреАрд╕рд╛рдареА рд╡реНрдпрд╛рд╡рд╕рд╛рдпрд┐рдХ рдорд╛рдирд╡реА рднрд╛рд╖рд╛рдВрддрд░рд╛рдЪреА рд╢рд┐рдлрд╛рд░рд╕ рдХреЗрд▓реА рдЬрд╛рддреЗ. рдпрд╛ рднрд╛рд╖рд╛рдВрддрд░рд╛рдЪрд╛ рд╡рд╛рдкрд░ рдХрд░реВрди рдЙрджреНрднрд╡рд▓реЗрд▓реНрдпрд╛ рдХреЛрдгрддреНрдпрд╛рд╣реА рдЧреИрд░рд╕рдордЬ рдХрд┐рдВрд╡рд╛ рдЪреБрдХреАрдЪреНрдпрд╛ рдЕрд░реНрдерд╛рд╕рд╛рдареА рдЖрдореНрд╣реА рдЬрдмрд╛рдмрджрд╛рд░ рд░рд╛рд╣рдгрд╛рд░ рдирд╛рд╣реА.