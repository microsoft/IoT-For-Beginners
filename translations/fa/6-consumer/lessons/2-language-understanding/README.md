<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "6f4ba69d77f16c4a5110623a96a215c3",
  "translation_date": "2025-08-25T22:32:16+00:00",
  "source_file": "6-consumer/lessons/2-language-understanding/README.md",
  "language_code": "fa"
}
-->
# درک زبان

![نمای کلی درس به صورت اسکچ‌نوت](../../../../../translated_images/lesson-22.6148ea28500d9e00c396aaa2649935fb6641362c8f03d8e5e90a676977ab01dd.fa.jpg)

> اسکچ‌نوت توسط [نیتیا ناراسیمهان](https://github.com/nitya). برای مشاهده نسخه بزرگ‌تر روی تصویر کلیک کنید.

## آزمون پیش از درس

[آزمون پیش از درس](https://black-meadow-040d15503.1.azurestaticapps.net/quiz/43)

## مقدمه

در درس قبلی، شما گفتار را به متن تبدیل کردید. برای اینکه بتوانید از این قابلیت برای برنامه‌ریزی یک تایمر هوشمند استفاده کنید، کد شما باید بتواند آنچه گفته شده را درک کند. شما می‌توانید فرض کنید که کاربر یک عبارت ثابت مانند "یک تایمر سه دقیقه‌ای تنظیم کن" را می‌گوید و آن عبارت را تجزیه کنید تا مدت زمان تایمر مشخص شود، اما این روش خیلی کاربرپسند نیست. اگر کاربر بگوید "یک تایمر برای سه دقیقه تنظیم کن"، شما یا من متوجه منظور او می‌شویم، اما کد شما نمی‌تواند، زیرا انتظار یک عبارت ثابت را دارد.

اینجاست که درک زبان وارد عمل می‌شود، با استفاده از مدل‌های هوش مصنوعی برای تفسیر متن و استخراج جزئیات مورد نیاز، به عنوان مثال توانایی درک هر دو عبارت "یک تایمر سه دقیقه‌ای تنظیم کن" و "یک تایمر برای سه دقیقه تنظیم کن" و فهمیدن اینکه یک تایمر برای سه دقیقه مورد نیاز است.

در این درس، شما با مدل‌های درک زبان آشنا خواهید شد، یاد خواهید گرفت چگونه آن‌ها را ایجاد، آموزش و از آن‌ها در کد خود استفاده کنید.

در این درس به موارد زیر خواهیم پرداخت:

* [درک زبان](../../../../../6-consumer/lessons/2-language-understanding)
* [ایجاد یک مدل درک زبان](../../../../../6-consumer/lessons/2-language-understanding)
* [اهداف و موجودیت‌ها](../../../../../6-consumer/lessons/2-language-understanding)
* [استفاده از مدل درک زبان](../../../../../6-consumer/lessons/2-language-understanding)

## درک زبان

انسان‌ها برای صدها هزار سال از زبان برای ارتباط استفاده کرده‌اند. ما با کلمات، صداها یا حرکات ارتباط برقرار می‌کنیم و آنچه گفته شده را درک می‌کنیم، هم معنای کلمات، صداها یا حرکات و هم زمینه آن‌ها. ما صداقت و طعنه را درک می‌کنیم، به طوری که همان کلمات بسته به لحن صدا می‌توانند معانی متفاوتی داشته باشند.

✅ به برخی از مکالماتی که اخیراً داشته‌اید فکر کنید. چه مقدار از مکالمه برای یک کامپیوتر سخت خواهد بود که درک کند، زیرا نیاز به زمینه دارد؟

درک زبان، که به آن درک زبان طبیعی نیز گفته می‌شود، بخشی از حوزه هوش مصنوعی به نام پردازش زبان طبیعی (NLP) است و با درک مطلب سروکار دارد، تلاش برای فهم جزئیات کلمات یا جملات. اگر از دستیار صوتی مانند الکسا یا سیری استفاده کرده‌اید، از خدمات درک زبان استفاده کرده‌اید. این‌ها خدمات هوش مصنوعی پشت صحنه هستند که عبارت "الکسا، آخرین آلبوم تیلور سویفت را پخش کن" را به رقصیدن دخترم در اتاق نشیمن با آهنگ‌های مورد علاقه‌اش تبدیل می‌کنند.

> 💁 کامپیوترها، با وجود تمام پیشرفت‌هایشان، هنوز راه طولانی برای درک واقعی متن دارند. وقتی از درک زبان توسط کامپیوترها صحبت می‌کنیم، منظورمان چیزی به مراتب کمتر از ارتباط انسانی پیشرفته است، بلکه منظورمان استخراج جزئیات کلیدی از برخی کلمات است.

به عنوان انسان، ما بدون فکر کردن زیاد زبان را درک می‌کنیم. اگر از یک انسان دیگر بخواهم "آخرین آلبوم تیلور سویفت را پخش کن"، او به طور غریزی می‌داند منظورم چیست. برای یک کامپیوتر، این سخت‌تر است. کامپیوتر باید کلمات را که از گفتار به متن تبدیل شده‌اند، گرفته و موارد زیر را استخراج کند:

* موسیقی باید پخش شود
* موسیقی متعلق به هنرمند تیلور سویفت است
* موسیقی خاص یک آلبوم کامل شامل چندین قطعه به ترتیب است
* تیلور سویفت آلبوم‌های زیادی دارد، بنابراین باید بر اساس ترتیب زمانی مرتب شوند و جدیدترین آلبوم مورد نظر است

✅ به برخی از جملاتی که هنگام درخواست چیزی گفته‌اید فکر کنید، مانند سفارش قهوه یا درخواست از یکی از اعضای خانواده برای دادن چیزی. سعی کنید آن‌ها را به قطعات اطلاعاتی که یک کامپیوتر باید استخراج کند تا جمله را درک کند، تقسیم کنید.

مدل‌های درک زبان، مدل‌های هوش مصنوعی هستند که برای استخراج جزئیات خاص از زبان آموزش داده می‌شوند و سپس برای وظایف خاص با استفاده از یادگیری انتقالی آموزش داده می‌شوند، همانطور که شما یک مدل بینایی سفارشی را با استفاده از مجموعه کوچکی از تصاویر آموزش دادید. شما می‌توانید یک مدل را بگیرید و سپس آن را با استفاده از متنی که می‌خواهید درک شود، آموزش دهید.

## ایجاد یک مدل درک زبان

![لوگوی LUIS](../../../../../translated_images/luis-logo.5cb4f3e88c020ee6df4f614e8831f4a4b6809a7247bf52085fb48d629ef9be52.fa.png)

شما می‌توانید مدل‌های درک زبان را با استفاده از LUIS، یک سرویس درک زبان از مایکروسافت که بخشی از خدمات شناختی است، ایجاد کنید.

### وظیفه - ایجاد یک منبع نویسندگی

برای استفاده از LUIS، شما باید یک منبع نویسندگی ایجاد کنید.

1. از دستور زیر برای ایجاد یک منبع نویسندگی در گروه منابع `smart-timer` خود استفاده کنید:

    ```python
    az cognitiveservices account create --name smart-timer-luis-authoring \
                                        --resource-group smart-timer \
                                        --kind LUIS.Authoring \
                                        --sku F0 \
                                        --yes \
                                        --location <location>
    ```

    `<location>` را با مکانی که هنگام ایجاد گروه منابع استفاده کرده‌اید جایگزین کنید.

    > ⚠️ LUIS در همه مناطق در دسترس نیست، بنابراین اگر خطای زیر را دریافت کردید:
    >
    > ```output
    > InvalidApiSetId: The account type 'LUIS.Authoring' is either invalid or unavailable in given region.
    > ```
    >
    > یک منطقه دیگر را انتخاب کنید.

    این دستور یک منبع نویسندگی LUIS با سطح رایگان ایجاد خواهد کرد.

### وظیفه - ایجاد یک اپلیکیشن درک زبان

1. پورتال LUIS را در [luis.ai](https://luis.ai?WT.mc_id=academic-17441-jabenn) در مرورگر خود باز کنید و با همان حسابی که برای Azure استفاده کرده‌اید وارد شوید.

1. دستورالعمل‌های موجود در دیالوگ را دنبال کنید تا اشتراک Azure خود را انتخاب کنید، سپس منبع `smart-timer-luis-authoring` که تازه ایجاد کرده‌اید را انتخاب کنید.

1. از لیست *اپلیکیشن‌های مکالمه*، دکمه **اپلیکیشن جدید** را انتخاب کنید تا یک اپلیکیشن جدید ایجاد کنید. اپلیکیشن جدید را `smart-timer` نام‌گذاری کنید و *فرهنگ* را به زبان خود تنظیم کنید.

    > 💁 یک فیلد برای منبع پیش‌بینی وجود دارد. شما می‌توانید یک منبع دوم فقط برای پیش‌بینی ایجاد کنید، اما منبع نویسندگی رایگان اجازه ۱۰۰۰ پیش‌بینی در ماه را می‌دهد که برای توسعه کافی است، بنابراین می‌توانید این فیلد را خالی بگذارید.

1. راهنمایی که پس از ایجاد اپلیکیشن ظاهر می‌شود را بخوانید تا با مراحل لازم برای آموزش مدل درک زبان آشنا شوید. پس از اتمام، این راهنما را ببندید.

## اهداف و موجودیت‌ها

درک زبان بر اساس *اهداف* و *موجودیت‌ها* است. اهداف نشان‌دهنده قصد کلمات هستند، برای مثال پخش موسیقی، تنظیم تایمر یا سفارش غذا. موجودیت‌ها نشان‌دهنده چیزی هستند که هدف به آن اشاره دارد، مانند آلبوم، مدت زمان تایمر یا نوع غذا. هر جمله‌ای که مدل تفسیر می‌کند باید حداقل یک هدف و به صورت اختیاری یک یا چند موجودیت داشته باشد.

برخی مثال‌ها:

| جمله                                              | هدف              | موجودیت‌ها                                 |
| ------------------------------------------------- | ---------------- | ------------------------------------------ |
| "آخرین آلبوم تیلور سویفت را پخش کن"              | *پخش موسیقی*     | *آخرین آلبوم تیلور سویفت*                 |
| "یک تایمر سه دقیقه‌ای تنظیم کن"                  | *تنظیم تایمر*    | *سه دقیقه*                                 |
| "تایمر من را لغو کن"                              | *لغو تایمر*      | هیچ                                       |
| "سه پیتزای بزرگ با آناناس و یک سالاد سزار سفارش بده" | *سفارش غذا*      | *سه پیتزای بزرگ با آناناس*، *سالاد سزار* |

✅ با جملاتی که قبلاً به آن‌ها فکر کرده‌اید، هدف و موجودیت‌های آن جمله چه خواهند بود؟

برای آموزش LUIS، ابتدا موجودیت‌ها را تنظیم می‌کنید. این‌ها می‌توانند یک لیست ثابت از اصطلاحات باشند یا از متن یاد گرفته شوند. برای مثال، شما می‌توانید یک لیست ثابت از غذاهای موجود در منوی خود ارائه دهید، همراه با تغییرات (یا مترادف‌ها) هر کلمه، مانند *بادمجان* و *آبرجین* به عنوان تغییرات *آبرجین*. LUIS همچنین موجودیت‌های از پیش ساخته شده‌ای دارد که می‌توان از آن‌ها استفاده کرد، مانند اعداد و مکان‌ها.

برای تنظیم تایمر، شما می‌توانید یک موجودیت با استفاده از موجودیت‌های عددی از پیش ساخته شده برای زمان داشته باشید و دیگری برای واحدها، مانند دقیقه و ثانیه. هر واحد می‌تواند چندین تغییر داشته باشد تا فرم‌های مفرد و جمع را پوشش دهد - مانند دقیقه و دقایق.

پس از تعریف موجودیت‌ها، شما اهداف را ایجاد می‌کنید. این‌ها بر اساس جملات نمونه‌ای که ارائه می‌دهید (که به آن‌ها عبارات گفته می‌شود) توسط مدل یاد گرفته می‌شوند. برای مثال، برای هدف *تنظیم تایمر*، شما ممکن است جملات زیر را ارائه دهید:

* `یک تایمر یک ثانیه‌ای تنظیم کن`
* `یک تایمر برای یک دقیقه و دوازده ثانیه تنظیم کن`
* `یک تایمر برای سه دقیقه تنظیم کن`
* `یک تایمر نه دقیقه و سی ثانیه‌ای تنظیم کن`

سپس به LUIS می‌گویید که کدام بخش‌های این جملات به موجودیت‌ها مربوط می‌شوند:

![جمله "یک تایمر برای یک دقیقه و دوازده ثانیه تنظیم کن" به موجودیت‌ها تقسیم شده است](../../../../../translated_images/sentence-as-intent-entities.301401696f9922590a99343f5c5d211b710b906f212f0d4d034cee3ffb610272.fa.png)

جمله `یک تایمر برای یک دقیقه و دوازده ثانیه تنظیم کن` هدف `تنظیم تایمر` دارد. همچنین دارای ۲ موجودیت با ۲ مقدار هر کدام است:

|            | زمان | واحد   |
| ---------- | ---: | ------ |
| 1 دقیقه    | 1    | دقیقه  |
| 12 ثانیه   | 12   | ثانیه  |

برای آموزش یک مدل خوب، شما به مجموعه‌ای از جملات نمونه مختلف نیاز دارید تا روش‌های مختلفی که ممکن است کسی همان درخواست را بیان کند، پوشش دهید.

> 💁 همانطور که با هر مدل هوش مصنوعی، هرچه داده‌ها بیشتر و دقیق‌تر باشند، مدل بهتر خواهد بود.

✅ به روش‌های مختلفی که ممکن است همان درخواست را بیان کنید و انتظار داشته باشید یک انسان آن را درک کند، فکر کنید.

### وظیفه - افزودن موجودیت‌ها به مدل‌های درک زبان

برای تایمر، شما نیاز به افزودن ۲ موجودیت دارید - یکی برای واحد زمان (دقیقه یا ثانیه) و دیگری برای تعداد دقیقه یا ثانیه.

شما می‌توانید دستورالعمل‌های استفاده از پورتال LUIS را در [مستندات شروع سریع: ساخت اپلیکیشن خود در پورتال LUIS در مستندات مایکروسافت](https://docs.microsoft.com/azure/cognitive-services/luis/luis-get-started-create-app?WT.mc_id=academic-17441-jabenn) پیدا کنید.

1. از پورتال LUIS، تب *موجودیت‌ها* را انتخاب کنید و موجودیت از پیش ساخته شده *عدد* را با انتخاب دکمه **افزودن موجودیت از پیش ساخته شده** و سپس انتخاب *عدد* از لیست اضافه کنید.

1. یک موجودیت جدید برای واحد زمان با استفاده از دکمه **ایجاد** ایجاد کنید. نام موجودیت را `واحد زمان` بگذارید و نوع آن را به *لیست* تنظیم کنید. مقادیر `دقیقه` و `ثانیه` را به لیست *مقادیر نرمال شده* اضافه کنید و فرم‌های مفرد و جمع را به لیست *مترادف‌ها* اضافه کنید. پس از افزودن هر مترادف، کلید `بازگشت` را فشار دهید تا به لیست اضافه شود.

    | مقدار نرمال شده | مترادف‌ها        |
    | ---------------- | --------------- |
    | دقیقه            | دقیقه، دقایق    |
    | ثانیه            | ثانیه، ثانیه‌ها |

### وظیفه - افزودن اهداف به مدل‌های درک زبان

1. از تب *اهداف*، دکمه **ایجاد** را انتخاب کنید تا یک هدف جدید ایجاد کنید. نام این هدف را `تنظیم تایمر` بگذارید.

1. در مثال‌ها، روش‌های مختلفی برای تنظیم تایمر با استفاده از دقیقه، ثانیه و ترکیب دقیقه و ثانیه وارد کنید. مثال‌ها می‌توانند شامل موارد زیر باشند:

    * `یک تایمر یک ثانیه‌ای تنظیم کن`
    * `یک تایمر چهار دقیقه‌ای تنظیم کن`
    * `یک تایمر چهار دقیقه و شش ثانیه‌ای تنظیم کن`
    * `یک تایمر نه دقیقه و سی ثانیه‌ای تنظیم کن`
    * `یک تایمر برای یک دقیقه و دوازده ثانیه تنظیم کن`
    * `یک تایمر برای سه دقیقه تنظیم کن`
    * `یک تایمر برای سه دقیقه و یک ثانیه تنظیم کن`
    * `یک تایمر برای سه دقیقه و یک ثانیه تنظیم کن`
    * `یک تایمر برای یک دقیقه و یک ثانیه تنظیم کن`
    * `یک تایمر برای سی ثانیه تنظیم کن`
    * `یک تایمر برای یک ثانیه تنظیم کن`

    اعداد را به صورت کلمات و عددی ترکیب کنید تا مدل یاد بگیرد هر دو را مدیریت کند.

1. همانطور که هر مثال را وارد می‌کنید، LUIS شروع به شناسایی موجودیت‌ها می‌کند و هر موجودیتی که پیدا کند را زیرخط و برچسب‌گذاری می‌کند.

    ![مثال‌ها با اعداد و واحدهای زمانی که توسط LUIS زیرخط شده‌اند](../../../../../translated_images/luis-intent-examples.25716580b2d2723cf1bafdf277d015c7f046d8cfa20f27bddf3a0873ec45fab7.fa.png)

### وظیفه - آموزش و آزمایش مدل

1. پس از پیکربندی موجودیت‌ها و اهداف، می‌توانید مدل را با استفاده از دکمه **آموزش** در منوی بالا آموزش دهید. این دکمه را انتخاب کنید و مدل باید در چند ثانیه آموزش داده شود. دکمه در حین آموزش خاکستری خواهد شد و پس از اتمام دوباره فعال خواهد شد.

1. دکمه **آزمایش** را از منوی بالا انتخاب کنید تا مدل درک زبان را آزمایش کنید. متنی مانند `یک تایمر برای پنج دقیقه و چهار ثانیه تنظیم کن` وارد کنید و کلید بازگشت را فشار دهید. جمله در یک جعبه زیر جعبه متنی که آن را وارد کرده‌اید ظاهر خواهد شد و زیر آن *هدف برتر* یا هدفی که با بالاترین احتمال شناسایی شده است نمایش داده خواهد شد. این باید `تنظیم تایمر` باشد. نام هدف با احتمال اینکه هدف شناسایی شده درست باشد دنبال خواهد شد.

1. گزینه **بازبینی** را انتخاب کنید تا تجزیه و تحلیل نتایج را مشاهده کنید. شما هدف با بالاترین امتیاز و درصد احتمال آن را خواهید دید، همراه با لیست موجودیت‌های شناسایی شده.

1. پنل *آزمایش* را پس از اتمام آزمایش ببندید.

### وظیفه - انتشار مدل

برای استفاده از این مدل از کد، باید آن را منتشر کنید. هنگام انتشار از LUIS، می‌توانید به یک محیط آزمایشی برای تست یا یک محیط تولید برای انتشار کامل منتشر کنید. در این درس، محیط آزمایشی کافی است.

1. از پورتال LUIS، دکمه **انتشار** را از منوی بالا انتخاب کنید.

1. مطمئن شوید که *محیط آزمایشی* انتخاب شده است، سپس **تمام شد** را انتخاب کنید. شما یک اعلان خواهید دید که اپلیکیشن منتشر شده است.

1. می‌توانید این را با استفاده از curl آزمایش کنید. برای ساخت دستور curl، شما به سه مقدار نیاز دارید - نقطه پایانی، شناسه اپلیکیشن (App ID) و یک کلید API. این‌ها را می‌توانید از تب **مدیریت** که از منوی بالا قابل انتخاب است، دسترسی پیدا کنید.

    1. از بخش *تنظیمات*، شناسه اپلیکیشن را کپی کنید.
1. از بخش *Azure Resources*، گزینه *Authoring Resource* را انتخاب کنید و *Primary Key* و *Endpoint URL* را کپی کنید.

1. دستور curl زیر را در خط فرمان یا ترمینال خود اجرا کنید:

    ```sh
    curl "<endpoint url>/luis/prediction/v3.0/apps/<app id>/slots/staging/predict" \
          --request GET \
          --get \
          --data "subscription-key=<primary key>" \
          --data "verbose=false" \
          --data "show-all-intents=true" \
          --data-urlencode "query=<sentence>"
    ```

    مقدار `<endpoint url>` را با Endpoint URL از بخش *Azure Resources* جایگزین کنید.

    مقدار `<app id>` را با App ID از بخش *Settings* جایگزین کنید.

    مقدار `<primary key>` را با Primary Key از بخش *Azure Resources* جایگزین کنید.

    مقدار `<sentence>` را با جمله‌ای که می‌خواهید آزمایش کنید جایگزین کنید.

1. خروجی این فراخوانی یک سند JSON خواهد بود که جزئیات پرس‌وجو، هدف اصلی (intent) و لیستی از موجودیت‌ها (entities) را بر اساس نوع آن‌ها نشان می‌دهد.

    ```JSON
    {
        "query": "set a timer for 45 minutes and 12 seconds",
        "prediction": {
            "topIntent": "set timer",
            "intents": {
                "set timer": {
                    "score": 0.97031575
                },
                "None": {
                    "score": 0.02205793
                }
            },
            "entities": {
                "number": [
                    45,
                    12
                ],
                "time-unit": [
                    [
                        "minute"
                    ],
                    [
                        "second"
                    ]
                ]
            }
        }
    }
    ```

    JSON بالا از پرس‌وجوی `set a timer for 45 minutes and 12 seconds` به دست آمده است:

    * `set timer` به عنوان هدف اصلی با احتمال ۹۷٪ شناسایی شده است.
    * دو موجودیت *number* شناسایی شده‌اند: `45` و `12`.
    * دو موجودیت *time-unit* شناسایی شده‌اند: `minute` و `second`.

## استفاده از مدل درک زبان

پس از انتشار، مدل LUIS را می‌توان از طریق کد فراخوانی کرد. در درس‌های قبلی، از IoT Hub برای مدیریت ارتباط با سرویس‌های ابری، ارسال داده‌های تله‌متری و گوش دادن به دستورات استفاده کرده‌اید. این فرآیند بسیار غیرهمزمان است - وقتی داده‌های تله‌متری ارسال می‌شوند، کد شما منتظر پاسخ نمی‌ماند و اگر سرویس ابری غیرفعال باشد، متوجه نخواهید شد.

برای یک تایمر هوشمند، ما به پاسخ فوری نیاز داریم تا بتوانیم به کاربر اطلاع دهیم که تایمر تنظیم شده است یا به او هشدار دهیم که سرویس‌های ابری در دسترس نیستند. برای این کار، دستگاه IoT ما به جای تکیه بر IoT Hub، مستقیماً یک وب endpoint را فراخوانی خواهد کرد.

به جای فراخوانی مستقیم LUIS از دستگاه IoT، می‌توانید از کد بدون سرور (serverless) با یک نوع تریگر متفاوت - یک تریگر HTTP - استفاده کنید. این امکان را به برنامه تابع شما می‌دهد که به درخواست‌های REST گوش دهد و به آن‌ها پاسخ دهد. این تابع به عنوان یک endpoint REST عمل خواهد کرد که دستگاه شما می‌تواند آن را فراخوانی کند.

> 💁 اگرچه می‌توانید LUIS را مستقیماً از دستگاه IoT خود فراخوانی کنید، بهتر است از چیزی مانند کد بدون سرور استفاده کنید. به این ترتیب، وقتی بخواهید برنامه LUIS که فراخوانی می‌کنید را تغییر دهید - مثلاً وقتی یک مدل بهتر آموزش می‌دهید یا مدلی را به زبان دیگری آموزش می‌دهید - فقط لازم است کد ابری خود را به‌روزرسانی کنید و نیازی به استقرار مجدد کد در هزاران یا میلیون‌ها دستگاه IoT نخواهید داشت.

### وظیفه - ایجاد یک برنامه توابع بدون سرور

1. یک برنامه توابع Azure به نام `smart-timer-trigger` ایجاد کنید و آن را در VS Code باز کنید.

1. یک تریگر HTTP به این برنامه اضافه کنید به نام `speech-trigger` با استفاده از دستور زیر در ترمینال VS Code:

    ```sh
    func new --name text-to-timer --template "HTTP trigger"
    ```

    این دستور یک تریگر HTTP به نام `text-to-timer` ایجاد می‌کند.

1. تریگر HTTP را با اجرای برنامه توابع آزمایش کنید. وقتی اجرا می‌شود، endpoint در خروجی نمایش داده می‌شود:

    ```output
    Functions:
    
            text-to-timer: [GET,POST] http://localhost:7071/api/text-to-timer
    ```

    این را با بارگذاری URL [http://localhost:7071/api/text-to-timer](http://localhost:7071/api/text-to-timer) در مرورگر خود آزمایش کنید.

    ```output
    This HTTP triggered function executed successfully. Pass a name in the query string or in the request body for a personalized response.
    ```

### وظیفه - استفاده از مدل درک زبان

1. SDK برای LUIS از طریق یک بسته Pip در دسترس است. خط زیر را به فایل `requirements.txt` اضافه کنید تا وابستگی به این بسته اضافه شود:

    ```sh
    azure-cognitiveservices-language-luis
    ```

1. مطمئن شوید که ترمینال VS Code محیط مجازی را فعال کرده است و دستور زیر را برای نصب بسته‌های Pip اجرا کنید:

    ```sh
    pip install -r requirements.txt
    ```

    > 💁 اگر با خطا مواجه شدید، ممکن است نیاز به به‌روزرسانی pip با دستور زیر داشته باشید:
    >
    > ```sh
    > pip install --upgrade pip
    > ```

1. ورودی‌های جدیدی به فایل `local.settings.json` برای کلید API LUIS، Endpoint URL و App ID از تب **MANAGE** در پورتال LUIS اضافه کنید:

    ```JSON
    "LUIS_KEY": "<primary key>",
    "LUIS_ENDPOINT_URL": "<endpoint url>",
    "LUIS_APP_ID": "<app id>"
    ```

    مقدار `<endpoint url>` را با Endpoint URL از بخش *Azure Resources* در تب **MANAGE** جایگزین کنید. این مقدار به صورت `https://<location>.api.cognitive.microsoft.com/` خواهد بود.

    مقدار `<app id>` را با App ID از بخش *Settings* در تب **MANAGE** جایگزین کنید.

    مقدار `<primary key>` را با Primary Key از بخش *Azure Resources* در تب **MANAGE** جایگزین کنید.

1. واردات زیر را به فایل `__init__.py` اضافه کنید:

    ```python
    import json
    import os
    from azure.cognitiveservices.language.luis.runtime import LUISRuntimeClient
    from msrest.authentication import CognitiveServicesCredentials
    ```

    این کد برخی از کتابخانه‌های سیستمی و همچنین کتابخانه‌های مورد نیاز برای تعامل با LUIS را وارد می‌کند.

1. محتوای متد `main` را حذف کنید و کد زیر را اضافه کنید:

    ```python
    luis_key = os.environ['LUIS_KEY']
    endpoint_url = os.environ['LUIS_ENDPOINT_URL']
    app_id = os.environ['LUIS_APP_ID']
    
    credentials = CognitiveServicesCredentials(luis_key)
    client = LUISRuntimeClient(endpoint=endpoint_url, credentials=credentials)
    ```

    این کد مقادیر اضافه‌شده به فایل `local.settings.json` برای برنامه LUIS شما را بارگذاری می‌کند، یک شیء اعتبارسنجی با کلید API شما ایجاد می‌کند و سپس یک شیء مشتری LUIS برای تعامل با برنامه LUIS شما ایجاد می‌کند.

1. این تریگر HTTP با ارسال متن برای درک به صورت JSON فراخوانی خواهد شد، که متن در یک ویژگی به نام `text` قرار دارد. کد زیر مقدار را از بدنه درخواست HTTP استخراج کرده و آن را در کنسول ثبت می‌کند. این کد را به تابع `main` اضافه کنید:

    ```python
    req_body = req.get_json()
    text = req_body['text']
    logging.info(f'Request - {text}')
    ```

1. پیش‌بینی‌ها از LUIS با ارسال یک درخواست پیش‌بینی - یک سند JSON حاوی متن برای پیش‌بینی - درخواست می‌شوند. این درخواست را با کد زیر ایجاد کنید:

    ```python
    prediction_request = { 'query' : text }
    ```

1. این درخواست سپس می‌تواند به LUIS ارسال شود، با استفاده از اسلات staging که برنامه شما به آن منتشر شده است:

    ```python
    prediction_response = client.prediction.get_slot_prediction(app_id, 'Staging', prediction_request)
    ```

1. پاسخ پیش‌بینی شامل هدف اصلی - هدفی با بالاترین امتیاز پیش‌بینی - همراه با موجودیت‌ها است. اگر هدف اصلی `set timer` باشد، موجودیت‌ها می‌توانند برای دریافت زمان مورد نیاز برای تایمر خوانده شوند:

    ```python
    if prediction_response.prediction.top_intent == 'set timer':
        numbers = prediction_response.prediction.entities['number']
        time_units = prediction_response.prediction.entities['time unit']
        total_seconds = 0
    ```

    موجودیت‌های `number` یک آرایه از اعداد خواهند بود. برای مثال، اگر بگویید *"Set a four minute 17 second timer."*، آرایه `number` شامل ۲ عدد صحیح خواهد بود - ۴ و ۱۷.

    موجودیت‌های `time unit` یک آرایه از آرایه‌های رشته‌ها خواهند بود، که هر واحد زمانی به صورت یک آرایه از رشته‌ها در داخل آرایه قرار دارد. برای مثال، اگر بگویید *"Set a four minute 17 second timer."*، آرایه `time unit` شامل ۲ آرایه با مقادیر تکی خواهد بود - `['minute']` و `['second']`.

    نسخه JSON این موجودیت‌ها برای *"Set a four minute 17 second timer."* به صورت زیر است:

    ```json
    {
        "number": [4, 17],
        "time unit": [
            ["minute"],
            ["second"]
        ]
    }
    ```

    این کد همچنین یک شمارنده برای زمان کل تایمر به ثانیه تعریف می‌کند. این مقدار با مقادیر موجودیت‌ها پر خواهد شد.

1. موجودیت‌ها به هم مرتبط نیستند، اما می‌توانیم برخی فرضیات درباره آن‌ها داشته باشیم. آن‌ها به ترتیب گفته شده خواهند بود، بنابراین موقعیت در آرایه می‌تواند برای تعیین اینکه کدام عدد با کدام واحد زمانی مطابقت دارد استفاده شود. برای مثال:

    * *"Set a 30 second timer"* - این مورد یک عدد `30` و یک واحد زمانی `second` خواهد داشت، بنابراین عدد تکی با واحد زمانی تکی مطابقت خواهد داشت.
    * *"Set a 2 minute and 30 second timer"* - این مورد دو عدد `2` و `30` و دو واحد زمانی `minute` و `second` خواهد داشت، بنابراین عدد اول برای واحد زمانی اول (۲ دقیقه) و عدد دوم برای واحد زمانی دوم (۳۰ ثانیه) خواهد بود.

    کد زیر تعداد آیتم‌های موجود در موجودیت‌های عددی را دریافت می‌کند و از آن برای استخراج آیتم اول از هر آرایه، سپس آیتم دوم و به همین ترتیب استفاده می‌کند. این کد را داخل بلوک `if` اضافه کنید.

    ```python
    for i in range(0, len(numbers)):
        number = numbers[i]
        time_unit = time_units[i][0]
    ```

    برای *"Set a four minute 17 second timer."*، این کد دو بار حلقه می‌زند و مقادیر زیر را می‌دهد:

    | شمارش حلقه | `number` | `time_unit` |
    | ---------: | -------: | ----------- |
    | 0          | 4        | minute      |
    | 1          | 17       | second      |

1. داخل این حلقه، از عدد و واحد زمانی برای محاسبه زمان کل تایمر استفاده کنید، با افزودن ۶۰ ثانیه برای هر دقیقه و تعداد ثانیه‌ها برای هر ثانیه.

    ```python
    if time_unit == 'minute':
        total_seconds += number * 60
    else:
        total_seconds += number
    ```

1. خارج از این حلقه از میان موجودیت‌ها، زمان کل تایمر را در کنسول ثبت کنید:

    ```python
    logging.info(f'Timer required for {total_seconds} seconds')
    ```

1. تعداد ثانیه‌ها باید به عنوان یک پاسخ HTTP از تابع بازگردانده شود. در انتهای بلوک `if`، کد زیر را اضافه کنید:

    ```python
    payload = {
        'seconds': total_seconds
    }
    return func.HttpResponse(json.dumps(payload), status_code=200)
    ```

    این کد یک payload حاوی تعداد کل ثانیه‌ها برای تایمر ایجاد می‌کند، آن را به یک رشته JSON تبدیل می‌کند و به عنوان یک نتیجه HTTP با کد وضعیت ۲۰۰ بازمی‌گرداند، که به معنای موفقیت‌آمیز بودن فراخوانی است.

1. در نهایت، خارج از بلوک `if`، اگر هدف شناسایی نشد، با بازگرداندن یک کد خطا آن را مدیریت کنید:

    ```python
    return func.HttpResponse(status_code=404)
    ```

    کد وضعیت ۴۰۴ به معنای *یافت نشد* است.

1. برنامه تابع را اجرا کنید و آن را با استفاده از curl آزمایش کنید.

    ```sh
    curl --request POST 'http://localhost:7071/api/text-to-timer' \
         --header 'Content-Type: application/json' \
         --include \
         --data '{"text":"<text>"}'
    ```

    مقدار `<text>` را با متن درخواست خود جایگزین کنید، برای مثال `set a 2 minutes 27 second timer`.

    خروجی زیر را از برنامه توابع مشاهده خواهید کرد:

    ```output
    Functions:

            text-to-timer: [GET,POST] http://localhost:7071/api/text-to-timer
    
    For detailed output, run func with --verbose flag.
    [2021-06-26T19:45:14.502Z] Worker process started and initialized.
    [2021-06-26T19:45:19.338Z] Host lock lease acquired by instance ID '000000000000000000000000951CAE4E'.
    [2021-06-26T19:45:52.059Z] Executing 'Functions.text-to-timer' (Reason='This function was programmatically called via the host APIs.', Id=f68bfb90-30e4-47a5-99da-126b66218e81)
    [2021-06-26T19:45:53.577Z] Timer required for 147 seconds
    [2021-06-26T19:45:53.746Z] Executed 'Functions.text-to-timer' (Succeeded, Id=f68bfb90-30e4-47a5-99da-126b66218e81, Duration=1750ms)
    ```

    فراخوانی curl خروجی زیر را بازمی‌گرداند:

    ```output
    HTTP/1.1 200 OK
    Date: Tue, 29 Jun 2021 01:14:11 GMT
    Content-Type: text/plain; charset=utf-8
    Server: Kestrel
    Transfer-Encoding: chunked
    
    {"seconds": 147}
    ```

    تعداد ثانیه‌های تایمر در مقدار `"seconds"` قرار دارد.

> 💁 می‌توانید این کد را در پوشه [code/functions](../../../../../6-consumer/lessons/2-language-understanding/code/functions) پیدا کنید.

### وظیفه - در دسترس قرار دادن تابع برای دستگاه IoT شما

1. برای اینکه دستگاه IoT شما بتواند endpoint REST شما را فراخوانی کند، باید URL را بداند. وقتی قبلاً به آن دسترسی پیدا کردید، از `localhost` استفاده کردید، که یک میانبر برای دسترسی به endpoint‌های REST روی ماشین محلی شما است. برای اینکه دستگاه IoT شما بتواند به آن دسترسی پیدا کند، باید یا آن را در ابر منتشر کنید یا آدرس IP خود را برای دسترسی محلی دریافت کنید.

    > ⚠️ اگر از Wio Terminal استفاده می‌کنید، اجرای برنامه تابع به صورت محلی آسان‌تر است، زیرا وابستگی به کتابخانه‌هایی وجود دارد که باعث می‌شود نتوانید برنامه تابع را به همان روشی که قبلاً انجام داده‌اید مستقر کنید. برنامه تابع را به صورت محلی اجرا کنید و از طریق آدرس IP کامپیوتر خود به آن دسترسی پیدا کنید. اگر می‌خواهید آن را در ابر مستقر کنید، اطلاعاتی در درس‌های بعدی در مورد نحوه انجام این کار ارائه خواهد شد.

    * برنامه توابع را منتشر کنید - دستورالعمل‌های درس‌های قبلی را برای انتشار برنامه توابع خود در ابر دنبال کنید. پس از انتشار، URL به صورت `https://<APP_NAME>.azurewebsites.net/api/text-to-timer` خواهد بود، که `<APP_NAME>` نام برنامه توابع شما خواهد بود. مطمئن شوید که تنظیمات محلی خود را نیز منتشر کنید.

      هنگام کار با تریگرهای HTTP، آن‌ها به طور پیش‌فرض با یک کلید برنامه تابع ایمن می‌شوند. برای دریافت این کلید، دستور زیر را اجرا کنید:

      ```sh
      az functionapp keys list --resource-group smart-timer \
                               --name <APP_NAME>                               
      ```

      مقدار ورودی `default` را از بخش `functionKeys` کپی کنید.

      ```output
      {
        "functionKeys": {
          "default": "sQO1LQaeK9N1qYD6SXeb/TctCmwQEkToLJU6Dw8TthNeUH8VA45hlA=="
        },
        "masterKey": "RSKOAIlyvvQEQt9dfpabJT018scaLpQu9p1poHIMCxx5LYrIQZyQ/g==",
        "systemKeys": {}
      }
      ```

      این کلید باید به عنوان یک پارامتر پرس‌وجو به URL اضافه شود، بنابراین URL نهایی به صورت `https://<APP_NAME>.azurewebsites.net/api/text-to-timer?code=<FUNCTION_KEY>` خواهد بود، که `<APP_NAME>` نام برنامه توابع شما و `<FUNCTION_KEY>` کلید پیش‌فرض تابع شما خواهد بود.

      > 💁 می‌توانید نوع مجوز تریگر HTTP را با استفاده از تنظیم `authlevel` در فایل `function.json` تغییر دهید. می‌توانید اطلاعات بیشتری در مورد این موضوع در [بخش پیکربندی مستندات تریگر HTTP توابع Azure در Microsoft Docs](https://docs.microsoft.com/azure/azure-functions/functions-bindings-http-webhook-trigger?WT.mc_id=academic-17441-jabenn&tabs=python#configuration) بخوانید.

    * برنامه توابع را به صورت محلی اجرا کنید و با استفاده از آدرس IP به آن دسترسی پیدا کنید - می‌توانید آدرس IP کامپیوتر خود را در شبکه محلی پیدا کنید و از آن برای ساخت URL استفاده کنید.

      آدرس IP خود را پیدا کنید:

      * در ویندوز ۱۰، راهنمای [پیدا کردن آدرس IP خود](https://support.microsoft.com/windows/find-your-ip-address-f21a9bbc-c582-55cd-35e0-73431160a1b9?WT.mc_id=academic-17441-jabenn) را دنبال کنید.
      * در macOS، راهنمای [چگونه آدرس IP خود را در مک پیدا کنیم](https://www.hellotech.com/guide/for/how-to-find-ip-address-on-mac) را دنبال کنید.
      * در لینوکس، بخش پیدا کردن آدرس IP خصوصی در [چگونه آدرس IP خود را در لینوکس پیدا کنیم](https://opensource.com/article/18/5/how-find-ip-address-linux) را دنبال کنید.

      پس از دریافت آدرس IP، می‌توانید به تابع در `http://` دسترسی پیدا کنید.
<آدرس_آی‌پی>
:7071/api/text-to-timer`، که `<IP_ADDRESS>` آدرس IP شما خواهد بود، برای مثال `http://192.168.1.10:7071/api/text-to-timer`.

      > 💁 توجه داشته باشید که این از پورت 7071 استفاده می‌کند، بنابراین بعد از آدرس IP باید `:7071` را اضافه کنید.

      > 💁 این فقط زمانی کار می‌کند که دستگاه IoT شما در همان شبکه‌ای باشد که کامپیوتر شما قرار دارد.

1. نقطه پایانی را با استفاده از curl آزمایش کنید.

---

## 🚀 چالش

راه‌های زیادی برای درخواست یک چیز مشابه، مانند تنظیم یک تایمر، وجود دارد. به روش‌های مختلف برای انجام این کار فکر کنید و از آنها به عنوان مثال در برنامه LUIS خود استفاده کنید. این روش‌ها را آزمایش کنید تا ببینید مدل شما چقدر می‌تواند با روش‌های مختلف درخواست تایمر سازگار شود.

## آزمون پس از درس

[آزمون پس از درس](https://black-meadow-040d15503.1.azurestaticapps.net/quiz/44)

## مرور و مطالعه شخصی

* درباره LUIS و قابلیت‌های آن بیشتر بخوانید در [صفحه مستندات Language Understanding (LUIS) در Microsoft docs](https://docs.microsoft.com/azure/cognitive-services/luis/?WT.mc_id=academic-17441-jabenn)
* درباره درک زبان بیشتر بخوانید در [صفحه درک زبان طبیعی در ویکی‌پدیا](https://wikipedia.org/wiki/Natural-language_understanding)
* درباره محرک‌های HTTP بیشتر بخوانید در [مستندات محرک HTTP در Azure Functions در Microsoft docs](https://docs.microsoft.com/azure/azure-functions/functions-bindings-http-webhook-trigger?WT.mc_id=academic-17441-jabenn&tabs=python)

## تکلیف

[لغو تایمر](assignment.md)

**سلب مسئولیت**:  
این سند با استفاده از سرویس ترجمه هوش مصنوعی [Co-op Translator](https://github.com/Azure/co-op-translator) ترجمه شده است. در حالی که ما تلاش می‌کنیم دقت را حفظ کنیم، لطفاً توجه داشته باشید که ترجمه‌های خودکار ممکن است شامل خطاها یا نادرستی‌ها باشند. سند اصلی به زبان اصلی آن باید به عنوان منبع معتبر در نظر گرفته شود. برای اطلاعات حساس، توصیه می‌شود از ترجمه حرفه‌ای انسانی استفاده کنید. ما مسئولیتی در قبال سوء تفاهم‌ها یا تفسیرهای نادرست ناشی از استفاده از این ترجمه نداریم.