<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "28320305a35ea3bc59c41fe146a2e6ed",
  "translation_date": "2025-08-28T04:08:30+00:00",
  "source_file": "2-farm/lessons/4-migrate-your-plant-to-the-cloud/wio-terminal-connect-hub.md",
  "language_code": "br"
}
-->
# Conecte seu dispositivo IoT √† nuvem - Wio Terminal

Nesta parte da li√ß√£o, voc√™ conectar√° seu Wio Terminal ao seu IoT Hub para enviar telemetria e receber comandos.

## Conecte seu dispositivo ao IoT Hub

O pr√≥ximo passo √© conectar seu dispositivo ao IoT Hub.

### Tarefa - conectar ao IoT Hub

1. Abra o projeto `soil-moisture-sensor` no VS Code.

1. Abra o arquivo `platformio.ini`. Remova a depend√™ncia da biblioteca `knolleary/PubSubClient`. Esta biblioteca era usada para conectar ao broker MQTT p√∫blico e n√£o √© necess√°ria para conectar ao IoT Hub.

1. Adicione as seguintes depend√™ncias de biblioteca:

    ```ini
    seeed-studio/Seeed Arduino RTC @ 2.0.0
    arduino-libraries/AzureIoTHub @ 1.6.0
    azure/AzureIoTUtility @ 1.6.1
    azure/AzureIoTProtocol_MQTT @ 1.6.0
    azure/AzureIoTProtocol_HTTP @ 1.6.0
    azure/AzureIoTSocket_WiFi @ 1.0.2
    ```

    A biblioteca `Seeed Arduino RTC` fornece c√≥digo para interagir com um rel√≥gio de tempo real no Wio Terminal, usado para rastrear o tempo. As bibliotecas restantes permitem que seu dispositivo IoT se conecte ao IoT Hub.

1. Adicione o seguinte ao final do arquivo `platformio.ini`:

    ```ini
    build_flags =
        -DDONT_USE_UPLOADTOBLOB
    ```

    Isso define uma flag de compilador necess√°ria ao compilar o c√≥digo do Arduino IoT Hub.

1. Abra o arquivo de cabe√ßalho `config.h`. Remova todas as configura√ß√µes de MQTT e adicione a seguinte constante para a string de conex√£o do dispositivo:

    ```cpp
    // IoT Hub settings
    const char *CONNECTION_STRING = "<connection string>";
    ```

    Substitua `<connection string>` pela string de conex√£o do seu dispositivo que voc√™ copiou anteriormente.

1. A conex√£o ao IoT Hub utiliza um token baseado em tempo. Isso significa que o dispositivo IoT precisa saber o hor√°rio atual. Diferentemente de sistemas operacionais como Windows, macOS ou Linux, microcontroladores n√£o sincronizam automaticamente o hor√°rio atual pela Internet. Isso significa que voc√™ precisar√° adicionar c√≥digo para obter o hor√°rio atual de um servidor [NTP](https://wikipedia.org/wiki/Network_Time_Protocol). Depois que o hor√°rio for obtido, ele pode ser armazenado em um rel√≥gio de tempo real no Wio Terminal, permitindo que o hor√°rio correto seja solicitado posteriormente, assumindo que o dispositivo n√£o perca energia. Adicione um novo arquivo chamado `ntp.h` com o seguinte c√≥digo:

    ```cpp
    #pragma once
    
    #include "DateTime.h"
    #include <time.h>
    #include "samd/NTPClientAz.h"
    #include <sys/time.h>

    static void initTime()
    {
        WiFiUDP _udp;
        time_t epochTime = (time_t)-1;
        NTPClientAz ntpClient;

        ntpClient.begin();

        while (true)
        {
            epochTime = ntpClient.getEpochTime("0.pool.ntp.org");

            if (epochTime == (time_t)-1)
            {
                Serial.println("Fetching NTP epoch time failed! Waiting 2 seconds to retry.");
                delay(2000);
            }
            else
            {
                Serial.print("Fetched NTP epoch time is: ");

                char buff[32];
                sprintf(buff, "%.f", difftime(epochTime, (time_t)0));
                Serial.println(buff);
                break;
            }
        }

        ntpClient.end();

        struct timeval tv;
        tv.tv_sec = epochTime;
        tv.tv_usec = 0;

        settimeofday(&tv, NULL);
    }
    ```

    Os detalhes deste c√≥digo est√£o fora do escopo desta li√ß√£o. Ele define uma fun√ß√£o chamada `initTime` que obt√©m o hor√°rio atual de um servidor NTP e o utiliza para configurar o rel√≥gio no Wio Terminal.

1. Abra o arquivo `main.cpp` e remova todo o c√≥digo MQTT, incluindo o arquivo de cabe√ßalho `PubSubClient.h`, a declara√ß√£o da vari√°vel `PubSubClient`, os m√©todos `reconnectMQTTClient` e `createMQTTClient`, e quaisquer chamadas para essas vari√°veis e m√©todos. Este arquivo deve conter apenas c√≥digo para conectar ao WiFi, obter a umidade do solo e criar um documento JSON com esses dados.

1. Adicione as seguintes diretivas `#include` ao topo do arquivo `main.cpp` para incluir os arquivos de cabe√ßalho das bibliotecas do IoT Hub e para configurar o hor√°rio:

    ```cpp
    #include <AzureIoTHub.h>
    #include <AzureIoTProtocol_MQTT.h>
    #include <iothubtransportmqtt.h>
    #include "ntp.h"
    ```

1. Adicione a seguinte chamada ao final da fun√ß√£o `setup` para configurar o hor√°rio atual:

    ```cpp
    initTime();
    ```

1. Adicione a seguinte declara√ß√£o de vari√°vel ao topo do arquivo, logo abaixo das diretivas de inclus√£o:

    ```cpp
    IOTHUB_DEVICE_CLIENT_LL_HANDLE _device_ll_handle;
    ```

    Isso declara um `IOTHUB_DEVICE_CLIENT_LL_HANDLE`, um identificador para uma conex√£o com o IoT Hub.

1. Abaixo disso, adicione o seguinte c√≥digo:

    ```cpp
    static void connectionStatusCallback(IOTHUB_CLIENT_CONNECTION_STATUS result, IOTHUB_CLIENT_CONNECTION_STATUS_REASON reason, void *user_context)
    {
        if (result == IOTHUB_CLIENT_CONNECTION_AUTHENTICATED)
        {
            Serial.println("The device client is connected to iothub");
        }
        else
        {
            Serial.println("The device client has been disconnected");
        }
    }
    ```

    Isso declara uma fun√ß√£o de callback que ser√° chamada quando a conex√£o com o IoT Hub mudar de status, como conectar ou desconectar. O status √© enviado para a porta serial.

1. Abaixo disso, adicione uma fun√ß√£o para conectar ao IoT Hub:

    ```cpp
    void connectIoTHub()
    {
        IoTHub_Init();
    
        _device_ll_handle = IoTHubDeviceClient_LL_CreateFromConnectionString(CONNECTION_STRING, MQTT_Protocol);
        
        if (_device_ll_handle == NULL)
        {
            Serial.println("Failure creating Iothub device. Hint: Check your connection string.");
            return;
        }
    
        IoTHubDeviceClient_LL_SetConnectionStatusCallback(_device_ll_handle, connectionStatusCallback, NULL);
    }
    ```

    Este c√≥digo inicializa o c√≥digo da biblioteca do IoT Hub e, em seguida, cria uma conex√£o usando a string de conex√£o no arquivo de cabe√ßalho `config.h`. Esta conex√£o √© baseada em MQTT. Se a conex√£o falhar, isso ser√° enviado para a porta serial - se voc√™ vir isso na sa√≠da, verifique a string de conex√£o. Por fim, o callback de status da conex√£o √© configurado.

1. Chame esta fun√ß√£o na fun√ß√£o `setup` abaixo da chamada para `initTime`:

    ```cpp
    connectIoTHub();
    ```

1. Assim como no cliente MQTT, este c√≥digo √© executado em uma √∫nica thread, ent√£o precisa de tempo para processar mensagens enviadas pelo hub e para o hub. Adicione o seguinte ao topo da fun√ß√£o `loop` para fazer isso:

    ```cpp
    IoTHubDeviceClient_LL_DoWork(_device_ll_handle);
    ```

1. Compile e carregue este c√≥digo. Voc√™ ver√° a conex√£o no monitor serial:

    ```output
    Connecting to WiFi..
    Connected!
    Fetched NTP epoch time is: 1619983687
    Sending telemetry {"soil_moisture":391}
    The device client is connected to iothub
    ```

    Na sa√≠da, voc√™ pode ver o hor√°rio NTP sendo obtido, seguido pelo cliente do dispositivo conectando. Pode levar alguns segundos para conectar, ent√£o voc√™ pode ver a umidade do solo na sa√≠da enquanto o dispositivo est√° conectando.

    > üíÅ Voc√™ pode converter o hor√°rio UNIX do NTP para uma vers√£o mais leg√≠vel usando um site como [unixtimestamp.com](https://www.unixtimestamp.com)

## Enviar telemetria

Agora que seu dispositivo est√° conectado, voc√™ pode enviar telemetria para o IoT Hub em vez do broker MQTT.

### Tarefa - enviar telemetria

1. Adicione a seguinte fun√ß√£o acima da fun√ß√£o `setup`:

    ```cpp
    void sendTelemetry(const char *telemetry)
    {
        IOTHUB_MESSAGE_HANDLE message_handle = IoTHubMessage_CreateFromString(telemetry);
        IoTHubDeviceClient_LL_SendEventAsync(_device_ll_handle, message_handle, NULL, NULL);
        IoTHubMessage_Destroy(message_handle);
    }
    ```

    Este c√≥digo cria uma mensagem do IoT Hub a partir de uma string passada como par√¢metro, envia-a para o hub e, em seguida, limpa o objeto da mensagem.

1. Chame este c√≥digo na fun√ß√£o `loop`, logo ap√≥s a linha onde a telemetria √© enviada para a porta serial:

    ```cpp
    sendTelemetry(telemetry.c_str());
    ```

## Manipular comandos

Seu dispositivo precisa manipular um comando do c√≥digo do servidor para controlar o rel√©. Isso √© enviado como uma solicita√ß√£o de m√©todo direto.

## Tarefa - manipular uma solicita√ß√£o de m√©todo direto

1. Adicione o seguinte c√≥digo antes da fun√ß√£o `connectIoTHub`:

    ```cpp
    int directMethodCallback(const char *method_name, const unsigned char *payload, size_t size, unsigned char **response, size_t *response_size, void *userContextCallback)
    {
        Serial.printf("Direct method received %s\r\n", method_name);
    
        if (strcmp(method_name, "relay_on") == 0)
        {
            digitalWrite(PIN_WIRE_SCL, HIGH);
        }
        else if (strcmp(method_name, "relay_off") == 0)
        {
            digitalWrite(PIN_WIRE_SCL, LOW);
        }
    }
    ```

    Este c√≥digo define uma fun√ß√£o de callback que a biblioteca do IoT Hub pode chamar quando recebe uma solicita√ß√£o de m√©todo direto. O m√©todo solicitado √© enviado no par√¢metro `method_name`. Esta fun√ß√£o imprime o m√©todo chamado na porta serial e, em seguida, liga ou desliga o rel√© dependendo do nome do m√©todo.

    > üíÅ Isso tamb√©m poderia ser implementado em uma √∫nica solicita√ß√£o de m√©todo direto, passando o estado desejado do rel√© em um payload que pode ser enviado com a solicita√ß√£o de m√©todo e dispon√≠vel no par√¢metro `payload`.

1. Adicione o seguinte c√≥digo ao final da fun√ß√£o `directMethodCallback`:

    ```cpp
    char resultBuff[16];
    sprintf(resultBuff, "{\"Result\":\"\"}");
    *response_size = strlen(resultBuff);
    *response = (unsigned char *)malloc(*response_size);
    memcpy(*response, resultBuff, *response_size);

    return IOTHUB_CLIENT_OK;
    ```

    Solicita√ß√µes de m√©todo direto precisam de uma resposta, e a resposta √© composta por duas partes - uma resposta como texto e um c√≥digo de retorno. Este c√≥digo criar√° um resultado como o seguinte documento JSON:

    ```JSON
    {
        "Result": ""
    }
    ```

    Isso √© ent√£o copiado no par√¢metro `response`, e o tamanho desta resposta √© configurado no par√¢metro `response_size`. Este c√≥digo ent√£o retorna `IOTHUB_CLIENT_OK` para mostrar que o m√©todo foi manipulado corretamente.

1. Configure o callback adicionando o seguinte ao final da fun√ß√£o `connectIoTHub`:

    ```cpp
    IoTHubClient_LL_SetDeviceMethodCallback(_device_ll_handle, directMethodCallback, NULL);
    ```

1. A fun√ß√£o `loop` chamar√° a fun√ß√£o `IoTHubDeviceClient_LL_DoWork` para processar eventos enviados pelo IoT Hub. Isso √© chamado apenas a cada 10 segundos devido ao `delay`, o que significa que m√©todos diretos s√£o processados apenas a cada 10 segundos. Para tornar isso mais eficiente, o atraso de 10 segundos pode ser implementado como v√°rios atrasos mais curtos, chamando `IoTHubDeviceClient_LL_DoWork` a cada vez. Para fazer isso, adicione o seguinte c√≥digo acima da fun√ß√£o `loop`:

    ```cpp
    void work_delay(int delay_time)
    {
        int current = 0;
        do
        {
            IoTHubDeviceClient_LL_DoWork(_device_ll_handle);
            delay(100);
            current += 100;
        } while (current < delay_time);
    }
    ```

    Este c√≥digo far√° um loop repetidamente, chamando `IoTHubDeviceClient_LL_DoWork` e atrasando por 100ms a cada vez. Ele far√° isso tantas vezes quanto necess√°rio para atrasar pelo tempo dado no par√¢metro `delay_time`. Isso significa que o dispositivo est√° esperando no m√°ximo 100ms para processar solicita√ß√µes de m√©todo direto.

1. Na fun√ß√£o `loop`, remova a chamada para `IoTHubDeviceClient_LL_DoWork` e substitua a chamada `delay(10000)` pelo seguinte para chamar esta nova fun√ß√£o:

    ```cpp
    work_delay(10000);
    ```

> üíÅ Voc√™ pode encontrar este c√≥digo na pasta [code/wio-terminal](../../../../../2-farm/lessons/4-migrate-your-plant-to-the-cloud/code/wio-terminal).

üòÄ Seu programa de sensor de umidade do solo est√° conectado ao seu IoT Hub!

---

**Aviso Legal**:  
Este documento foi traduzido utilizando o servi√ßo de tradu√ß√£o por IA [Co-op Translator](https://github.com/Azure/co-op-translator). Embora nos esforcemos para garantir a precis√£o, esteja ciente de que tradu√ß√µes automatizadas podem conter erros ou imprecis√µes. O documento original em seu idioma nativo deve ser considerado a fonte autoritativa. Para informa√ß√µes cr√≠ticas, recomenda-se a tradu√ß√£o profissional realizada por humanos. N√£o nos responsabilizamos por quaisquer mal-entendidos ou interpreta√ß√µes equivocadas decorrentes do uso desta tradu√ß√£o.