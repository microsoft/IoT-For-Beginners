<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "64ad4ddb4de81a18b7252e968f10b404",
  "translation_date": "2025-08-25T17:44:13+00:00",
  "source_file": "6-consumer/lessons/3-spoken-feedback/single-board-computer-set-timer.md",
  "language_code": "hi"
}
-->
# टाइमर सेट करें - वर्चुअल IoT हार्डवेयर और रास्पबेरी पाई

इस पाठ के इस भाग में, आप अपने सर्वरलेस कोड को कॉल करेंगे ताकि भाषण को समझा जा सके और परिणामों के आधार पर अपने वर्चुअल IoT डिवाइस या रास्पबेरी पाई पर एक टाइमर सेट किया जा सके।

## टाइमर सेट करें

भाषण से टेक्स्ट में बदलने वाले कॉल से प्राप्त टेक्स्ट को आपके सर्वरलेस कोड में भेजा जाना चाहिए ताकि इसे LUIS द्वारा प्रोसेस किया जा सके और टाइमर के लिए सेकंड की संख्या प्राप्त की जा सके। इन सेकंड्स का उपयोग टाइमर सेट करने के लिए किया जा सकता है।

टाइमर को Python के `threading.Timer` क्लास का उपयोग करके सेट किया जा सकता है। यह क्लास एक देरी समय और एक फंक्शन लेता है, और देरी समय के बाद, फंक्शन निष्पादित होता है।

### कार्य - टेक्स्ट को सर्वरलेस फंक्शन में भेजें

1. VS Code में `smart-timer` प्रोजेक्ट खोलें और सुनिश्चित करें कि यदि आप वर्चुअल IoT डिवाइस का उपयोग कर रहे हैं तो टर्मिनल में वर्चुअल एनवायरनमेंट लोड हो।

1. `process_text` फंक्शन के ऊपर, एक फंक्शन `get_timer_time` घोषित करें ताकि आपने जो REST एंडपॉइंट बनाया है उसे कॉल किया जा सके:

    ```python
    def get_timer_time(text):
    ```

1. इस फंक्शन में निम्नलिखित कोड जोड़ें ताकि कॉल करने के लिए URL को परिभाषित किया जा सके:

    ```python
    url = '<URL>'
    ```

    `<URL>` को उस REST एंडपॉइंट के URL से बदलें जिसे आपने पिछले पाठ में अपने कंप्यूटर या क्लाउड पर बनाया था।

1. टेक्स्ट को JSON के रूप में कॉल में पास की जाने वाली प्रॉपर्टी के रूप में सेट करने के लिए निम्नलिखित कोड जोड़ें:

    ```python
    body = {
        'text': text
    }
    
    response = requests.post(url, json=body)
    ```

1. इसके नीचे, रिस्पॉन्स पेलोड से `seconds` को प्राप्त करें, और यदि कॉल विफल हो तो 0 लौटाएं:

    ```python
    if response.status_code != 200:
        return 0
    
    payload = response.json()
    return payload['seconds']
    ```

    सफल HTTP कॉल्स 200 रेंज में स्टेटस कोड लौटाते हैं, और आपका सर्वरलेस कोड 200 लौटाता है यदि टेक्स्ट को प्रोसेस किया गया और इसे सेट टाइमर इंटेंट के रूप में पहचाना गया।

### कार्य - बैकग्राउंड थ्रेड पर टाइमर सेट करें

1. फाइल के शीर्ष पर निम्नलिखित इंपोर्ट स्टेटमेंट जोड़ें ताकि threading Python लाइब्रेरी को इंपोर्ट किया जा सके:

    ```python
    import threading
    ```

1. `process_text` फंक्शन के ऊपर, एक फंक्शन जोड़ें ताकि प्रतिक्रिया को बोला जा सके। अभी के लिए यह केवल कंसोल में लिखेगा, लेकिन इस पाठ में बाद में यह टेक्स्ट बोलेगा।

    ```python
    def say(text):
        print(text)
    ```

1. इसके नीचे एक फंक्शन जोड़ें जिसे टाइमर द्वारा कॉल किया जाएगा ताकि यह घोषणा की जा सके कि टाइमर पूरा हो गया है:

    ```python
    def announce_timer(minutes, seconds):
        announcement = 'Times up on your '
        if minutes > 0:
            announcement += f'{minutes} minute '
        if seconds > 0:
            announcement += f'{seconds} second '
        announcement += 'timer.'
        say(announcement)
    ```

    यह फंक्शन टाइमर के लिए मिनट्स और सेकंड्स की संख्या लेता है और एक वाक्य बनाता है जो कहता है कि टाइमर पूरा हो गया है। यह मिनट्स और सेकंड्स की संख्या की जांच करता है और केवल उस समय इकाई को शामिल करता है जिसमें कोई संख्या हो। उदाहरण के लिए, यदि मिनट्स की संख्या 0 है तो केवल सेकंड्स को संदेश में शामिल किया जाता है। यह वाक्य फिर `say` फंक्शन को भेजा जाता है।

1. इसके नीचे, निम्नलिखित `create_timer` फंक्शन जोड़ें ताकि टाइमर बनाया जा सके:

    ```python
    def create_timer(total_seconds):
        minutes, seconds = divmod(total_seconds, 60)
        threading.Timer(total_seconds, announce_timer, args=[minutes, seconds]).start()
    ```

    यह फंक्शन टाइमर के लिए कुल सेकंड्स लेता है जो कमांड में भेजा जाएगा और इसे मिनट्स और सेकंड्स में बदलता है। फिर यह कुल सेकंड्स का उपयोग करके एक टाइमर ऑब्जेक्ट बनाता और शुरू करता है, `announce_timer` फंक्शन और मिनट्स और सेकंड्स वाली सूची को पास करता है। जब टाइमर समाप्त होता है, तो यह `announce_timer` फंक्शन को कॉल करेगा और इस सूची की सामग्री को पैरामीटर्स के रूप में पास करेगा - इसलिए सूची का पहला आइटम `minutes` पैरामीटर के रूप में पास होता है और दूसरा आइटम `seconds` पैरामीटर के रूप में।

1. `create_timer` फंक्शन के अंत में, उपयोगकर्ता को यह घोषणा करने के लिए एक संदेश बनाने का कोड जोड़ें कि टाइमर शुरू हो रहा है:

    ```python
    announcement = ''
    if minutes > 0:
        announcement += f'{minutes} minute '
    if seconds > 0:
        announcement += f'{seconds} second '    
    announcement += 'timer started.'
    say(announcement)
    ```

    फिर से, यह केवल उस समय इकाई को शामिल करता है जिसमें कोई मान होता है। यह वाक्य फिर `say` फंक्शन को भेजा जाता है।

1. `process_text` फंक्शन के अंत में निम्नलिखित जोड़ें ताकि टेक्स्ट से टाइमर के लिए समय प्राप्त किया जा सके, फिर टाइमर बनाया जा सके:

    ```python
    seconds = get_timer_time(text)
    if seconds > 0:
        create_timer(seconds)
    ```

    टाइमर केवल तब बनाया जाता है जब सेकंड्स की संख्या 0 से अधिक हो।

1. ऐप चलाएं और सुनिश्चित करें कि फंक्शन ऐप भी चल रहा है। कुछ टाइमर सेट करें, और आउटपुट दिखाएगा कि टाइमर सेट हो रहा है और फिर दिखाएगा जब यह समाप्त होता है:

    ```output
    pi@raspberrypi:~/smart-timer $ python3 app.py 
    Set a two minute 27 second timer.
    2 minute 27 second timer started.
    Times up on your 2 minute 27 second timer.
    ```

> 💁 आप इस कोड को [code-timer/pi](../../../../../6-consumer/lessons/3-spoken-feedback/code-timer/pi) या [code-timer/virtual-iot-device](../../../../../6-consumer/lessons/3-spoken-feedback/code-timer/virtual-iot-device) फोल्डर में पा सकते हैं।

😀 आपका टाइमर प्रोग्राम सफल रहा!

**अस्वीकरण**:  
यह दस्तावेज़ AI अनुवाद सेवा [Co-op Translator](https://github.com/Azure/co-op-translator) का उपयोग करके अनुवादित किया गया है। जबकि हम सटीकता सुनिश्चित करने का प्रयास करते हैं, कृपया ध्यान दें कि स्वचालित अनुवाद में त्रुटियां या अशुद्धियां हो सकती हैं। मूल भाषा में उपलब्ध मूल दस्तावेज़ को प्रामाणिक स्रोत माना जाना चाहिए। महत्वपूर्ण जानकारी के लिए, पेशेवर मानव अनुवाद की सिफारिश की जाती है। इस अनुवाद के उपयोग से उत्पन्न किसी भी गलतफहमी या गलत व्याख्या के लिए हम जिम्मेदार नहीं हैं।