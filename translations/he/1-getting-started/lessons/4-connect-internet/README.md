<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "71b5040e0b3472f1c0949c9b55f224c0",
  "translation_date": "2025-08-27T21:44:04+00:00",
  "source_file": "1-getting-started/lessons/4-connect-internet/README.md",
  "language_code": "he"
}
-->
# חיבור המכשיר שלך לאינטרנט

![סקיצה של השיעור](../../../../../translated_images/lesson-4.7344e074ea68fa545fd320b12dce36d72dd62d28c3b4596cb26cf315f434b98f.he.jpg)

> סקיצה מאת [Nitya Narasimhan](https://github.com/nitya). לחץ על התמונה לגרסה גדולה יותר.

השיעור הזה נלמד כחלק מסדרת [Hello IoT](https://youtube.com/playlist?list=PLmsFUfdnGr3xRts0TIwyaHyQuHaNQcb6-) של [Microsoft Reactor](https://developer.microsoft.com/reactor/?WT.mc_id=academic-17441-jabenn). השיעור הועבר בשני סרטונים - שיעור של שעה אחת ושעה נוספת של שאלות ותשובות עם העמקה בחלקים מהשיעור.

[![שיעור 4: חיבור המכשיר שלך לאינטרנט](https://img.youtube.com/vi/O4dd172mZhs/0.jpg)](https://youtu.be/O4dd172mZhs)

[![שיעור 4: חיבור המכשיר שלך לאינטרנט - שאלות ותשובות](https://img.youtube.com/vi/j-cVCzRDE2Q/0.jpg)](https://youtu.be/j-cVCzRDE2Q)

> 🎥 לחץ על התמונות למעלה לצפייה בסרטונים

## שאלון לפני השיעור

[שאלון לפני השיעור](https://black-meadow-040d15503.1.azurestaticapps.net/quiz/7)

## מבוא

האות **I** ב-IoT מייצגת **אינטרנט** - החיבור לענן והשירותים שמאפשרים את רוב הפונקציות של מכשירי IoT, החל מאיסוף נתונים מהחיישנים המחוברים למכשיר ועד לשליחת הודעות לשליטה במפעילים. מכשירי IoT בדרך כלל מתחברים לשירות ענן יחיד באמצעות פרוטוקול תקשורת סטנדרטי, והשירות הזה מחובר לשאר האפליקציה שלך, החל משירותי AI לקבלת החלטות חכמות על בסיס הנתונים ועד לאפליקציות אינטרנט לשליטה או דיווח.

> 🎓 נתונים שנאספים מחיישנים ונשלחים לענן נקראים טלמטריה.

מכשירי IoT יכולים לקבל הודעות מהענן. לעיתים ההודעות מכילות פקודות - כלומר הוראות לביצוע פעולה, בין אם פנימית (כגון אתחול או עדכון קושחה) או באמצעות מפעיל (כגון הדלקת אור).

השיעור הזה מציג כמה מפרוטוקולי התקשורת שמכשירי IoT יכולים להשתמש בהם כדי להתחבר לענן, ואת סוגי הנתונים שהם עשויים לשלוח או לקבל. בנוסף, תתנסו בהם בפועל, ותוסיפו שליטה דרך האינטרנט למנורת הלילה שלכם, תוך העברת לוגיקת השליטה ב-LED לקוד 'שרת' שרץ מקומית.

בשיעור הזה נעסוק ב:

* [פרוטוקולי תקשורת](../../../../../1-getting-started/lessons/4-connect-internet)
* [Message Queueing Telemetry Transport (MQTT)](../../../../../1-getting-started/lessons/4-connect-internet)
* [טלמטריה](../../../../../1-getting-started/lessons/4-connect-internet)
* [פקודות](../../../../../1-getting-started/lessons/4-connect-internet)

## פרוטוקולי תקשורת

ישנם מספר פרוטוקולי תקשורת פופולריים שמכשירי IoT משתמשים בהם כדי לתקשר עם האינטרנט. הפופולריים ביותר מבוססים על מודל פרסום/מנוי דרך סוג כלשהו של מתווך. מכשירי IoT מתחברים למתווך, מפרסמים טלמטריה ונרשמים לפקודות. שירותי הענן גם מתחברים למתווך, נרשמים לכל הודעות הטלמטריה ומפרסמים פקודות למכשירים ספציפיים או לקבוצות של מכשירים.

![מכשירי IoT מתחברים למתווך, מפרסמים טלמטריה ונרשמים לפקודות. שירותי ענן מתחברים למתווך, נרשמים לכל הטלמטריה ושולחים פקודות למכשירים ספציפיים.](../../../../../translated_images/pub-sub.7c7ed43fe9fd15d4e1f81a3fd95440413c457acd9bcbe9a43341e30e88db5264.he.png)

MQTT הוא פרוטוקול התקשורת הפופולרי ביותר למכשירי IoT והוא מכוסה בשיעור הזה. פרוטוקולים אחרים כוללים AMQP ו-HTTP/HTTPS.

## Message Queueing Telemetry Transport (MQTT)

[MQTT](http://mqtt.org) הוא פרוטוקול הודעות קל משקל וסטנדרטי פתוח שיכול לשלוח הודעות בין מכשירים. הוא תוכנן בשנת 1999 לניטור צינורות נפט, ושוחרר כסטנדרט פתוח 15 שנים מאוחר יותר על ידי IBM.

MQTT כולל מתווך יחיד ומספר לקוחות. כל הלקוחות מתחברים למתווך, והמתווך מנתב הודעות ללקוחות הרלוונטיים. הודעות מנותבות באמצעות נושאים (topics) שמותיים, במקום להישלח ישירות ללקוח מסוים. לקוח יכול לפרסם לנושא, וכל לקוח שנרשם לנושא הזה יקבל את ההודעה.

![מכשיר IoT מפרסם טלמטריה בנושא /telemetry, ושירות הענן נרשם לנושא הזה](../../../../../translated_images/mqtt.cbf7f21d9adc3e17548b359444cc11bb4bf2010543e32ece9a47becf54438c23.he.png)

✅ בצעו מחקר. אם יש לכם הרבה מכשירי IoT, איך תוכלו להבטיח שהמתווך של MQTT יוכל להתמודד עם כל ההודעות?

### חיבור מכשיר ה-IoT שלכם ל-MQTT

החלק הראשון בהוספת שליטה דרך האינטרנט למנורת הלילה שלכם הוא חיבור למתווך MQTT.

#### משימה

חברו את המכשיר שלכם למתווך MQTT.

בחלק הזה של השיעור, תחברו את מנורת הלילה שלכם לאינטרנט כדי לאפשר שליטה מרחוק. מאוחר יותר בשיעור, מכשיר ה-IoT שלכם ישלח הודעת טלמטריה דרך MQTT למתווך MQTT ציבורי עם רמת האור, שם היא תיאסף על ידי קוד שרת שתכתבו. הקוד הזה יבדוק את רמת האור וישלח הודעת פקודה חזרה למכשיר, שתורה לו להדליק או לכבות את ה-LED.

שימוש אמיתי במערכת כזו יכול להיות איסוף נתונים ממספר חיישני אור לפני קבלת החלטה להדליק אורות, במקום עם הרבה אורות, כמו אצטדיון. זה יכול למנוע הדלקת אורות אם רק חיישן אחד מכוסה בעננים או ציפור, אבל שאר החיישנים מזהים מספיק אור.

✅ אילו מצבים אחרים ידרשו הערכת נתונים ממספר חיישנים לפני שליחת פקודות?

במקום להתמודד עם המורכבות של הגדרת מתווך MQTT כחלק מהמשימה הזו, תוכלו להשתמש בשרת בדיקה ציבורי שמריץ [Eclipse Mosquitto](https://www.mosquitto.org), מתווך MQTT בקוד פתוח. מתווך הבדיקה הזה זמין לציבור ב-[test.mosquitto.org](https://test.mosquitto.org), ואינו דורש יצירת חשבון, מה שהופך אותו לכלי נהדר לבדיקת לקוחות ושרתים של MQTT.

> 💁 מתווך הבדיקה הזה הוא ציבורי ואינו מאובטח. כל אחד יכול להאזין למה שאתם מפרסמים, ולכן לא כדאי להשתמש בו עם נתונים שצריכים להישאר פרטיים.

![תרשים זרימה של המשימה שמראה קריאת רמות אור ובדיקתן, ושליטה ב-LED](../../../../../translated_images/assignment-1-internet-flow.3256feab5f052fd273bf4e331157c574c2c3fa42e479836fc9c3586f41db35a5.he.png)

עקבו אחר הצעד הרלוונטי למטה כדי לחבר את המכשיר שלכם למתווך MQTT:

* [Arduino - Wio Terminal](wio-terminal-mqtt.md)
* [מחשב לוח יחיד - Raspberry Pi/מכשיר IoT וירטואלי](single-board-computer-mqtt.md)

### מבט מעמיק יותר על MQTT

נושאים יכולים להיות בעלי היררכיה, ולקוחות יכולים להירשם לרמות שונות של ההיררכיה באמצעות תווים כלליים. לדוגמה, תוכלו לשלוח הודעות טלמטריה של טמפרטורה לנושא `/telemetry/temperature` והודעות לחות לנושא `/telemetry/humidity`, ואז באפליקציית הענן שלכם להירשם לנושא `/telemetry/*` כדי לקבל את שתי הודעות הטלמטריה של הטמפרטורה והלחות.

הודעות יכולות להישלח עם איכות שירות (QoS), שקובעת את ההבטחה לקבלת ההודעה.

* פעם אחת בלבד - ההודעה נשלחת פעם אחת בלבד והלקוח והמתווך לא נוקטים צעדים נוספים לאישור המסירה (שלח ושכח).
* לפחות פעם אחת - ההודעה נשלחת מחדש על ידי השולח מספר פעמים עד שמתקבל אישור (מסירה מאושרת).
* בדיוק פעם אחת - השולח והמקבל מבצעים תהליך אישור דו-שלבי כדי להבטיח שהודעה אחת בלבד תתקבל (מסירה מובטחת).

✅ אילו מצבים עשויים לדרוש הודעה עם מסירה מובטחת על פני הודעת שלח ושכח?

למרות שהשם הוא Message Queueing (ראשי תיבות ב-MQTT), הוא למעשה לא תומך בתורים של הודעות. המשמעות היא שאם לקוח מתנתק ואז מתחבר מחדש, הוא לא יקבל הודעות שנשלחו במהלך הניתוק, למעט הודעות שהוא כבר התחיל לעבד באמצעות תהליך QoS. הודעות יכולות להיות עם דגל שמור. אם הדגל הזה מוגדר, מתווך MQTT ישמור את ההודעה האחרונה שנשלחה לנושא עם הדגל הזה, וישלח אותה לכל לקוח שיירשם לנושא הזה מאוחר יותר. כך, הלקוחות תמיד יקבלו את ההודעה האחרונה.

MQTT גם תומך בפונקציית שמירה על חיבור שמוודאת שהחיבור עדיין פעיל במהלך פערים ארוכים בין הודעות.

> 🦟 [Mosquitto מקרן Eclipse](https://mosquitto.org) מציע מתווך MQTT חינמי שתוכלו להפעיל בעצמכם כדי להתנסות ב-MQTT, יחד עם מתווך MQTT ציבורי שתוכלו להשתמש בו לבדיקת הקוד שלכם, המתארח ב-[test.mosquitto.org](https://test.mosquitto.org).

חיבורי MQTT יכולים להיות ציבוריים ופתוחים, או מוצפנים ומאובטחים באמצעות שמות משתמש וסיסמאות, או תעודות.

> 💁 MQTT מתקשר דרך TCP/IP, אותו פרוטוקול רשת בסיסי כמו HTTP, אבל על פורט שונה. ניתן גם להשתמש ב-MQTT דרך WebSockets כדי לתקשר עם אפליקציות אינטרנט שרצות בדפדפן, או במצבים שבהם חומות אש או כללי רשת אחרים חוסמים חיבורי MQTT סטנדרטיים.

## טלמטריה

המילה טלמטריה נגזרת משורשים יווניים שמשמעותם מדידה מרחוק. טלמטריה היא פעולת איסוף נתונים מחיישנים ושליחתם לענן.

> 💁 אחד ממכשירי הטלמטריה הראשונים הומצא בצרפת בשנת 1874 ושלח בזמן אמת נתוני מזג אוויר ועומק שלג ממון בלאן לפריז. הוא השתמש בחוטים פיזיים מכיוון שטכנולוגיות אלחוטיות לא היו זמינות באותה תקופה.

בואו נחזור לדוגמה של התרמוסטט החכם משיעור 1.

![תרמוסטט מחובר לאינטרנט שמשתמש בחיישנים מרובים בחדרים](../../../../../translated_images/telemetry.21e5d8b97649d2ebeb0f68d4b9691ab2d1f7bd629338e131465aff8a614e4d4a.he.png)

לתרמוסטט יש חיישני טמפרטורה לאיסוף טלמטריה. סביר להניח שיהיה לו חיישן טמפרטורה מובנה, והוא עשוי להתחבר למספר חיישני טמפרטורה חיצוניים דרך פרוטוקול אלחוטי כמו [Bluetooth Low Energy](https://wikipedia.org/wiki/Bluetooth_Low_Energy) (BLE).

דוגמה לנתוני הטלמטריה שהוא עשוי לשלוח יכולה להיות:

| שם | ערך | תיאור |
| ---- | ----- | ----------- |
| `thermostat_temperature` | 18°C | הטמפרטורה שנמדדה על ידי חיישן הטמפרטורה המובנה של התרמוסטט |
| `livingroom_temperature` | 19°C | הטמפרטורה שנמדדה על ידי חיישן טמפרטורה מרוחק שנקרא `livingroom` כדי לזהות את החדר שבו הוא נמצא |
| `bedroom_temperature` | 21°C | הטמפרטורה שנמדדה על ידי חיישן טמפרטורה מרוחק שנקרא `bedroom` כדי לזהות את החדר שבו הוא נמצא |

שירות הענן יכול להשתמש בנתוני הטלמטריה האלה כדי לקבל החלטות לגבי אילו פקודות לשלוח לשליטה בחימום.

### שליחת טלמטריה ממכשיר ה-IoT שלכם

החלק הבא בהוספת שליטה דרך האינטרנט למנורת הלילה שלכם הוא שליחת טלמטריה של רמת האור למתווך MQTT בנושא טלמטריה.

#### משימה - שליחת טלמטריה ממכשיר ה-IoT שלכם

שלחו טלמטריה של רמת האור למתווך MQTT.

נתונים נשלחים מקודדים כ-JSON - קיצור ל-JavaScript Object Notation, סטנדרט לקידוד נתונים בטקסט באמצעות זוגות מפתח/ערך.

✅ אם לא נתקלתם ב-JSON בעבר, תוכלו ללמוד עליו יותר בתיעוד של [JSON.org](https://www.json.org/).

עקבו אחר הצעד הרלוונטי למטה כדי לשלוח טלמטריה מהמכשיר שלכם למתווך MQTT:

* [Arduino - Wio Terminal](wio-terminal-telemetry.md)
* [מחשב לוח יחיד - Raspberry Pi/מכשיר IoT וירטואלי](single-board-computer-telemetry.md)

### קבלת טלמטריה ממתווך MQTT

אין טעם לשלוח טלמטריה אם אין שום דבר בצד השני שמאזין לה. הטלמטריה של רמת האור צריכה משהו שמאזין לה כדי לעבד את הנתונים. קוד ה'שרת' הזה הוא סוג הקוד שתפרסו לשירות ענן כחלק מאפליקציית IoT גדולה יותר, אבל כאן אתם הולכים להריץ את הקוד הזה מקומית על המחשב שלכם (או על ה-Pi שלכם אם אתם כותבים קוד ישירות עליו). קוד השרת מורכב מאפליקציית Python שמאזינה להודעות טלמטריה דרך MQTT עם רמות אור. מאוחר יותר בשיעור תגרמו לה להשיב עם הודעת פקודה עם הוראות להדליק או לכבות את ה-LED.

✅ בצעו מחקר: מה קורה להודעות MQTT אם אין מאזין?

#### התקנת Python ו-VS Code

אם אין לכם Python ו-VS Code מותקנים מקומית, תצטרכו להתקין את שניהם כדי לכתוב את קוד השרת. אם אתם משתמשים במכשיר IoT וירטואלי או עובדים על Raspberry Pi, תוכלו לדלג על השלב הזה מכיוון שצריך להיות לכם כבר הכל מותקן ומוגדר.

##### משימה - התקנת Python ו-VS Code

התקינו Python ו-VS Code.

1. התקינו Python. עיינו בעמוד ההורדות של [Python](https://www.python.org/downloads/) להוראות התקנה של הגרסה האחרונה של Python.

1. התקינו את Visual Studio Code (VS Code). זהו העורך שבו תשתמשו לכתיבת קוד המכשיר הווירטואלי שלכם ב-Python. עיינו בתיעוד של [VS Code](https://code.visualstudio.com?WT.mc_id=academic-17441-jabenn) להוראות התקנה של VS Code.
💁 אתם יכולים להשתמש בכל עורך או סביבת פיתוח של Python שאתם מעדיפים עבור השיעורים הללו, אך ההוראות בשיעורים יתבססו על שימוש ב-VS Code.
1. התקן את הרחבת Pylance עבור VS Code. זו הרחבה ל-VS Code המספקת תמיכה בשפת Python. עיין ב-[תיעוד הרחבת Pylance](https://marketplace.visualstudio.com/items?WT.mc_id=academic-17441-jabenn&itemName=ms-python.vscode-pylance) להוראות התקנה של ההרחבה ב-VS Code.

#### הגדרת סביבת עבודה וירטואלית ב-Python

אחת התכונות החזקות של Python היא היכולת להתקין [חבילות pip](https://pypi.org) - אלו חבילות קוד שנכתבו על ידי אחרים ופורסמו באינטרנט. ניתן להתקין חבילת pip במחשב שלך באמצעות פקודה אחת בלבד, ואז להשתמש בחבילה הזו בקוד שלך. תשתמש ב-pip כדי להתקין חבילה לתקשורת באמצעות MQTT.

כברירת מחדל, כאשר אתה מתקין חבילה, היא זמינה בכל המחשב שלך, וזה יכול להוביל לבעיות עם גרסאות חבילות - כמו יישום אחד שתלוי בגרסה מסוימת של חבילה שעלולה להישבר כאשר אתה מתקין גרסה חדשה עבור יישום אחר. כדי להתמודד עם בעיה זו, ניתן להשתמש ב-[סביבת עבודה וירטואלית ב-Python](https://docs.python.org/3/library/venv.html), שהיא למעשה עותק של Python בתיקייה ייעודית, וכאשר אתה מתקין חבילות pip הן מותקנות רק בתיקייה הזו.

##### משימה - הגדרת סביבת עבודה וירטואלית ב-Python

הגדר סביבת עבודה וירטואלית ב-Python והתקן את חבילות pip עבור MQTT.

1. מהטרמינל או שורת הפקודה שלך, הרץ את הפקודות הבאות במיקום לבחירתך כדי ליצור תיקייה חדשה ולעבור אליה:

    ```sh
    mkdir nightlight-server
    cd nightlight-server
    ```

1. כעת הרץ את הפקודה הבאה כדי ליצור סביבת עבודה וירטואלית בתיקיית `.venv`:

    ```sh
    python3 -m venv .venv
    ```

    > 💁 יש לקרוא במפורש ל-`python3` כדי ליצור את סביבת העבודה הווירטואלית, למקרה שיש לך Python 2 מותקן בנוסף ל-Python 3 (הגרסה העדכנית ביותר). אם Python 2 מותקן, קריאה ל-`python` תשתמש ב-Python 2 במקום ב-Python 3.

1. הפעל את סביבת העבודה הווירטואלית:

    * ב-Windows:
        * אם אתה משתמש ב-Command Prompt או ב-Command Prompt דרך Windows Terminal, הרץ:

            ```cmd
            .venv\Scripts\activate.bat
            ```

        * אם אתה משתמש ב-PowerShell, הרץ:

            ```powershell
            .\.venv\Scripts\Activate.ps1
            ```

    * ב-macOS או Linux, הרץ:

        ```cmd
        source ./.venv/bin/activate
        ```

    > 💁 פקודות אלו צריכות להיות מופעלות מאותו מיקום שבו הרצת את הפקודה ליצירת סביבת העבודה הווירטואלית. לעולם לא תצטרך לנווט לתוך תיקיית `.venv`, תמיד יש להפעיל את פקודת ההפעלה וכל פקודות להתקנת חבילות או הרצת קוד מהתיקייה שבה היית כשיצרת את סביבת העבודה הווירטואלית.

1. לאחר שסביבת העבודה הווירטואלית הופעלה, פקודת `python` כברירת מחדל תפעיל את גרסת Python שבה השתמשת ליצירת סביבת העבודה הווירטואלית. הרץ את הפקודה הבאה כדי לבדוק את הגרסה:

    ```sh
    python --version
    ```

    הפלט יהיה דומה לפלט הבא:

    ```output
    (.venv) ➜  nightlight-server python --version
    Python 3.9.1
    ```

    > 💁 גרסת Python שלך עשויה להיות שונה - כל עוד זו גרסה 3.6 או גבוהה יותר, אתה בסדר. אם לא, מחק את התיקייה הזו, התקן גרסה חדשה יותר של Python ונסה שוב.

1. הרץ את הפקודות הבאות כדי להתקין את חבילת pip עבור [Paho-MQTT](https://pypi.org/project/paho-mqtt/), ספריית MQTT פופולרית.

    ```sh
    pip install paho-mqtt
    ```

    חבילת pip זו תותקן רק בסביבת העבודה הווירטואלית, ולא תהיה זמינה מחוץ לה.

#### כתיבת קוד השרת

כעת ניתן לכתוב את קוד השרת ב-Python.

##### משימה - כתיבת קוד השרת

כתוב את קוד השרת.

1. מהטרמינל או שורת הפקודה שלך, הרץ את הפקודה הבאה בתוך סביבת העבודה הווירטואלית כדי ליצור קובץ Python בשם `app.py`:

    * ב-Windows הרץ:

        ```cmd
        type nul > app.py
        ```

    * ב-macOS או Linux הרץ:

        ```cmd
        touch app.py
        ```

1. פתח את התיקייה הנוכחית ב-VS Code:

    ```sh
    code .
    ```

1. כאשר VS Code יופעל, הוא יפעיל את סביבת העבודה הווירטואלית של Python. הדבר ידווח בשורת המצב התחתונה:

    ![VS Code showing the selected virtual environment](../../../../../translated_images/vscode-virtual-env.8ba42e04c3d533cf677e16cbe5ed9a3b80f62c6964472dc84b6f940800f0909f.he.png)

1. אם הטרמינל של VS Code כבר פועל כאשר VS Code מופעל, הוא לא יפעיל את סביבת העבודה הווירטואלית בתוכו. הדבר הפשוט ביותר לעשות הוא לסגור את הטרמינל באמצעות כפתור **Kill the active terminal instance**:

    ![VS Code Kill the active terminal instance button](../../../../../translated_images/vscode-kill-terminal.1cc4de7c6f25ee08f423f0ead714e61d069fac1eb2089e97b8a7bbcb3d45fe5e.he.png)

1. הפעל טרמינל חדש ב-VS Code על ידי בחירה ב-*Terminal -> New Terminal*, או לחיצה על `` CTRL+` ``. הטרמינל החדש יטען את סביבת העבודה הווירטואלית, עם קריאה להפעלה שתופיע בטרמינל. שם סביבת העבודה הווירטואלית (`.venv`) יופיע גם הוא בהנחיה:

    ```output
    ➜  nightlight-server source .venv/bin/activate
    (.venv) ➜  nightlight 
    ```

1. פתח את הקובץ `app.py` מסייר הקבצים של VS Code והוסף את הקוד הבא:

    ```python
    import json
    import time
    
    import paho.mqtt.client as mqtt
    
    id = '<ID>'
    
    client_telemetry_topic = id + '/telemetry'
    client_name = id + 'nightlight_server'
    
    mqtt_client = mqtt.Client(client_name)
    mqtt_client.connect('test.mosquitto.org')
    
    mqtt_client.loop_start()
    
    def handle_telemetry(client, userdata, message):
        payload = json.loads(message.payload.decode())
        print("Message received:", payload)
    
    mqtt_client.subscribe(client_telemetry_topic)
    mqtt_client.on_message = handle_telemetry
    
    while True:
        time.sleep(2)
    ```

    החלף את `<ID>` בשורה 6 עם מזהה הייחודי שהשתמשת בו בעת יצירת קוד המכשיר שלך.

    ⚠️ זה **חייב** להיות אותו מזהה שהשתמשת בו במכשיר שלך, אחרת קוד השרת לא יירשם או יפרסם לנושא הנכון.

    קוד זה יוצר לקוח MQTT עם שם ייחודי ומתחבר ל-broker *test.mosquitto.org*. לאחר מכן הוא מתחיל לולאת עיבוד שפועלת על שרשור רקע ומאזינה להודעות בכל הנושאים הרשומים.

    הלקוח נרשם להודעות בנושא הטלמטריה ומגדיר פונקציה שנקראת כאשר מתקבלת הודעה. כאשר מתקבלת הודעת טלמטריה, הפונקציה `handle_telemetry` מופעלת ומדפיסה את ההודעה שהתקבלה לקונסול.

    לבסוף, לולאה אינסופית שומרת על האפליקציה פועלת. לקוח ה-MQTT מאזין להודעות על שרשור רקע ופועל כל הזמן שהאפליקציה הראשית פועלת.

1. מהטרמינל של VS Code, הרץ את הפקודה הבאה כדי להפעיל את אפליקציית Python שלך:

    ```sh
    python app.py
    ```

    האפליקציה תתחיל להאזין להודעות מהמכשיר IoT.

1. ודא שהמכשיר שלך פועל ושולח הודעות טלמטריה. שנה את רמות האור שמזוהות על ידי המכשיר הפיזי או הווירטואלי שלך. הודעות שמתקבלות יודפסו לטרמינל.

    ```output
    (.venv) ➜  nightlight-server python app.py
    Message received: {'light': 0}
    Message received: {'light': 400}
    ```

    הקובץ app.py בסביבת העבודה הווירטואלית nightlight חייב להיות פועל כדי שהקובץ app.py בסביבת העבודה הווירטואלית nightlight-server יקבל את ההודעות שנשלחות.

> 💁 ניתן למצוא את הקוד הזה בתיקייה [code-server/server](../../../../../1-getting-started/lessons/4-connect-internet/code-server/server).

### באיזו תדירות יש לשלוח טלמטריה?

שיקול חשוב עם טלמטריה הוא באיזו תדירות למדוד ולשלוח את הנתונים? התשובה היא - זה תלוי. אם תמדוד לעיתים קרובות תוכל להגיב מהר יותר לשינויים במדידות, אך תשתמש ביותר כוח, יותר רוחב פס, תיצור יותר נתונים ותצטרך יותר משאבי ענן לעיבוד.

לדוגמה, עבור תרמוסטט, מדידה כל כמה דקות היא כנראה יותר ממספיקה, שכן טמפרטורות לא משתנות לעיתים קרובות. אם תמדוד רק פעם ביום, אתה עלול לחמם את הבית לטמפרטורות לילה באמצע יום שמשי, בעוד שאם תמדוד כל שנייה יהיו לך אלפי מדידות טמפרטורה מיותרות שיאטו את מהירות האינטרנט של המשתמשים, ישתמשו ביותר כוח (בעיה עבור מכשירים מבוססי סוללה כמו חיישנים מרוחקים), ויגדילו את עלות משאבי הענן של הספקים לעיבוד ואחסון.

לעומת זאת, אם אתה עוקב אחר נתונים סביב מכונה במפעל שאם היא תיכשל זה עלול לגרום לנזק קטסטרופלי ומיליוני דולרים בהפסדים, אז מדידה מספר פעמים בשנייה עשויה להיות הכרחית. עדיף לבזבז רוחב פס מאשר לפספס טלמטריה שמצביעה על כך שמכונה צריכה להיעצר ולתוקן לפני שהיא נשברת.

> 💁 במצב כזה, ייתכן שתרצה לשקול שימוש במכשיר קצה לעיבוד הטלמטריה תחילה כדי להפחית את התלות באינטרנט.

### אובדן קישוריות

חיבורי אינטרנט יכולים להיות לא אמינים, עם תקלות נפוצות. מה מכשיר IoT צריך לעשות בנסיבות אלו - האם הוא צריך לאבד את הנתונים, או לשמור אותם עד שהקישוריות תשוחזר? שוב, התשובה היא שזה תלוי.

לדוגמה, עבור תרמוסטט, הנתונים יכולים כנראה להיאבד ברגע שנמדדה טמפרטורה חדשה. מערכת החימום לא מתעניינת בכך שלפני 20 דקות הטמפרטורה הייתה 20.5°C אם הטמפרטורה עכשיו היא 19°C, הטמפרטורה הנוכחית היא זו שקובעת אם החימום צריך להיות מופעל או כבוי.

לעומת זאת, עבור מכונות ייתכן שתרצה לשמור את הנתונים, במיוחד אם הם משמשים לחיפוש מגמות. ישנם מודלים של למידת מכונה שיכולים לזהות חריגות בזרמי נתונים על ידי הסתכלות על נתונים מתקופה מוגדרת (כגון השעה האחרונה) וזיהוי נתונים חריגים. זה משמש לעיתים קרובות לתחזוקה חזויה, חיפוש אינדיקציות לכך שמשהו עשוי להישבר בקרוב כדי שתוכל לתקן או להחליף אותו לפני שזה קורה. ייתכן שתרצה שכל טלמטריה עבור מכונה תישלח כדי שתוכל לעבד אותה לזיהוי חריגות, ולכן ברגע שמכשיר ה-IoT יכול להתחבר מחדש הוא ישלח את כל הטלמטריה שנוצרה במהלך תקופת התקלה באינטרנט.

מעצבי מכשירי IoT צריכים גם לשקול אם ניתן להשתמש במכשיר IoT במהלך תקלה באינטרנט או אובדן אות שנגרם על ידי מיקום. תרמוסטט חכם צריך להיות מסוגל לקבל החלטות מוגבלות לשליטה בחימום אם הוא לא יכול לשלוח טלמטריה לענן עקב תקלה.

[![מכונית פרארי נתקעה כי מישהו ניסה לעדכן אותה מתחת לאדמה ללא קליטת סלולר](../../../../../translated_images/bricked-car.dc38f8efadc6c59d76211f981a521efb300939283dee468f79503aae3ec67615.he.png)](https://twitter.com/internetofshit/status/1315736960082808832)

כדי ש-MQTT יטפל באובדן קישוריות, קוד המכשיר והשרת יצטרכו להיות אחראים להבטחת מסירת הודעות אם היא נדרשת, לדוגמה על ידי דרישה שכל ההודעות שנשלחות ייענו בהודעות נוספות בנושא תשובה, ואם לא הן יתווספו לתור באופן ידני כדי להישלח מחדש מאוחר יותר.

## פקודות

פקודות הן הודעות שנשלחות מהענן למכשיר, ומורות לו לעשות משהו. רוב הזמן זה כרוך במתן סוג של פלט באמצעות מפעיל, אבל זה יכול להיות הוראה למכשיר עצמו, כמו לבצע אתחול מחדש, או לאסוף טלמטריה נוספת ולהחזיר אותה כתגובה לפקודה.

![תרמוסטט מחובר לאינטרנט שמקבל פקודה להפעיל את החימום](../../../../../translated_images/commands.d6c06bbbb3a02cce95f2831a1c331daf6dedd4e470c4aa2b0ae54f332016e504.he.png)

לדוגמה, תרמוסטט יכול לקבל פקודה מהענן להפעיל את החימום. בהתבסס על נתוני הטלמטריה מכל החיישנים, אם שירות הענן החליט שהחימום צריך להיות מופעל, הוא שולח את הפקודה הרלוונטית.

### שליחת פקודות ל-broker של MQTT

השלב הבא עבור מנורת הלילה הנשלטת דרך האינטרנט הוא שקוד השרת ישלח פקודה חזרה למכשיר IoT כדי לשלוט באור בהתאם לרמות האור שהוא מזהה.

1. פתח את קוד השרת ב-VS Code

1. הוסף את השורה הבאה לאחר הכרזת `client_telemetry_topic` כדי להגדיר לאיזה נושא לשלוח פקודות:

    ```python
    server_command_topic = id + '/commands'
    ```

1. הוסף את הקוד הבא לסוף הפונקציה `handle_telemetry`:

    ```python
    command = { 'led_on' : payload['light'] < 300 }
    print("Sending message:", command)
    
    client.publish(server_command_topic, json.dumps(command))
    ```

    קוד זה שולח הודעת JSON לנושא הפקודה עם הערך של `led_on` מוגדר ל-true או false בהתאם אם האור פחות מ-300 או לא. אם האור פחות מ-300, נשלח true כדי להורות למכשיר להפעיל את ה-LED.

1. הרץ את הקוד כפי שעשית קודם

1. שנה את רמות האור שמזוהות על ידי המכשיר הפיזי או הווירטואלי שלך. הודעות שמתקבלות ופקודות שנשלחות ייכתבו לטרמינל:

    ```output
    (.venv) ➜  nightlight-server python app.py
    Message received: {'light': 0}
    Sending message: {'led_on': True}
    Message received: {'light': 400}
    Sending message: {'led_on': False}
    ```

> 💁 הטלמטריה והפקודות נשלחות על נושא אחד בלבד כל אחד. משמעות הדבר היא שטלמטריה ממכשירים מרובים תופיע באותו נושא טלמטריה, ופקודות למכשירים מרובים יופיעו באותו נושא פקודות. אם תרצה לשלוח פקודה למכשיר ספציפי, תוכל להשתמש בנושאים מרובים, שמות עם מזהה מכשיר ייחודי, כגון `/commands/device1`, `/commands/device2`. כך מכשיר יכול להאזין להודעות שמיועדות רק למכשיר אחד.

> 💁 ניתן למצוא את הקוד הזה בתיקייה [code-commands/server](../../../../../1-getting-started/lessons/4-connect-internet/code-commands/server).

### טיפול בפקודות במכשיר IoT

כעת, כאשר פקודות נשלחות מהשרת, ניתן להוסיף קוד למכשיר IoT כדי לטפל בהן ולשלוט ב-LED.

עקוב אחר השלב הרלוונטי למטה כדי להאזין לפקודות מה-broker של MQTT:

* [Arduino - Wio Terminal](wio-terminal-commands.md)
* [מחשב חד-לוח - Raspberry Pi/מכשיר IoT וירטואלי](single-board-computer-commands.md)

לאחר שהקוד הזה נכתב ופועל, נסה לשנות את רמות האור. צפה בפלט מהשרת ומהמכשיר, וצפה ב-LED כאשר אתה משנה את רמות האור.

### אובדן קישוריות

מה שירות ענן צריך לעשות אם הוא צריך לשלוח פקודה למכשיר IoT שאינו מחובר? שוב, התשובה היא שזה תלוי.

אם הפקודה האחרונה מבטלת פקודה קודמת, אז ניתן כנראה להתעלם מהפקודות הקודמות. אם שירות ענן שולח פקודה להפעיל את החימום, ואז שולח פקודה לכבות אותו, אז ניתן להתעלם מהפקודה להפעיל ולא לשלוח אותה מחדש.

אם הפקודות צריכות להיות מעובדות ברצף, כמו להזיז זרוע רובוטית למעלה ואז לסגור תופסן, אז הן צריכות להישלח בסדר הנכון ברגע שהקישוריות משוחזרת.

✅ כיצד קוד המכשיר או השרת יכול להבטיח שפקודות תמיד יישלחו ויטופלו בסדר הנכון באמצעות MQTT אם יש צורך?

---

## 🚀 אתגר

האתגר בשלושת השיעורים האחרונים היה לרשום כמה שיותר מכשירי IoT שנמצאים בבית, בבית הספר או במקום העבודה שלך ולהחליט אם הם מבוססים על מיקרו-בקרים או מחשבים חד-לוחיים, או אפילו שילוב של שניהם, ולחשוב על אילו חיישנים ומפעילים הם משתמשים.
למכשירים אלו, חשבו על אילו הודעות הם עשויים לשלוח או לקבל. איזה טלמטריה הם שולחים? אילו הודעות או פקודות הם עשויים לקבל? האם לדעתכם הם מאובטחים?

## חידון לאחר ההרצאה

[חידון לאחר ההרצאה](https://black-meadow-040d15503.1.azurestaticapps.net/quiz/8)

## סקירה ולימוד עצמי

קראו עוד על MQTT בעמוד הוויקיפדיה של [MQTT](https://wikipedia.org/wiki/MQTT).

נסו להפעיל שרת MQTT בעצמכם באמצעות [Mosquitto](https://www.mosquitto.org) ולהתחבר אליו מהמכשיר ה-IoT שלכם ומהקוד של השרת.

> 💁 טיפ - כברירת מחדל, Mosquitto לא מאפשר חיבורים אנונימיים (כלומר חיבורים ללא שם משתמש וסיסמה), ולא מאפשר חיבורים מחוץ למחשב שעליו הוא פועל.  
> ניתן לתקן זאת באמצעות [קובץ תצורה `mosquitto.conf`](https://www.mosquitto.org/man/mosquitto-conf-5.html) עם התוכן הבא:  
>
> ```sh
> listener 1883 0.0.0.0
> allow_anonymous true
> ```

## משימה

[השוו והבדילו בין MQTT לפרוטוקולי תקשורת אחרים](assignment.md)

---

**כתב ויתור**:  
מסמך זה תורגם באמצעות שירות תרגום מבוסס בינה מלאכותית [Co-op Translator](https://github.com/Azure/co-op-translator). למרות שאנו שואפים לדיוק, יש לקחת בחשבון שתרגומים אוטומטיים עשויים להכיל שגיאות או אי דיוקים. המסמך המקורי בשפתו המקורית צריך להיחשב כמקור סמכותי. עבור מידע קריטי, מומלץ להשתמש בתרגום מקצועי על ידי אדם. איננו נושאים באחריות לאי הבנות או לפרשנויות שגויות הנובעות משימוש בתרגום זה.