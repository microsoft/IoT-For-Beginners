<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "160be8c0f558687f6686dca64f10f739",
  "translation_date": "2025-08-28T12:29:25+00:00",
  "source_file": "4-manufacturing/lessons/2-check-fruit-from-device/wio-terminal-camera.md",
  "language_code": "hr"
}
-->
# Snimanje slike - Wio Terminal

U ovom dijelu lekcije dodati ƒáete kameru na svoj Wio Terminal i snimiti slike pomoƒáu nje.

## Hardver

Wio Terminal treba kameru.

Kamera koju ƒáete koristiti je [ArduCam Mini 2MP Plus](https://www.arducam.com/product/arducam-2mp-spi-camera-b0067-arduino/). Ovo je kamera od 2 megapiksela bazirana na OV2640 senzoru slike. Komunicira putem SPI suƒçelja za snimanje slika i koristi I2C za konfiguraciju senzora.

## Povezivanje kamere

ArduCam nema Grove prikljuƒçak, veƒá se povezuje na SPI i I2C sabirnice putem GPIO pinova na Wio Terminalu.

### Zadatak - povezivanje kamere

Pove≈æite kameru.

![Senzor ArduCam](../../../../../translated_images/arducam.20e4e4cbb268296570b5914e20d6c349fc42ddac9ed4e1b9deba2188204eebae.hr.png)

1. Pinovi na bazi ArduCam-a trebaju biti povezani na GPIO pinove na Wio Terminalu. Kako biste lak≈°e prona≈°li odgovarajuƒáe pinove, zalijepite naljepnicu s GPIO pinovima koja dolazi uz Wio Terminal oko pinova:

    ![Wio Terminal s naljepnicom GPIO pinova](../../../../../translated_images/wio-terminal-pin-sticker.b90b1535937b84bd00d853f0004aea74fac2aec04b43f14b887796b2633f855e.hr.png)

1. Koristeƒái ≈æice za povezivanje, napravite sljedeƒáe veze:

    | Pin ArduCAM-a | Pin Wio Terminala | Opis                                    |
    | ------------- | ----------------- | --------------------------------------- |
    | CS            | 24 (SPI_CS)       | SPI odabir ƒçipa                         |
    | MOSI          | 19 (SPI_MOSI)     | SPI izlaz kontrolera, ulaz periferije   |
    | MISO          | 21 (SPI_MISO)     | SPI ulaz kontrolera, izlaz periferije   |
    | SCK           | 23 (SPI_SCLK)     | SPI serijski sat                        |
    | GND           | 6 (GND)           | Zemlja - 0V                             |
    | VCC           | 4 (5V)            | Napajanje od 5V                         |
    | SDA           | 3 (I2C1_SDA)      | I2C serijski podaci                     |
    | SCL           | 5 (I2C1_SCL)      | I2C serijski sat                        |

    ![Wio Terminal povezan s ArduCam-om pomoƒáu ≈æica](../../../../../translated_images/arducam-wio-terminal-connections.a4d5a4049bdb5ab800a2877389fc6ecf5e4ff307e6451ff56c517e6786467d0a.hr.png)

    GND i VCC veze osiguravaju napajanje od 5V za ArduCam. Kamera radi na 5V, za razliku od Grove senzora koji rade na 3V. Ovo napajanje dolazi direktno iz USB-C prikljuƒçka koji napaja ureƒëaj.

    > üíÅ Za SPI vezu oznake pinova na ArduCam-u i nazivi pinova na Wio Terminalu koji se koriste u kodu jo≈° uvijek koriste staru konvenciju imenovanja. Upute u ovoj lekciji koristit ƒáe novu konvenciju imenovanja, osim kada se nazivi pinova koriste u kodu.

1. Sada mo≈æete povezati Wio Terminal s raƒçunalom.

## Programiranje ureƒëaja za povezivanje s kamerom

Wio Terminal sada mo≈æe biti programiran za kori≈°tenje prikljuƒçene ArduCAM kamere.

### Zadatak - programiranje ureƒëaja za povezivanje s kamerom

1. Kreirajte potpuno novi projekt za Wio Terminal koristeƒái PlatformIO. Nazovite projekt `fruit-quality-detector`. Dodajte kod u funkciju `setup` za konfiguraciju serijskog porta.

1. Dodajte kod za povezivanje na WiFi, koristeƒái va≈°e WiFi vjerodajnice u datoteci `config.h`. Ne zaboravite dodati potrebne biblioteke u datoteku `platformio.ini`.

1. Biblioteka ArduCam nije dostupna kao Arduino biblioteka koja se mo≈æe instalirati iz datoteke `platformio.ini`. Umjesto toga, potrebno ju je instalirati iz izvornog koda s njihove GitHub stranice. Mo≈æete je dobiti na sljedeƒáe naƒçine:

    * Kloniranjem repozitorija s [https://github.com/ArduCAM/Arduino.git](https://github.com/ArduCAM/Arduino.git)
    * Posjetom repozitoriju na GitHub-u na [github.com/ArduCAM/Arduino](https://github.com/ArduCAM/Arduino) i preuzimanjem koda kao zip datoteke putem gumba **Code**

1. Trebate samo mapu `ArduCAM` iz ovog koda. Kopirajte cijelu mapu u mapu `lib` u va≈°em projektu.

    > ‚ö†Ô∏è Cijela mapa mora biti kopirana, tako da je kod u `lib/ArduCam`. Nemojte samo kopirati sadr≈æaj mape `ArduCam` u mapu `lib`, kopirajte cijelu mapu.

1. Kod biblioteke ArduCam radi za vi≈°e vrsta kamera. Tip kamere koju ≈æelite koristiti konfigurira se pomoƒáu zastavica kompajlera - ovo odr≈æava biblioteku ≈°to manjom uklanjanjem koda za kamere koje ne koristite. Za konfiguraciju biblioteke za OV2640 kameru, dodajte sljedeƒáe na kraj datoteke `platformio.ini`:

    ```ini
    build_flags =
        -DARDUCAM_SHIELD_V2
        -DOV2640_CAM
    ```

    Ovo postavlja 2 zastavice kompajlera:

      * `ARDUCAM_SHIELD_V2` za informiranje biblioteke da je kamera na Arduino ploƒçi, poznatoj kao shield.
      * `OV2640_CAM` za informiranje biblioteke da ukljuƒçi samo kod za OV2640 kameru.

1. Dodajte zaglavnu datoteku u mapu `src` nazvanu `camera.h`. Ova datoteka ƒáe sadr≈æavati kod za komunikaciju s kamerom. Dodajte sljedeƒái kod u ovu datoteku:

    ```cpp
    #pragma once
    
    #include <ArduCAM.h>
    #include <Wire.h>
    
    class Camera
    {
    public:
        Camera(int format, int image_size) : _arducam(OV2640, PIN_SPI_SS)
        {
            _format = format;
            _image_size = image_size;
        }
    
        bool init()
        {
            // Reset the CPLD
            _arducam.write_reg(0x07, 0x80);
            delay(100);
    
            _arducam.write_reg(0x07, 0x00);
            delay(100);
    
            // Check if the ArduCAM SPI bus is OK
            _arducam.write_reg(ARDUCHIP_TEST1, 0x55);
            if (_arducam.read_reg(ARDUCHIP_TEST1) != 0x55)
            {
                return false;
            }
                
            // Change MCU mode
            _arducam.set_mode(MCU2LCD_MODE);
    
            uint8_t vid, pid;
    
            // Check if the camera module type is OV2640
            _arducam.wrSensorReg8_8(0xff, 0x01);
            _arducam.rdSensorReg8_8(OV2640_CHIPID_HIGH, &vid);
            _arducam.rdSensorReg8_8(OV2640_CHIPID_LOW, &pid);
            if ((vid != 0x26) && ((pid != 0x41) || (pid != 0x42)))
            {
                return false;
            }
            
            _arducam.set_format(_format);
            _arducam.InitCAM();
            _arducam.OV2640_set_JPEG_size(_image_size);
            _arducam.OV2640_set_Light_Mode(Auto);
            _arducam.OV2640_set_Special_effects(Normal);
            delay(1000);
    
            return true;
        }
    
        void startCapture()
        {
            _arducam.flush_fifo();
            _arducam.clear_fifo_flag();
            _arducam.start_capture();
        }
    
        bool captureReady()
        {
            return _arducam.get_bit(ARDUCHIP_TRIG, CAP_DONE_MASK);
        }
    
        bool readImageToBuffer(byte **buffer, uint32_t &buffer_length)
        {
            if (!captureReady()) return false;
    
            // Get the image file length
            uint32_t length = _arducam.read_fifo_length();
            buffer_length = length;
    
            if (length >= MAX_FIFO_SIZE)
            {
                return false;
            }
            if (length == 0)
            {
                return false;
            }
    
            // create the buffer
            byte *buf = new byte[length];
    
            uint8_t temp = 0, temp_last = 0;
            int i = 0;
            uint32_t buffer_pos = 0;
            bool is_header = false;
    
            _arducam.CS_LOW();
            _arducam.set_fifo_burst();
            
            while (length--)
            {
                temp_last = temp;
                temp = SPI.transfer(0x00);
                //Read JPEG data from FIFO
                if ((temp == 0xD9) && (temp_last == 0xFF)) //If find the end ,break while,
                {
                    buf[buffer_pos] = temp;
    
                    buffer_pos++;
                    i++;
                    
                    _arducam.CS_HIGH();
                }
                if (is_header == true)
                {
                    //Write image data to buffer if not full
                    if (i < 256)
                    {
                        buf[buffer_pos] = temp;
                        buffer_pos++;
                        i++;
                    }
                    else
                    {
                        _arducam.CS_HIGH();
    
                        i = 0;
                        buf[buffer_pos] = temp;
    
                        buffer_pos++;
                        i++;
    
                        _arducam.CS_LOW();
                        _arducam.set_fifo_burst();
                    }
                }
                else if ((temp == 0xD8) & (temp_last == 0xFF))
                {
                    is_header = true;
    
                    buf[buffer_pos] = temp_last;
                    buffer_pos++;
                    i++;
    
                    buf[buffer_pos] = temp;
                    buffer_pos++;
                    i++;
                }
            }
            
            _arducam.clear_fifo_flag();
    
            _arducam.set_format(_format);
            _arducam.InitCAM();
            _arducam.OV2640_set_JPEG_size(_image_size);
    
            // return the buffer
            *buffer = buf;
        }
    
    private:
        ArduCAM _arducam;
        int _format;
        int _image_size;
    };
    ```

    Ovo je kod niske razine koji konfigurira kameru koristeƒái biblioteke ArduCam i izvlaƒçi slike kada je potrebno koristeƒái SPI sabirnicu. Ovaj kod je vrlo specifiƒçan za ArduCam, tako da ne morate brinuti o tome kako radi u ovom trenutku.

1. U `main.cpp`, dodajte sljedeƒái kod ispod ostalih `include` izjava za ukljuƒçivanje ove nove datoteke i kreiranje instance klase kamere:

    ```cpp
    #include "camera.h"

    Camera camera = Camera(JPEG, OV2640_640x480);
    ```

    Ovo kreira `Camera` koja sprema slike kao JPEG-ove u rezoluciji 640x480. Iako su podr≈æane veƒáe rezolucije (do 3280x2464), klasifikator slika radi na mnogo manjim slikama (227x227), tako da nema potrebe za snimanjem i slanjem veƒáih slika.

1. Dodajte sljedeƒái kod ispod ovoga za definiranje funkcije za postavljanje kamere:

    ```cpp
    void setupCamera()
    {
        pinMode(PIN_SPI_SS, OUTPUT);
        digitalWrite(PIN_SPI_SS, HIGH);
    
        Wire.begin();
        SPI.begin();
    
        if (!camera.init())
        {
            Serial.println("Error setting up the camera!");
        }
    }
    ```

    Ova funkcija `setupCamera` zapoƒçinje konfiguracijom SPI pina za odabir ƒçipa (`PIN_SPI_SS`) kao visokog, ƒçime Wio Terminal postaje SPI kontroler. Zatim pokreƒáe I2C i SPI sabirnice. Na kraju inicijalizira klasu kamere koja konfigurira postavke senzora kamere i osigurava da je sve ispravno povezano.

1. Pozovite ovu funkciju na kraju funkcije `setup`:

    ```cpp
    setupCamera();
    ```

1. Izgradite i uƒçitajte ovaj kod te provjerite izlaz iz serijskog monitora. Ako vidite `Error setting up the camera!`, provjerite o≈æiƒçenje kako biste osigurali da su svi kablovi povezani na ispravne pinove na ArduCam-u i GPIO pinove na Wio Terminalu te da su svi kablovi ispravno postavljeni.

## Snimanje slike

Wio Terminal sada mo≈æe biti programiran za snimanje slike kada se pritisne gumb.

### Zadatak - snimanje slike

1. Mikrokontroleri kontinuirano izvr≈°avaju va≈° kod, tako da nije lako pokrenuti ne≈°to poput snimanja fotografije bez reagiranja na senzor. Wio Terminal ima gumbe, pa se kamera mo≈æe postaviti da se aktivira jednim od gumba. Dodajte sljedeƒái kod na kraj funkcije `setup` za konfiguraciju gumba C (jednog od tri gumba na vrhu, onog najbli≈æeg prekidaƒçu za napajanje).

    ![Gumb C na vrhu najbli≈æi prekidaƒçu za napajanje](../../../../../translated_images/wio-terminal-c-button.73df3cb1c1445ea07ee98316af0e7925fcb43135df0abed58d3d4822b2589c3b.hr.png)

    ```cpp
    pinMode(WIO_KEY_C, INPUT_PULLUP);
    ```

    Naƒçin rada `INPUT_PULLUP` u osnovi invertira ulaz. Na primjer, normalno bi gumb slao nizak signal kada nije pritisnut, a visok signal kada je pritisnut. Kada je postavljen na `INPUT_PULLUP`, ≈°alje visok signal kada nije pritisnut, a nizak signal kada je pritisnut.

1. Dodajte praznu funkciju za reagiranje na pritisak gumba prije funkcije `loop`:

    ```cpp
    void buttonPressed()
    {
        
    }
    ```

1. Pozovite ovu funkciju u metodi `loop` kada je gumb pritisnut:

    ```cpp
    void loop()
    {
        if (digitalRead(WIO_KEY_C) == LOW)
        {
            buttonPressed();
            delay(2000);
        }
    
        delay(200);
    }
    ```

    Ovaj kljuƒç provjerava je li gumb pritisnut. Ako je pritisnut, poziva se funkcija `buttonPressed`, a petlja se odgaƒëa za 2 sekunde. Ovo omoguƒáuje vrijeme za otpu≈°tanje gumba kako se dugi pritisak ne bi registrirao dvaput.

    > üíÅ Gumb na Wio Terminalu je postavljen na `INPUT_PULLUP`, pa ≈°alje visok signal kada nije pritisnut, a nizak signal kada je pritisnut.

1. Dodajte sljedeƒái kod u funkciju `buttonPressed`:

    ```cpp
    camera.startCapture();
 
    while (!camera.captureReady())
        delay(100);

    Serial.println("Image captured");

    byte *buffer;
    uint32_t length;

    if (camera.readImageToBuffer(&buffer, length))
    {
        Serial.print("Image read to buffer with length ");
        Serial.println(length);

        delete(buffer);
    }
    ```

    Ovaj kod zapoƒçinje snimanje kamere pozivom `startCapture`. Hardver kamere ne radi tako da vraƒáa podatke kada ih zatra≈æite, veƒá ≈°aljete instrukciju za poƒçetak snimanja, a kamera ƒáe raditi u pozadini na snimanju slike, pretvaranju u JPEG i spremanju u lokalni meƒëuspremnik na samoj kameri. Poziv `captureReady` zatim provjerava je li snimanje slike zavr≈°eno.

    Kada je snimanje zavr≈°eno, podaci slike kopiraju se iz meƒëuspremnika na kameri u lokalni meƒëuspremnik (niz bajtova) pozivom `readImageToBuffer`. Duljina meƒëuspremnika zatim se ≈°alje na serijski monitor.

1. Izgradite i uƒçitajte ovaj kod te provjerite izlaz na serijskom monitoru. Svaki put kada pritisnete gumb C, slika ƒáe biti snimljena i vidjet ƒáete veliƒçinu slike poslanu na serijski monitor.

    ```output
    Connecting to WiFi..
    Connected!
    Image captured
    Image read to buffer with length 9224
    Image captured
    Image read to buffer with length 11272
    ```

    Razliƒçite slike imat ƒáe razliƒçite veliƒçine. Komprimirane su kao JPEG-ovi, a veliƒçina JPEG datoteke za odreƒëenu rezoluciju ovisi o tome ≈°to se nalazi na slici.

> üíÅ Ovaj kod mo≈æete pronaƒái u mapi [code-camera/wio-terminal](../../../../../4-manufacturing/lessons/2-check-fruit-from-device/code-camera/wio-terminal).

üòÄ Uspje≈°no ste snimili slike pomoƒáu svog Wio Terminala.

## Opcionalno - provjera slika kamere pomoƒáu SD kartice

Najlak≈°i naƒçin za pregled slika koje je kamera snimila je zapisivanje na SD karticu u Wio Terminalu, a zatim pregled na va≈°em raƒçunalu. Napravite ovaj korak ako imate rezervnu microSD karticu i microSD prikljuƒçak na va≈°em raƒçunalu ili adapter.

Wio Terminal podr≈æava samo microSD kartice do 16GB. Ako imate veƒáu SD karticu, neƒáe raditi.

### Zadatak - provjera slika kamere pomoƒáu SD kartice

1. Formatirajte microSD karticu kao FAT32 ili exFAT koristeƒái odgovarajuƒáe aplikacije na va≈°em raƒçunalu (Disk Utility na macOS-u, File Explorer na Windowsima ili pomoƒáu alata naredbenog retka na Linuxu).

1. Umetnite microSD karticu u prikljuƒçak odmah ispod prekidaƒça za napajanje. Provjerite je li potpuno umetnuta dok ne klikne i ostane na mjestu; mo≈æda ƒáete je morati gurnuti pomoƒáu nokta ili tankog alata.

1. Dodajte sljedeƒáe `include` izjave na vrh datoteke `main.cpp`:

    ```cpp
    #include "SD/Seeed_SD.h"
    #include <Seeed_FS.h>
    ```

1. Dodajte sljedeƒáu funkciju prije funkcije `setup`:

    ```cpp
    void setupSDCard()
    {
        while (!SD.begin(SDCARD_SS_PIN, SDCARD_SPI))
        {
            Serial.println("SD Card Error");
        }
    }
    ```

    Ovo konfigurira SD karticu koristeƒái SPI sabirnicu.

1. Pozovite ovo iz funkcije `setup`:

    ```cpp
    setupSDCard();
    ```

1. Dodajte sljedeƒái kod iznad funkcije `buttonPressed`:

    ```cpp
    int fileNum = 1;

    void saveToSDCard(byte *buffer, uint32_t length)
    {
        char buff[16];
        sprintf(buff, "%d.jpg", fileNum);
        fileNum++;
    
        File outFile = SD.open(buff, FILE_WRITE );
        outFile.write(buffer, length);
        outFile.close();

        Serial.print("Image written to file ");
        Serial.println(buff);
    }
    ```

    Ovo definira globalnu varijablu za broj datoteka. Koristi se za nazive datoteka slika kako bi se moglo snimiti vi≈°e slika s poveƒáavajuƒáim nazivima datoteka - `1.jpg`, `2.jpg` i tako dalje.

    Zatim definira funkciju `saveToSDCard` koja prima meƒëuspremnik podataka bajtova i duljinu meƒëuspremnika. Naziv datoteke se kreira koristeƒái broj datoteka, a broj datoteka se poveƒáava za sljedeƒáu datoteku. Binarni podaci iz meƒëuspremnika zatim se zapisuju u datoteku.

1. Pozovite funkciju `saveToSDCard` iz funkcije `buttonPressed`. Poziv bi trebao biti **prije** nego ≈°to se meƒëuspremnik izbri≈°e:

    ```cpp
    Serial.print("Image read to buffer with length ");
    Serial.println(length);

    saveToSDCard(buffer, length);
    
    delete(buffer);
    ```

1. Izgradite i uƒçitajte ovaj kod te provjerite izlaz na serijskom monitoru. Svaki put kada pritisnete gumb C, slika ƒáe biti snimljena i spremljena na SD karticu.

    ```output
    Connecting to WiFi..
    Connected!
    Image captured
    Image read to buffer with length 16392
    Image written to file 1.jpg
    Image captured
    Image read to buffer with length 14344
    Image written to file 2.jpg
    ```

1. Iskljuƒçite microSD karticu i izvadite je laganim pritiskom i otpu≈°tanjem, te ƒáe iskoƒçiti. Mo≈æda ƒáete morati koristiti tanki alat za ovo. Prikljuƒçite microSD karticu na svoje raƒçunalo kako biste pregledali slike.

    ![Slika banane snimljena pomoƒáu ArduCam-a](../../../../../translated_images/banana-arducam.be1b32d4267a8194b0fd042362e56faa431da9cd4af172051b37243ea9be0256.hr.jpg)
üíÅ Mo≈æda ƒáe biti potrebno nekoliko slika da se bijela ravnote≈æa kamere prilagodi. Primijetit ƒáete to na temelju boje snimljenih slika, prve nekoliko mogu izgledati neispravno u boji. Uvijek mo≈æete zaobiƒái ovo promjenom koda kako biste snimili nekoliko slika koje se ignoriraju u funkciji `setup`.


---

**Odricanje od odgovornosti**:  
Ovaj dokument je preveden pomoƒáu AI usluge za prevoƒëenje [Co-op Translator](https://github.com/Azure/co-op-translator). Iako nastojimo osigurati toƒçnost, imajte na umu da automatski prijevodi mogu sadr≈æavati pogre≈°ke ili netoƒçnosti. Izvorni dokument na izvornom jeziku treba smatrati autoritativnim izvorom. Za kljuƒçne informacije preporuƒçuje se profesionalni prijevod od strane ƒçovjeka. Ne preuzimamo odgovornost za bilo kakva nesporazuma ili pogre≈°na tumaƒçenja koja proizlaze iz kori≈°tenja ovog prijevoda.