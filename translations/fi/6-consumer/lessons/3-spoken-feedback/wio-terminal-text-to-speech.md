<!--
CO_OP_TRANSLATOR_METADATA:
{
  "original_hash": "a202fa5889790a3777bfc33dd9f4b459",
  "translation_date": "2025-08-27T22:28:19+00:00",
  "source_file": "6-consumer/lessons/3-spoken-feedback/wio-terminal-text-to-speech.md",
  "language_code": "fi"
}
-->
# Teksti puheeksi - Wio Terminal

T√§ss√§ osassa oppituntia muutat tekstin puheeksi tarjotaksesi puhuttua palautetta.

## Teksti puheeksi

Puhepalveluiden SDK, jota k√§ytit edellisess√§ oppitunnissa muuttaaksesi puheen tekstiksi, voidaan k√§ytt√§√§ tekstin muuttamiseen takaisin puheeksi.

## Hanki lista √§√§nist√§

Kun pyyd√§t puhetta, sinun t√§ytyy m√§√§ritt√§√§ k√§ytett√§v√§ √§√§ni, sill√§ puhetta voidaan tuottaa monilla eri √§√§nill√§. Jokainen kieli tukee useita eri √§√§ni√§, ja puhepalveluiden SDK:sta voit saada listan kunkin kielen tuetuista √§√§nist√§. Mikro-ohjainten rajoitukset tulevat t√§ss√§ esiin - puhepalveluiden tukemien √§√§nien lista on yli 77KB kokoinen JSON-dokumentti, joka on liian suuri k√§sitelt√§v√§ksi Wio Terminalilla. Kirjoitushetkell√§ t√§ydellinen lista sis√§lt√§√§ 215 √§√§nt√§, joista jokainen on m√§√§ritelty JSON-dokumentilla, kuten seuraava:

```json
{
    "Name": "Microsoft Server Speech Text to Speech Voice (en-US, AriaNeural)",
    "DisplayName": "Aria",
    "LocalName": "Aria",
    "ShortName": "en-US-AriaNeural",
    "Gender": "Female",
    "Locale": "en-US",
    "StyleList": [
        "chat",
        "customerservice",
        "narration-professional",
        "newscast-casual",
        "newscast-formal",
        "cheerful",
        "empathetic"
    ],
    "SampleRateHertz": "24000",
    "VoiceType": "Neural",
    "Status": "GA"
}
```

T√§m√§ JSON koskee **Aria**-√§√§nt√§, jolla on useita √§√§nen tyylej√§. Tekstin muuttamiseksi puheeksi tarvitaan vain lyhytnimi, `en-US-AriaNeural`.

Sen sijaan, ett√§ lataisit ja dekoodaisit koko listan mikro-ohjaimellasi, sinun t√§ytyy kirjoittaa lis√§√§ serveritt√∂mi√§ koodeja hakeaksesi listan k√§ytett√§v√§n kielen √§√§nist√§ ja kutsua t√§t√§ Wio Terminalista. Koodisi voi sitten valita sopivan √§√§nen listasta, esimerkiksi ensimm√§isen l√∂yt√§m√§ns√§.

### Teht√§v√§ - luo serverit√∂n funktio √§√§nilistan hakemiseksi

1. Avaa `smart-timer-trigger`-projektisi VS Codessa ja avaa terminaali varmistaen, ett√§ virtuaaliymp√§rist√∂ on aktivoitu. Jos ei, lopeta ja luo terminaali uudelleen.

1. Avaa `local.settings.json`-tiedosto ja lis√§√§ asetukset puhepalvelun API-avaimelle ja sijainnille:

    ```json
    "SPEECH_KEY": "<key>",
    "SPEECH_LOCATION": "<location>"
    ```

    Korvaa `<key>` puhepalveluresurssisi API-avaimella. Korvaa `<location>` sijainnilla, jota k√§ytit luodessasi puhepalveluresurssin.

1. Lis√§√§ uusi HTTP-triggeri t√§h√§n sovellukseen nimelt√§ `get-voices` k√§ytt√§m√§ll√§ seuraavaa komentoa VS Code -terminaalissa funktiosovelluksen projektin juurikansiossa:

    ```sh
    func new --name get-voices --template "HTTP trigger"
    ```

    T√§m√§ luo HTTP-triggerin nimelt√§ `get-voices`.

1. Korvaa `get-voices`-kansion `__init__.py`-tiedoston sis√§lt√∂ seuraavalla:

    ```python
    import json
    import os
    import requests
    
    import azure.functions as func
    
    def main(req: func.HttpRequest) -> func.HttpResponse:
        location = os.environ['SPEECH_LOCATION']
        speech_key = os.environ['SPEECH_KEY']
    
        req_body = req.get_json()
        language = req_body['language']
    
        url = f'https://{location}.tts.speech.microsoft.com/cognitiveservices/voices/list'
    
        headers = {
            'Ocp-Apim-Subscription-Key': speech_key
        }
    
        response = requests.get(url, headers=headers)
        voices_json = json.loads(response.text)
    
        voices = filter(lambda x: x['Locale'].lower() == language.lower(), voices_json)
        voices = map(lambda x: x['ShortName'], voices)
    
        return func.HttpResponse(json.dumps(list(voices)), status_code=200)
    ```

    T√§m√§ koodi tekee HTTP-pyynn√∂n endpointiin √§√§nien hakemiseksi. √Ñ√§nilista on suuri JSON-lohko, joka sis√§lt√§√§ kaikkien kielten √§√§net, joten pyynn√∂n rungossa v√§litetyn kielen √§√§net suodatetaan, ja lyhytnimi poimitaan ja palautetaan JSON-listana. Lyhytnimi on arvo, jota tarvitaan tekstin muuttamiseksi puheeksi, joten vain t√§m√§ arvo palautetaan.

    > üíÅ Voit muuttaa suodatinta tarpeen mukaan valitaksesi vain haluamasi √§√§net.

    T√§m√§ pienent√§√§ datan kokoa 77KB:sta (kirjoitushetkell√§) paljon pienemm√§ksi JSON-dokumentiksi. Esimerkiksi Yhdysvaltain √§√§nille t√§m√§ on 408 tavua.

1. Aja funktiosovelluksesi paikallisesti. Voit sitten kutsua t√§t√§ ty√∂kalulla, kuten curl, samalla tavalla kuin testasit `text-to-timer` HTTP-triggeri√§. Muista v√§litt√§√§ kielesi JSON-runkona:

    ```json
    {
        "language":"<language>"
    }
    ```

    Korvaa `<language>` kielell√§si, kuten `en-GB` tai `zh-CN`.

> üíÅ L√∂yd√§t t√§m√§n koodin [code-spoken-response/functions](../../../../../6-consumer/lessons/3-spoken-feedback/code-spoken-response/functions)-kansiosta.

### Teht√§v√§ - hae √§√§ni Wio Terminalistasi

1. Avaa `smart-timer`-projektisi VS Codessa, jos se ei ole jo auki.

1. Avaa `config.h`-otsikkotiedosto ja lis√§√§ URL funktiosovelluksellesi:

    ```cpp
    const char *GET_VOICES_FUNCTION_URL = "<URL>";
    ```

    Korvaa `<URL>` URL:lla `get-voices` HTTP-triggerille funktiosovelluksessasi. T√§m√§ on sama kuin `TEXT_TO_TIMER_FUNCTION_URL`-arvo, paitsi ett√§ funktiolla on nimi `get-voices` eik√§ `text-to-timer`.

1. Luo uusi tiedosto `src`-kansioon nimelt√§ `text_to_speech.h`. T√§t√§ k√§ytet√§√§n luokan m√§√§ritt√§miseen tekstin muuttamiseksi puheeksi.

1. Lis√§√§ seuraavat include-direktiivit uuden `text_to_speech.h`-tiedoston alkuun:

    ```cpp
    #pragma once

    #include <Arduino.h>
    #include <ArduinoJson.h>
    #include <HTTPClient.h>
    #include <Seeed_FS.h>
    #include <SD/Seeed_SD.h>
    #include <WiFiClient.h>
    #include <WiFiClientSecure.h>
    
    #include "config.h"
    #include "speech_to_text.h"
    ```

1. Lis√§√§ t√§m√§n alle seuraava koodi `TextToSpeech`-luokan julistamiseksi, sek√§ instanssi, jota voidaan k√§ytt√§√§ sovelluksen muissa osissa:

    ```cpp
    class TextToSpeech
    {
    public:
    private:
    };
    
    TextToSpeech textToSpeech;
    ```

1. Kutsua varten funktiosovellusta, sinun t√§ytyy julistaa WiFi-asiakas. Lis√§√§ seuraava luokan `private`-osioon:

    ```cpp
    WiFiClient _client;
    ```

1. Lis√§√§ `private`-osioon kentt√§ valitulle √§√§nelle:

    ```cpp
    String _voice;
    ```

1. Lis√§√§ `public`-osioon `init`-funktio, joka hakee ensimm√§isen √§√§nen:

    ```cpp
    void init()
    {
    }
    ```

1. √Ñ√§nien hakemiseksi JSON-dokumentti t√§ytyy l√§hett√§√§ funktiosovellukseen kielen kanssa. Lis√§√§ seuraava koodi `init`-funktioon luodaksesi t√§m√§n JSON-dokumentin:

    ```cpp
    DynamicJsonDocument doc(1024);
    doc["language"] = LANGUAGE;

    String body;
    serializeJson(doc, body);
    ```

1. Luo seuraavaksi `HTTPClient` ja k√§yt√§ sit√§ kutsuaksesi funktiosovellusta √§√§nien hakemiseksi, l√§hett√§en JSON-dokumentin:

    ```cpp
    HTTPClient httpClient;
    httpClient.begin(_client, GET_VOICES_FUNCTION_URL);

    int httpResponseCode = httpClient.POST(body);
    ```

1. Lis√§√§ t√§m√§n alle koodi tarkistaaksesi vastauskoodin, ja jos se on 200 (onnistuminen), poimi √§√§nilista ja hae ensimm√§inen √§√§ni listasta:

    ```cpp
    if (httpResponseCode == 200)
    {
        String result = httpClient.getString();
        Serial.println(result);

        DynamicJsonDocument doc(1024);
        deserializeJson(doc, result.c_str());

        JsonArray obj = doc.as<JsonArray>();
        _voice = obj[0].as<String>();

        Serial.print("Using voice ");
        Serial.println(_voice);
    }
    else
    {
        Serial.print("Failed to get voices - error ");
        Serial.println(httpResponseCode);
    }
    ```

1. T√§m√§n j√§lkeen lopeta HTTP-asiakasliittym√§n yhteys:

    ```cpp
    httpClient.end();
    ```

1. Avaa `main.cpp`-tiedosto ja lis√§√§ seuraava include-direktiivi alkuun sis√§llytt√§√§ksesi t√§m√§n uuden otsikkotiedoston:

    ```cpp
    #include "text_to_speech.h"
    ```

1. `setup`-funktiossa, `speechToText.init();`-kutsun alapuolelle, lis√§√§ seuraava `TextToSpeech`-luokan alustamiseksi:

    ```cpp
    textToSpeech.init();
    ```

1. Rakenna t√§m√§ koodi, lataa se Wio Terminaliin ja testaa se sarjamonitorin kautta. Varmista, ett√§ funktiosovelluksesi on k√§ynniss√§.

    N√§et funktiosovelluksesta palautetun saatavilla olevien √§√§nien listan sek√§ valitun √§√§nen.

    ```output
    --- Available filters and text transformations: colorize, debug, default, direct, hexlify, log2file, nocontrol, printable, send_on_enter, time
    --- More details at http://bit.ly/pio-monitor-filters
    --- Miniterm on /dev/cu.usbmodem1101  9600,8,N,1 ---
    --- Quit: Ctrl+C | Menu: Ctrl+T | Help: Ctrl+T followed by Ctrl+H ---
    Connecting to WiFi..
    Connected!
    Got access token.
    ["en-US-JennyNeural", "en-US-JennyMultilingualNeural", "en-US-GuyNeural", "en-US-AriaNeural", "en-US-AmberNeural", "en-US-AnaNeural", "en-US-AshleyNeural", "en-US-BrandonNeural", "en-US-ChristopherNeural", "en-US-CoraNeural", "en-US-ElizabethNeural", "en-US-EricNeural", "en-US-JacobNeural", "en-US-MichelleNeural", "en-US-MonicaNeural", "en-US-AriaRUS", "en-US-BenjaminRUS", "en-US-GuyRUS", "en-US-ZiraRUS"]
    Using voice en-US-JennyNeural
    Ready.
    ```

## Muunna teksti puheeksi

Kun sinulla on √§√§ni k√§ytett√§v√§ksi, sit√§ voidaan k√§ytt√§√§ tekstin muuttamiseen puheeksi. Samat muistirajoitukset, jotka koskevat √§√§ni√§, p√§tev√§t my√∂s puheen muuttamiseen tekstiksi, joten sinun t√§ytyy kirjoittaa puhe SD-kortille, jotta se voidaan toistaa ReSpeakerin kautta.

> üíÅ Aiemmissa oppitunneissa t√§ss√§ projektissa k√§ytit flash-muistia mikrofonista tallennetun puheen s√§ilytt√§miseen. T√§m√§ oppitunti k√§ytt√§√§ SD-korttia, koska sen kautta on helpompi toistaa √§√§nt√§ Seeed-audiokirjastojen avulla.

On my√∂s toinen rajoitus, joka t√§ytyy ottaa huomioon: saatavilla oleva puhepalvelun tuottama audiodata ja Wio Terminalin tukemat formaatit. Toisin kuin t√§ysimittaiset tietokoneet, mikro-ohjainten audiokirjastot voivat olla hyvin rajallisia tukemiensa audioformaattien suhteen. Esimerkiksi Seeed Arduino Audio -kirjasto, joka voi toistaa √§√§nt√§ ReSpeakerin kautta, tukee vain √§√§niformaatteja, joiden n√§ytteenottotaajuus on 44.1KHz. Azure-puhepalvelut voivat tarjota √§√§nt√§ useissa formaateissa, mutta mik√§√§n niist√§ ei k√§yt√§ t√§t√§ n√§ytteenottotaajuutta; ne tarjoavat vain 8KHz, 16KHz, 24KHz ja 48KHz. T√§m√§ tarkoittaa, ett√§ √§√§ni t√§ytyy uudelleenn√§ytteist√§√§ 44.1KHz:iin, mik√§ vaatisi enemm√§n resursseja kuin Wio Terminalilla on, erityisesti muistia.

Kun dataa t√§ytyy k√§sitell√§ t√§ll√§ tavalla, on usein parempi k√§ytt√§√§ serverit√∂nt√§ koodia, erityisesti jos data on per√§isin verkkopyynn√∂st√§. Wio Terminal voi kutsua serverit√∂nt√§ funktiota, v√§litt√§√§ tekstin muutettavaksi, ja serverit√∂n funktio voi sek√§ kutsua puhepalvelua tekstin muuttamiseksi puheeksi ett√§ uudelleenn√§ytteist√§√§ √§√§nen tarvittavaan n√§ytteenottotaajuuteen. Se voi sitten palauttaa √§√§nen Wio Terminalin tarvitsemassa muodossa, jotta se voidaan tallentaa SD-kortille ja toistaa ReSpeakerin kautta.

### Teht√§v√§ - luo serverit√∂n funktio tekstin muuttamiseksi puheeksi

1. Avaa `smart-timer-trigger`-projektisi VS Codessa ja avaa terminaali varmistaen, ett√§ virtuaaliymp√§rist√∂ on aktivoitu. Jos ei, lopeta ja luo terminaali uudelleen.

1. Lis√§√§ uusi HTTP-triggeri t√§h√§n sovellukseen nimelt√§ `text-to-speech` k√§ytt√§m√§ll√§ seuraavaa komentoa VS Code -terminaalissa funktiosovelluksen projektin juurikansiossa:

    ```sh
    func new --name text-to-speech --template "HTTP trigger"
    ```

    T√§m√§ luo HTTP-triggerin nimelt√§ `text-to-speech`.

1. [librosa](https://librosa.org)-Pip-paketilla on funktioita √§√§nen uudelleenn√§ytteist√§miseen, joten lis√§√§ t√§m√§ `requirements.txt`-tiedostoon:

    ```sh
    librosa
    ```

    Kun t√§m√§ on lis√§tty, asenna Pip-paketit seuraavalla komennolla VS Code -terminaalista:

    ```sh
    pip install -r requirements.txt
    ```

    > ‚ö†Ô∏è Jos k√§yt√§t Linuxia, mukaan lukien Raspberry Pi OS:√§√§, sinun t√§ytyy ehk√§ asentaa `libsndfile` seuraavalla komennolla:
    >
    > ```sh
    > sudo apt update
    > sudo apt install libsndfile1-dev
    > ```

1. Tekstin muuttamiseksi puheeksi et voi k√§ytt√§√§ puhepalvelun API-avainta suoraan, vaan sinun t√§ytyy pyyt√§√§ k√§ytt√∂oikeustunnus, k√§ytt√§en API-avainta autentikoimaan k√§ytt√∂oikeustunnuspyynn√∂n. Avaa `__init__.py`-tiedosto `text-to-speech`-kansiosta ja korvaa kaikki sen koodi seuraavalla:

    ```python
    import io
    import os
    import requests
    
    import librosa
    import soundfile as sf
    import azure.functions as func
    
    location = os.environ['SPEECH_LOCATION']
    speech_key = os.environ['SPEECH_KEY']
    
    def get_access_token():
        headers = {
            'Ocp-Apim-Subscription-Key': speech_key
        }
    
        token_endpoint = f'https://{location}.api.cognitive.microsoft.com/sts/v1.0/issuetoken'
        response = requests.post(token_endpoint, headers=headers)
        return str(response.text)
    ```

    T√§m√§ m√§√§ritt√§√§ vakioita sijainnille ja puheavaimelle, jotka luetaan asetuksista. Se m√§√§ritt√§√§ my√∂s `get_access_token`-funktion, joka hakee k√§ytt√∂oikeustunnuksen puhepalvelulle.

1. Lis√§√§ t√§m√§n koodin alle seuraava:

    ```python
    playback_format = 'riff-48khz-16bit-mono-pcm'

    def main(req: func.HttpRequest) -> func.HttpResponse:
        req_body = req.get_json()
        language = req_body['language']
        voice = req_body['voice']
        text = req_body['text']
    
        url = f'https://{location}.tts.speech.microsoft.com/cognitiveservices/v1'
    
        headers = {
            'Authorization': 'Bearer ' + get_access_token(),
            'Content-Type': 'application/ssml+xml',
            'X-Microsoft-OutputFormat': playback_format
        }
    
        ssml =  f'<speak version=\'1.0\' xml:lang=\'{language}\'>'
        ssml += f'<voice xml:lang=\'{language}\' name=\'{voice}\'>'
        ssml += text
        ssml += '</voice>'
        ssml += '</speak>'
    
        response = requests.post(url, headers=headers, data=ssml.encode('utf-8'))
    
        raw_audio, sample_rate = librosa.load(io.BytesIO(response.content), sr=48000)
        resampled = librosa.resample(raw_audio, sample_rate, 44100)
        
        output_buffer = io.BytesIO()
        sf.write(output_buffer, resampled, 44100, 'PCM_16', format='wav')
        output_buffer.seek(0)
    
        return func.HttpResponse(output_buffer.read(), status_code=200)
    ```

    T√§m√§ m√§√§ritt√§√§ HTTP-triggerin, joka muuntaa tekstin puheeksi. Se poimii tekstin, kielen ja √§√§nen JSON-rungosta, joka on l√§hetetty pyynt√∂√∂n, rakentaa SSML:n puhepyynt√∂√§ varten, ja kutsuu asiaankuuluvaa REST-API:a autentikoiden k√§ytt√∂oikeustunnuksella. T√§m√§ REST-API-kutsu palauttaa √§√§nen koodattuna 16-bittiseksi, 48KHz mono WAV-tiedostoksi, joka on m√§√§ritelty `playback_format`-arvolla, joka l√§hetet√§√§n REST-API-kutsuun.

    T√§m√§ uudelleenn√§ytteistet√§√§n `librosa`-kirjastolla n√§ytteenottotaajuudesta 48KHz n√§ytteenottotaajuuteen 44.1KHz, ja t√§m√§ √§√§ni tallennetaan binaariseen puskuriin, joka sitten palautetaan.

1. Aja funktiosovelluksesi paikallisesti tai julkaise se pilveen. Voit sitten kutsua t√§t√§ ty√∂kalulla, kuten curl, samalla tavalla kuin testasit `text-to-timer` HTTP-triggeri√§. Muista v√§litt√§√§ kieli, √§√§ni ja teksti JSON-runkona:

    ```json
    {
        "language": "<language>",
        "voice": "<voice>",
        "text": "<text>"
    }
    ```

    Korvaa `<language>` kielell√§si, kuten `en-GB` tai `zh-CN`. Korvaa `<voice>` haluamallasi √§√§nell√§. Korvaa `<text>` tekstill√§, jonka haluat muuttaa puheeksi. Voit tallentaa tuloksen tiedostoon ja toistaa sen mill√§ tahansa WAV-tiedostoja toistavalla audioplayerilla.

    Esimerkiksi muuntaaksesi "Hello" puheeksi k√§ytt√§en Yhdysvaltain englantia ja Jenny Neural -√§√§nt√§, kun funktiosovellus on k√§ynniss√§ paikallisesti, voit k√§ytt√§√§ seuraavaa curl-komentoa:

    ```sh
    curl -X GET 'http://localhost:7071/api/text-to-speech' \
         -H 'Content-Type: application/json' \
         -o hello.wav \
         -d '{
           "language":"en-US",
           "voice": "en-US-JennyNeural",
           "text": "Hello"
         }'
    ```

    T√§m√§ tallentaa √§√§nen `hello.wav`-tiedostoon nykyisess√§ hakemistossa.

> üíÅ L√∂yd√§t t√§m√§n koodin [code-spoken-response/functions](../../../../../6-consumer/lessons/3-spoken-feedback/code-spoken-response/functions)-kansiosta.

### Teht√§v√§ - hae puhe Wio Terminalistasi

1. Avaa `smart-timer`-projektisi VS Codessa, jos se ei ole jo auki.

1. Avaa `config.h`-otsikkotiedosto ja lis√§√§ URL funktiosovelluksellesi:

    ```cpp
    const char *TEXT_TO_SPEECH_FUNCTION_URL = "<URL>";
    ```

    Korvaa `<URL>` URL:lla `text-to-speech` HTTP-triggerille funktiosovelluksessasi. T√§m√§ on sama kuin `TEXT_TO_TIMER_FUNCTION_URL`-arvo, paitsi ett√§ funktiolla on nimi `text-to-speech` eik√§ `text-to-timer`.

1. Avaa `text_to_speech.h`-otsikkotiedosto ja lis√§√§ seuraava metodi `TextToSpeech`-luokan `public`-osioon:

    ```cpp
    void convertTextToSpeech(String text)
    {
    }
    ```

1. Lis√§√§ `convertTextToSpeech`-metodiin seuraava koodi JSON:n luomiseksi, joka l√§hetet√§√§n funktiosovellukseen:

    ```cpp
    DynamicJsonDocument doc(1024);
    doc["language"] = LANGUAGE;
    doc["voice"] = _voice;
    doc["text"] = text;

    String body;
    serializeJson(doc, body);
    ```

    T√§m√§ kirjoittaa kielen, √§√§nen ja tekstin JSON-dokumenttiin ja sarjoittaa sen merkkijonoksi.

1. Lis√§√§ t√§m√§n alle seuraava koodi funktiosovelluksen kutsumiseksi:

    ```cpp
    HTTPClient httpClient;
    httpClient.begin(_client, TEXT_TO_SPEECH_FUNCTION_URL);

    int httpResponseCode = httpClient.POST(body);
    ```

    T√§m√§ luo HTTPClientin ja tekee POST-pyynn√∂n JSON-dokumentilla tekstist√§ puheeksi HTTP-triggerille.

1. Jos kutsu onnistuu, funktiosovelluksen palauttama raaka binaaridata voidaan streamata tiedostoon SD-kortilla. Lis√§√§ seuraava koodi t√§m√§n tekemiseksi:

    ```cpp
    if (httpResponseCode == 200)
    {            
        File wav_file = SD.open("SPEECH.WAV", FILE_WRITE);
        httpClient.writeToStream(&wav_file);
        wav_file.close();
    }
    else
    {
        Serial.print("Failed to get speech - error ");
        Serial.println(httpResponseCode);
    }
    ```

    T√§m√§ koodi tarkistaa vastauksen, ja jos se on 200 (onnistuminen), binaaridata streamataan tiedostoon SD-kortin juureen nimelt√§ `SPEECH.WAV`.

1. T√§m√§n metodin lopussa sulje HTTP-yhteys:

    ```cpp
    httpClient.end();
    ```

1. Nyt teksti, joka halutaan lausua, voidaan muuntaa √§√§neksi. `main.cpp`-tiedostossa lis√§√§ seuraava rivi `say`-funktion loppuun muuntaaksesi lausuttavan tekstin √§√§neksi:
```cpp
    textToSpeech.convertTextToSpeech(text);
    ```

### Teht√§v√§ - toista √§√§nt√§ Wio Terminalilla

**Tulossa pian**

## Funktiosovelluksen julkaiseminen pilveen

Funktiosovelluksen suorittaminen paikallisesti johtuu siit√§, ett√§ `librosa`-Pip-paketilla Linuxissa on riippuvuus kirjastoon, joka ei ole oletuksena asennettu ja joka t√§ytyy asentaa ennen kuin funktiosovellus voi toimia. Funktiosovellukset ovat palvelimettomia - ei ole palvelimia, joita voisit hallita itse, joten t√§t√§ kirjastoa ei voi asentaa etuk√§teen.

Ratkaisu t√§h√§n on sen sijaan julkaista funktiosovellus Docker-kontin avulla. T√§m√§ kontti otetaan pilvess√§ k√§ytt√∂√∂n aina, kun tarvitaan uusi instanssi funktiosovelluksestasi (esimerkiksi silloin, kun kysynt√§ ylitt√§√§ k√§ytett√§viss√§ olevat resurssit tai jos funktiosovellusta ei ole k√§ytetty pitk√§√§n aikaan ja se on suljettu).

Ohjeet funktiosovelluksen luomiseen ja Dockerin kautta julkaisemiseen l√∂yd√§t [Microsoft Docsin Linuxilla mukautetun kontin avulla funktioiden luomisen dokumentaatiosta](https://docs.microsoft.com/azure/azure-functions/functions-create-function-linux-custom-image?WT.mc_id=academic-17441-jabenn&tabs=bash%2Cazurecli&pivots=programming-language-python).

Kun t√§m√§ on julkaistu, voit siirt√§√§ Wio Terminal -koodisi k√§ytt√§m√§√§n t√§t√§ funktiota:

1. Lis√§√§ Azure Functions -sertifikaatti tiedostoon `config.h`:

    ```cpp
    const char *FUNCTIONS_CERTIFICATE =
        "-----BEGIN CERTIFICATE-----\r\n"
        "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\r\n"
        "-----END CERTIFICATE-----\r\n";
    ```

1. Vaihda kaikki `
<WiFiClient.h>`-sis√§llytykset `<WiFiClientSecure.h>`-sis√§llytyksiin.

1. Vaihda kaikki `WiFiClient`-kent√§t `WiFiClientSecure`-kentiksi.

1. Lis√§√§ jokaiseen luokkaan, jossa on `WiFiClientSecure`-kentt√§, konstruktori ja aseta sertifikaatti siin√§ konstruktorissa:

    ```cpp
    _client.setCACert(FUNCTIONS_CERTIFICATE);
    ```

---

**Vastuuvapauslauseke**:  
T√§m√§ asiakirja on k√§√§nnetty k√§ytt√§m√§ll√§ teko√§lypohjaista k√§√§nn√∂spalvelua [Co-op Translator](https://github.com/Azure/co-op-translator). Vaikka pyrimme tarkkuuteen, huomioithan, ett√§ automaattiset k√§√§nn√∂kset voivat sis√§lt√§√§ virheit√§ tai ep√§tarkkuuksia. Alkuper√§ist√§ asiakirjaa sen alkuper√§isell√§ kielell√§ tulisi pit√§√§ ensisijaisena l√§hteen√§. Kriittisen tiedon osalta suositellaan ammattimaista ihmisk√§√§nn√∂st√§. Emme ole vastuussa v√§√§rink√§sityksist√§ tai virhetulkinnoista, jotka johtuvat t√§m√§n k√§√§nn√∂ksen k√§yt√∂st√§.